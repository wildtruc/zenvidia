#! /bin/bash

#  Zenvidia
#  Sat Feb  6 16:58:20 2010
#  Copyright  2010-2016  PirateProd
#  <wildtruc@noneltd.net>
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with main.c;if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301,  USA

# set -E

### ZENVIDIA VARS
install_dir=/usr/local							# default tools & system install directory
nvdir=$install_dir/zenvidia					# default Zenvidia directory
conf_dir=$nvdir
script_conf=$nvdir/script.conf				# Zenvidia conf file
nv_root=/opt											# Nvidia main driver directory
nvtmp="$nvdir/temp"								# extract temp directory
buildtmp="$nvdir/build"							# build temp directory
nvlog="$nvdir/log"								# logs directory
nvdl="$nvdir/release"							# downlaod driver backups directory
nvbackup="$nvdir/backups"
nvcompat="$nvdir/compats"
### NVIDIA-INSTALLER VARS ###					# nvidia-installer option: install temp dir
nvi_docs="$install_dir/share/doc/NVIDIA_GLX-1.0"
zen_docs="$install_dir/share/doc/zenvidia"
docs="--documentation-prefix=$install_dir"
profile="--application-profile-path=$install_dir/share/nvidia"
icon_stock=$install_dir/share/pixmaps
img_zen_desktop=$icon_stock/swiss_knife.png
img_zen_bar=swiss_knife
# user_DL_DIR=$(su "$(who | awk '{print $1}')" xdg-user-dir DOWNLOAD)
xt_hold=0
xt_delay=4



E="Download"
PM="Back to previous menu"
MM="Back to main menu"
I="Quit"
CC="Confirm"
R="Back to main"
GO="Go on"
## Classic answer
ansOK="OK"
ansNF="NOT PRESENT"
ansNA="NONE"
ansCF="Confirm your choice."
ansWN="What do you want to do ?"

## terminal fonts colors.
red='\e[1;31m'
yel='\e[0;33m'
grn='\e[0;32m'
blu='\e[0;34m'
cya='\e[0;36m'
pur='\e[0;35m'
nc='\e[0m'

## PROLOGUE ###

## check if X server is alive
ps -A | grep -i xorg &>/dev/null
eval x_alive=$?
## save sys IFS variable for restoration purpose.
## ex: IFS=$' \t\n'
ifs=$IFS
## read script mandatory vars config first.
. $script_conf

dep_exec_check(){
	## clean depencies list if any.
	unset deplist
	#p_xterm=$(command -v xterm) || deplist+=("xterm")
	## multi distro system bianries compatibilities.
	d_lspci=$(command -v lspci)
	d_modinfo=$(command -v modinfo)
	d_sys=$(command -v systemctl)
	p_git=$(command -v git) || deplist+=("git")
	p_wget=$(command -v wget) || deplist+=("wget")
	p_gcc=$(command -v gcc) || deplist+=("gcc")
	p_dkms=$(command -v dkms) || deplist+=("dkms")
	d_yad=$(command -v yad) || deplist+=("yad")
	d_zen=$(command -v zenity) || deplist+=("zenity")
	d_xdpy=$(command -v xdpyinfo) || deplist+=("xdpyinfo")
	d_ssl=$(command -v openssl) || deplist+=("openssl")
	d_randr=$(command -v xrandr) || deplist+=("xrandr")
	d_nv_installer=$(command -v nvidia-installer)
	d_nv_settings=$(command -v nvidia-settings)
	d_nv_probe=$(command -v nvidia-modprobe)
	d_probe=$(command -v modprobe)
	i_sys=$(command -v dracut)
	i_init=$(command -v update-initramfs)
	i_cpio=$(command -v mkinitcpio)
	# grub could be, grub-[command] or grub2-[command]. Let 'find' catch it for us.
	d_grub=$(find /usr/{sbin,local/sbin} -regextype sed -regex ".*grub[0-9]\?-.*"| sed -n "s/-.*$//;1p")
}
## find first default values for distro and desktop user
## define who is facing the screen.
def_user(){
	user=$(who | grep "(:[0-9])" | awk '{print $1}')
	test "$user" && echo $user || echo $USER
	return
}
su_cmd(){
	case $plug_version in
# 		arch|sles|mageia|mandriva) su_cmd='su -l';;
		rhel|fedora|ubuntu|mint|debian) echo "$(command -v sudo) -u" && return;;
		*) echo "$(command -v su)" && return;;
	esac
}
user_DL_DIR(){
	if [ $x_alive -eq 0 ]; then
		if [[ $(whoami) == "root" ]]; then
			echo $( $(su_cmd) $(def_user) xdg-user-dir DOWNLOAD )
		else
			echo "xdg-user-dir DOWNLOAD"
		fi
		return
	fi
}
user_CF_DIR(){
	if [ $x_alive -eq 0 ]; then
		if [[ $(whoami) == "root" ]]; then
			echo $( $(su_cmd) $(def_user) xdg-user-dir )'/.zenvidia'
		else
			echo "/home/$USER/.zenvidia"
		fi
		return
	fi
}
rem_drv_list(){
	if ! [ -f $(user_CF_DIR)/notify/drvlist ]; then
		$su_cmd "$(def_user)" $(command -v zen_notify) -n &>/dev/null
	fi
	echo "$(user_CF_DIR)/notify/drvlist" && return
}
distro_version(){ # var
	## taken from DKMS script for conformity with dkms queries.
	if [[ -r /etc/os-release ]]; then
		. /etc/os-release
		if [[ "$ID" = "ubuntu" ]]; then
			# ID_LIKE=debian in ubuntu
			echo $ID
		elif [[ ${#ID_LIKE[@]} != 0 ]]; then
			echo ${ID_LIKE[0]}
		else
			echo $ID
		fi
		return
	fi
	local DISTRIB_ID
	# Try the LSB-provided strings first
	if [ -r /etc/lsb-release ]; then
		. /etc/lsb-release
	elif type lsb_release &>/dev/null; then
		DISTRIB_ID=$(lsb_release -i -s)
	fi
	## fix case sensitive
	case ${DISTRIB_ID} in
		Fedora) echo fedora ;;
		RedHatEnterprise*|CentOS|ScientificSL) echo rhel ;;
		SUSE*) echo sles ;;
		Arch) echo arch ;;
		*) if [[ ${DISTRIB_ID} ]]; then
				echo "${DISTRIB_ID}"
			else
				echo unknown
			fi
		;;
	esac
}
win_warning(){
	if [ $zenity_ver -le 3420 ]; then
		win_icon='--window-icon='$img_zen_desktop
		icon_name='--icon-name'
	else
		win_icon=''
		icon_name='--icon'
	fi
	$d_zen --width=450 --title="$_zen_title" $win_icon --warning --no-wrap \
	--text="$w_text" $icon_name=$icone --ok-label="$w_label"
}
set_su(){
	w_text=$(cat <<-WRN
	<b><big>Zenvida didn't find any Distro config file for $plug_version</big></b>

	Next window will ask for distribution <b>name</b> and/or <b>sudo</b> command line
	options for default user admin priviledge.
	<i>( ex: sudo -l, sudo -u, etc )</i>
	WRN
	)
	icone='important'
	w_label='Got it!'
	win_warning

	if [ "$plug_version" == "unknown" ]; then
		w_text=$( cat <<-MSG
			Enter name and <b>sudo</b> type command line arguments.
		MSG
		)
		zen_entry='--add-entry=Distribution'
	else
		w_text=$( cat <<-MSG
			Enter <b>sudo</b> type command line and option
		MSG
		)
	fi
	set_args=$($d_zen --height=200 --width=100 --title="$_zen_title" $win_icon --forms \
	--text="$w_text" --separator=';' $zen_entry --add-entry="sudo command")
	if [ $? = 0 ]; then
		[ "$set_args" != '' ] || exit 0
		if [[ "$set_args" =~ ';' ]]; then
			plug_version=$(echo "$set_args"|cut -d';' -f1)
			plug_conf=$plug_version.conf
			su_cmd=$(echo "$set_args"|cut -d';' -f2)
		else
			su_cmd="$set_args"
		fi
		if [ $(grep -c "su_cmd=" $script_conf ) -eq 0 ]; then echo -e 'su_cmd="'$su_cmd'"' >> $script_conf; fi
	else
		exit 0
	fi
}
distro(){
	plug_version=$(distro_version)
	plug_conf=$plug_version.conf
	if [ "$(def_user)" != "root" ]; then
		if [[ ! -e $conf_dir/distro/$plug_conf ]]; then
			if [[ $(ls -1 $conf_dir/distro | grep -ic "$plug_conf" ) -gt 0 ]]; then
			## conf file exist but in a different upper/lower case.
				dest_conf=$(ls -1 $conf_dir/distro | grep -i "$plug_conf")
			else
			## conf doesn't exist and need to be created
				## check first if name is unknown and ask default su commabnd for user admin priv.
				set_su
				cat <<-CONF > $(user_CF_DIR)/$plug_conf
					## examples between [...] have to be remove by real texts, vars, commands.
					## You can reset detected or set name to friendly one to display in Zenvidia.
					DISTRO="$plug_version"
					kernel=\$( uname -r | cut -d '-' -f 1 )
					## optional kernel devel package extension sometime needed (see ex. below in p_kernel)
					d_version=[ex: \$( uname -r | cut -d '-' -f 1,2 )]
					## define X server executable.
					X="[X]"
					## define package installer and options.
					PKG_INSTALLER="[ex: dnf]"
					pkg_cmd='[ex: install]'
					## auto "yes" option, final space is here needed.
					pkg_opts='[ex: -y ]'
					## default distro 32/64 libs directories.
					if [[ \$ELF_TYPE == 64 ]]; then
						ELF_32="[ex: /i386-linux-gnu or nothing]"
						ELF_64="[ex: /x86_64-linux-gnu or 64]"
						master=lib
					else
						## usualy 32 bit distro doesn't need any special libs definitions.
						ELF_32=""
						ELF_64=""
						master=lib
					fi
					## grub/grub2 directory if different than usual.
					grub_dir=[def: /boot/grub2]
					## define specific dir extension for kernel header and drivers source directory if any.
					alt=[ex: /kernels for /usr/src/kernels/ instead of /usr/src/]
					## default distro kernel sources.
					kernel_src=[ex: /usr/src\$alt/\$(uname -r)]
					## default initramfs updater commend (ex: dracut -f, update-initramfs, etc)
					INITRAM='[ex: dracut -f]'
					if [ \$resolve_dep = 0 ]; then
					## distro specific depencies
					## You can had there any packages matching specific distro needs.
					## ex: deplist+=("package1"), deplist+=("package2"), etc
						deplist+=("[ex: kernel-devel, kernel-headers-\$(uname -r), gksu]")
						deplist+=("")
					fi
				CONF
				## warn about no config file
				w_text=$(cat <<-WRN
				<b>Main $plug_version distro variables are now setted</b>

				You need to create a <u>new configuration</u> based on your distro environment variables.

				<i>Note : Even in case you are not sure of what you are doing, new configuratin file will be saved anyway.
				You will just have to go back to it in <u>$(user_CF_DIR)/$plug_conf</u> afterward.</i>
				WRN
				)
				icone='xkill'
				w_label="Let's go"
				win_warning
				## edit new config file.
				edit_plug_conf=$( $d_zen --width=640 --height=400 --title="Zenvidia $plug_version edition" \
				$win_icon --text-info --editable \
				--filename="$(user_CF_DIR)/$plug_conf" --checkbox="Confirm to write" --cancel-label="Abort (panic button)" \
				--ok-label="Create config file")
				if [ $? = 0 ]; then
					echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf
				else
					## display error message and close all processes.
					w_text=$(cat <<-WRN
					<b>Zenvida can't work without Distro config file for $plug_version</b>

					<u>Don't ask the dev, if didn't create one, it's probably he doesn't know how to.</u>

					You can try having a look at your distro's community forum and ask for help
					or see Zenvidia's git discussion feed.
					Then going back to the saved config file in $(user_CF_DIR)
					WRN
					)
					$d_zen --width=450 --title="$_zen_title" --error --no-wrap \
					--text="$w_text" $icon_name=xkill --ok-label="Snif!"
						exit 0
					fi
			fi
		else
			dest_conf=$(ls -1 $conf_dir/distro | grep -i "$plug_conf")
		fi
		test -f $(user_CF_DIR)/$plug_conf || cp -f $conf_dir/distro/$dest_conf $(user_CF_DIR)/$plug_conf
		. $(user_CF_DIR)/$plug_conf
	else
		## this is here add to get compatibility in terminal only mode and isn't used in graphic mode.
		plug_conf=$(ls -1 $conf_dir/distro |grep -i "$plug_version")
		if test -f $conf_dir/distro/$plug_conf; then
		    . $conf_dir/distro/$plug_conf
		else
		    echo -e "${red} # No distribution conf file found. Abort.${nc}"
		    exit 0
		fi
	fi
	# CHECK that /usr/local/ for lib is in LD path
	for LD in "$ELF_32" "$ELF_64"; do
		if [ $(ldconfig -p |grep -c "$install_dir/$master$LD") -eq 0 ]; then
			printf "$install_dir/$master$LD" > /etc/ld.so.conf.d/local-lib$LD.conf
		fi
	done
}
module_dest_location(){
	case "$(distro_version)" in
		fedora* | rhel* | ovm*) echo "extra" && return ;;
		sles* | suse* | opensuse*) echo "updates" && return ;;
		debian* | ubuntu*) echo "updates/dkms" && return ;;
		arch*) echo "updates/dkms" && return ;;
		*) echo "extra" && return ;;
	esac
}
dm_serv(){
	for dm in {gdm,kdm,xdm,lightdm,lxdm,slim,sddm}; do
		if test -f /usr/lib/systemd/system/$dm.service; then echo "$dm" ; break; else dm=0; fi
	done
	if [ $dm = 0 ]; then
		## if DM is not found, try to dig in display manager service status.
		## wont work if DM service already disable, but will in case of x server crash.
# 		echo "$($d_sys show display-manager.service | sed -En "s/^Docu.*=[\"]?.*:(.*)\(.*\)[\"]?/\1/p")"
		echo "$($d_sys show display-manager.service | sed -En "s/^Id=(.*)\..*$/\1/p")"
	fi
	return
}
zen_colors(){
	# pango colors
	end='</span>'
	v='<span color="'$main'" weight="normal" font="'$size0'" font_family="'$font0'">'	#green
	j='<span color="'$sub'">'			#orange/yellow
	y='<span color="'$log_msg'">'		#cyan/blue
	r='<span color="'$title'">'
	# big red orange title
	rBB='<span color="'$title'" weight="bold" font="20" font_family="'$font1'">'	#red
	# Big
	bf='<span font="'$size1'">'
	nf='<span font="'$size0'">'
	mf='<span font="'$(($size0+2))'">'
	sf='<span font="'$(($size0-2))'">'
	# Bold
	vB='<span color="'$main'" weight="bold" font="'$size0'" font_family="'$font0'">'
	yB='<span color="'$log_msg'" weight="bold" font_family="'$font0'">'
	jB='<span color="'$log_warn'" weight="bold" font_family="'$font0'">'
	gB='<span color="'$log_grn'" weight="bold" font_family="'$font0'">'
	rB='<span color="'$log_err'" weight="bold" font_family="'$font0'">'
	# grey dash
	# 	ge='<span color="#68686F" weight="bold">' #68686F
	ge='<span color="#68686F">'
	nr='<span color="#000000">'
	## xterm colors
	xt_colors='-fg '$fg_xterm' -bg '$bg_xterm
	xN='\e[0m'
	xB='\e[1m'
}
### SYSTEM FUNCTIONS
PCI_ID(){
	## graphic cards id
	unset dev_n dev slot slot_id vnd vnd_id
	i=0
	optimus=0
	test $UID = 0 && tee /sys/bus/pci/rescan <<<1
	sleep 1
	## rescan in case of device power switch off (nvidia-xrun, bbswitch, etc).
	pci_list=( "$(lspci -mnn | grep "VGA")" )
	IFS=$(echo -en "\n\b")
	for dev_slot in ${pci_list[@]}; do
		dev_n+=("$i")
		vnd+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^(.*) \[.*\]$/\1/p")")
		vnd_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
		if [[ "${vnd_id[$i]}" =~ "10de" ]]; then
			dev+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}'| sed -En "s/^.*\[(.*)\] \[.*\].*$/\1/p")")
			dev_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
			dev_name=${dev[0]}
		else
			[ "${vnd_id[$i]}" = "8086" ] && dev+=("Intel Graphic") # dev+=("Intel Graphic",modesettings)
			[ "${vnd_id[$i]}" = "1002" ] && dev+=("AMD Radeon") # dev+=("Intel Graphic",flglx)
			[ "${vnd_id[$i]}" = "1022" ] && dev+=("AMD Embed") # dev+=("Intel Graphic",radeon)
			((optimus++))
		fi
		slot+=("$(printf "$dev_slot"| awk '{print $1}')")
		slot_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.*\[.*\] \[(.*)\].*$/\1/p")")
		((i++))
	done
	IFS=$ifs
# 	dev_nb=${#dev_n[*]} # test control
	pci_dev_nb=${dev_n[*]}
	if [ $i -gt 1 ]; then
		if ! [[ "${vnd_id[*]}" =~ "10de" ]]; then
			scan_alert="\n\nNvidia device was not scanned.\nRun again with root priviledge and rescan pci bus."
		fi
	fi
}
# elf types
libclass(){
	# define distro base ELF type
	if [[ $HOSTTYPE =~ "64" ]]; then
# 	if [ $(uname - |grep -c "64") -gt 0 ] ; then
		ELF_TYPE="64"
	else
		ELF_TYPE=""
	fi
}
## dependencies control
dep_control(){
	unset dep_text
# 	deplist=( yad zenity wget ) # test
	if [ "${#deplist[*]}" -gt 0 ] ; then
		for d in ${deplist[@]}; do
			dep_text+=("$d, ")
		done
		dep_text=$(echo "${dep_text[*]}" | sed -n "s/, $//p")' are missing.'
		if [ $UID = 0 ]; then
			context='--question'
			label='Install'
			info='Will you install them now ?'
			EXEC=$(
				cat <<-DEP
					read -p "$info (Y/N) :" confirm
					if [[ "\$confirm" =~ [yY] ]]; then
						$PKG_INSTALLER $pkg_opts$pkg_cmd ${deplist[*]}
						sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
					else
						echo -e "\n${red}Those dependencies are mandatory for Zenvidia.${nc}\n"
						echo -e "If you don't want Zenvidia to install them automatically,"
						echo -e "you need to use your packages manager instead"
						echo -e "BYE !"
					fi
					echo -e "$x_esc_message"
					$x_sleep
				DEP
			)
		else
			context='--warning'
			label='Got it'
			info="You need to restart with ${j}Zenvidia (admin)${end}\n\or use your pacakges manager to install them"
			EXEC=$(
				cat <<-DEP
					echo -e "Zenvidia is start without admin priviledges."
					echo -e "You need to restart with ${red}Zenvidia (admin)${nc} to install them."
					echo -e "$x_esc_message"
					$x_sleep
				DEP
			)
		fi
		w_text=$(
		cat <<-DEP
			#set -x
			echo -e "${red}Script Dependencies Check${nc}\n"

			echo -e "Required dependencies are not met.\n"
			echo -e "$dep_text\n"
			$EXEC
		DEP
		)
# 			if [ $? = 0 ]&&[ $UID = 0 ]; then
# 			if [ $UID = 0 ]; then
# 				if [ $d_yad ]; then # test
			if ! [ $d_yad ]; then
				xterm $xt_options -e "$w_text"
			else
				w_text=$(
				cat <<-DEP
					${j}<b>Script Dependencies Check</b>${end}

					Some required dependencies are not met.
					$dep_text

					$info
				DEP
				)
				if [ $zenity_ver -le 3420 ]; then
					win_icon='--window-icon='$img_zen_desktop
				else
					win_icon=''
				fi
				$d_zen $context --width=400 --text="${v}$w_text${end}" \
				$win_icon --ok-label="$label"
				if [ $? = 0 ]; then
					if [[ "$context" =~ "warning" ]]; then exit 0; fi
					(	$PKG_INSTALLER $pkg_opts$pkg_cmd ${deplist[*]} 2>&1 | \
						while read line; do echo "# ${ge}${sf}${line}${end}${end}"; done
						echo -e "# "
						$esc_message
						$x_sleep ) | \
					$d_yad --width=600 --height=300 --title "Zenvidia" $win_icon \
					--progress --center --hide-text --enable-log='' --log-expanded --log-height=300 \
					--text="${v}Installing missing dependencies${end}" $x_hold
					sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
				else
					exit 0
				fi
			fi
			dep_exec_check
# 			else
# 				exit 0
# 			fi
	fi
}
connection_control(){
	cnx=$(ping -c2 www.nvidia.com)
	cnx=$?
	( if [ $cnx -eq 1 ]; then
		w_text=$( cat <<-MSG
			No internet connection detected.
			A valid network connection is required for any download.
		MSG
		)
		$d_zen --width=300 $win_icon --error --text="${v}$w_text${end}"
	fi ) | $d_zen --width=450 --title="$_zen_title" $win_icon --progress --pulsate --auto-close \
	--text="${v}Connection control...${end}"
	if [ $cnx = 0 ]; then cnx_msg="OK"; else cnx_msg="NONE"; fi
}
## gcc and other compatibility control
compil_vars(){
	if [[ -s $d_nv_installer ]]; then
		NV_bin_ver=$($d_nv_installer -v | grep "nvidia-installer"|awk '{print $3}')
	else
		NV_bin_ver='none'
	fi
	if [[ $(gcc --version | grep "gcc") ]]; then
		GCC=$(gcc --version | grep "gcc" | sed -n "s/^.*) //p"| awk '{print $1}')
	else
		GCC='none'
	fi
	KERNEL=$(uname -r)
	OLD_KERNEL=$(ls -1 /lib/modules | sed -n '/'$KERNEL'/{g;1!p};h')
	# xterm/yad  vars and messages.
	x_pixel=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.* ([0-9]{3,5})x([0-9]{3,5}) .*$/\1;\2/1p")
	x_milli=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.*\(([0-9]{3,4})x([0-9]{3,4}).*\).*$/\1;\2/1p")
	term_x_dsp=$(printf "$x_pixel"| cut -d';' -f1)
	[ $xt_hold = 0 ]|| xx_hold=' -hold'
	if [ $xt_hold = 1 ]; then
		x_esc_message="\n${nc}*****  Close window to escape *****"
		esc_message="# ${nr}*****  Close window to escape *****${end}"
		x_hold=''
		x_sleep=''
	else
		x_esc_message="\n${nc}*****  Window will auto-close in $xt_delay seconds *****"
		esc_message="# ${nr}*****  Window will auto-close in $xt_delay seconds  *****${end}"
		x_hold='--auto-close'
		x_sleep="sleep $xt_delay"
	fi
	xt_options=$xt_colors''$xx_hold' -fn 8x13 -geometry 80x24+'$[ ( ($(printf "$x_pixel"| cut -d';' -f1)-660)/2) ]'+0'
	grub_cfg=$(find /boot -wholename "*/grub.cfg")
	grub_def=/etc/default/grub
}
## define installed driver version, if any
version_id(){
	if [[ ! $(version) ]]; then
		echo "undefined yet"
	else
		echo $(version)
	fi
}
## If version 'undifined', control if driver is initialy installed.
check_version(){
	if ! [[ $(version) =~ [0-9]* || $(new_version) =~ [0-9]* ]]; then
		w_text=$( cat <<-ERR
			${j}${bf}Version text file not found.${end}${end}

			Look like driver isn't installed initialy.
			Go to ${y}<b>» Main menu » Install drivers</b>${end} first.
		ERR
		)
		$d_zen --width=300 $win_icon --error --text="${v}$w_text${end}"
		base_menu
	fi
}

# ### INSTALL & COMPIL SECTION ###
## TOOLS ###
nv_open_modules_set(){
	# nvidia_installer give the possibility to use open driver version, but not the possibility to choose
	# between open or proprietary version by installing both, or just test open only.
	# let's do it.
	if [ $open_wrn = 1 ]; then
		if [ $extract_open = 1 ]; then
			if [ $use_open -ne 1 ]; then
				_title="$_zen_title"
				_text=$(cat <<-MSG
					${jB}Nvidia Open Source Modules${end}
					${vB}Since 515 driver series, it is possible to use nvidia open source drivers
					By default, Zenvidia will build them alongside the main ones.

					AT THIS POINT, OPEN SOURCE DRIVERS WILL BE ONLY BUILD.
					You will be able to switch between version at any time with the ${j}Switch Tool${end}
					in ${j}Configuration and Tools${end} menu (restart Zenvidia is mandatory).

					${j}WARNING ${end}:${v}<i> Open drivers are in still in early state, many features are not
					accessible at this point.
					Check progress in Nvidia Changelog update regulary</i>.${end}

					Do you want to build open source drivers ?${end}
				MSG
				)
				$d_zen --question $win_icon --title="$_title" $icon_name=dialog-warning --text="$_text" \
				--no-wrap --cancel-label="No" --ok-label="Yes"
				if [ $? = 0 ]; then
					open_drv=1; use_open=0
				else
					open_drv=0; use_open=0
				fi
				sed -Ei "s/^(use_open)=[0-9]$/\1=$use_open/" $basic_conf
				sed -Ei "s/^(open_drv)=[0-9]$/\1=$open_drv/" $basic_conf
				if [ $first_open = 1 ]; then
					_text=$(cat <<-MSG
						${jB}Nvidia Open Source Modules${end}

						${j}WARNING ${end}:${vB}By default, Zenvidia send alert about open driver building,
						If you select ${j}<i>NO</i>${end} here, the previous window won't be displayed again.

						${v}<i>(Choice will be saved in configuration file and could be change)</i>${end}

						Do you want to be warn at each drivers upgrade ?${end}
					MSG
					)
					$d_zen --question $win_icon --title="$_title" $icon_name=dialog-warning --text="$_text" \
					--no-wrap --cancel-label="No" --ok-label="Yes"
					if [ $? = 0 ]; then
						first_open=0; open_wrn=1
					else
						first_open=0; open_wrn=0
					fi
					sed -Ei "s/^(open_wrn)=[0-9]$/\1=$open_wrn/" $basic_conf
					sed -Ei "s/^(first_open)=[0-9]$/\1=$first_open/" $basic_conf
				fi
			fi
		fi
	fi
	## check for open drivers source dir in tree
	if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
		cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open /usr/src/open-nvidia-$(new_version)
	fi
}
nv_modules_set(){
	_insert_type=1
	_help_tip=$(cat <<-HLP
		${v}- Unified Memory Module (${j} nvidia-uvm ${end})
		  is required for CUDA driver and application.
		- Prime Sync DRM Module (${j} nvidia-drm ${end})
		  is required for Optimus PRIME modesetting environment.${end}
		If you do not have or intend to use CUDA service and/or Optimus PRIME,
		it is safe to not use them."
	HLP
	)

	## Optimus alert and basic config.
	if [ ${#dev_n[*]} -gt 1 ]; then
		if [ $optimus -gt 0 ]; then
			if [ $no_opti_warn = 0 ]; then
				modules_msg=$(cat <<-TXT
					${v}<b>Optimus Prime detection alert</b>
					More than one different devices detected in the system.

					In this particular case all driver type are mandatory and Zenvidia
					will auto setup drivers for Optimus. Xorg will be prepared for Optimus specific needs.
					<b>Warning</b> : ${j}From there, Optimus/Prime manager tool is mandatory${end}.

					<u>Note</u> : <i>settings will be saved in zenvidia local config and alert wont be shown again.
					Edit Zenvidia local config file to change this behaviour or only Optimus set.</i>

					Do you want to preset Optimus ?${end}
				TXT
				)
				$d_zen --question $win_icon --title="$_zen_title" $icon_name=dialog-warning \
				--text="$modules_msg" --no-wrap --cancel-label="No thanks, I'll figure it out later" --ok-label="Yes, please"
				if [ $? = 0 ]; then
					opti_preset=1
					use_uvm=1
					use_drm=1
				else
					opti_preset=0
				fi
				no_opti_warn=1
				sed -Ei "s/^(no_opti_warn)=[0-9]$/\1=$no_opti_warn/g" $basic_conf
				sed -Ei "s/^(opti_preset)=[0-9]$/\1=$opti_preset/g" $basic_conf
			fi
		fi
	fi
	## get values from previoully optimus sets or config file.
	if [ $hlp_txt = 1 ]; then _tip=$_help_tip; else _tip=''; fi
	if [ $use_uvm -gt 0 ]; then UVM='TRUE'; else UVM='FALSE'; fi
	if [ $use_drm -gt 0 ]; then DRM='TRUE'; else DRM='FALSE'; fi
# 	if [ $use_peer -gt 0 ]; then PEER='TRUE'; else PEER='FALSE'; fi

	## warn about first use.
	modules_msg=$(cat <<-TXT
		${vB}This is the first time you launch this options sets.

		With the next window you can select the nvidia's drivers type you want/need
		to use and will set the basic configuration file for future builds.
		$_help_tip${end}
	TXT
	)
	if [ $no_warn = 0 ]; then
		$d_zen --question $win_icon --title="$_zen_title" $icon_name=dialog-warning \
		--text="$modules_msg" --no-wrap --cancel-label="I got it, don't show me this message again" --ok-label="I got it"
		no_warn=$?
		sed -Ei "s/^(no_warn)=[0-9]$/\1=$no_warn/g" $basic_conf
	fi
	_title="$_zen_title"
	_text=$(cat <<-TXT
		${yB}${bf}Nvidia Optional Modules${end}${end}
		${vB}By default Zenvidia will only use the main Nvidia driver.
		You can select here the optional driver as you need.
		$_tip
		Check the appropriate boxes in list below to use optional drivers.${end}
		${v}Note :<i> nvidia-drm is use by default since 515 serie and will be set to 1</i>.

		<i>(Choice will be saved in configuration file and could be change)</i>${end}
	TXT
	)
	## set modprobe.d files
	black_file=/etc/modprobe.d/nvidia-blacklist.conf
	unset driver_var black_conf modprobe_conf
	driver_var=$($d_zen --width=500 $win_icon --list --title="$_title" --text="$_text" \
	--column="check" --column="2" --column="driver" --checklist --multiple --print-column=2 --hide-column=2 \
	--separator=' ' --hide-header \
	$UVM "use_uvm" "Unified Memory Module (nvidia-uvm)" $DRM "use_drm" "Optimus Prime Sync DRM Module (nvidia-drm)")
	if [ $? = 1 ]; then base_menu; fi
	## sortie : use_uvm use_drm
	## ATTENTION la valeur TRUE implique l'usage et n'est pas blacklistée.
	## La valeur FALSE implique le non usage et est blacklistée.
	for mod in {use_uvm,use_drm}; do
		## if optimus system is detect, set all vars to 1, else, manage as usual.
		if [ $opti_preset = 0 ]; then
			if [[ "$driver_var" =~ "$mod" ]]; then
			# don't blacklist or remove from blacklist.
				class=$(printf "$mod"|cut -c4-)
				black_conf+=("$mod;1;nvidia$class")
			else
			# blacklist or add to blacklist.
				VAL=0
				if [ $(chk_version) -ge 515 ]; then
				## SINCE 515.48 DRM ARE USE BY DEFAULT set is 1.
					if [[ "$mod" == "use_drm" ]]; then
						[ $(grep -c "nvidia$class" $black_file) -gt 0 ]&& VAL=1
					fi
				fi
				class=$(printf "$mod"|cut -c4-)
				black_conf+=("$mod;$VAL;blacklist nvidia$class")
			fi
		else
			class=$(printf "$mod"|cut -c4-)
			black_conf+=("$mod;1;nvidia$class")
			eval $mod=1
		fi
	done
}
gcc_options(){
	# test driver code compilator version __GNUC__, __GNUC_MINOR__
	test $(grep -E -c "gcc_mismatch" $basic_conf) -gt 0 && (
		if [ $gcc_mismatch = 1 ]; then ignore_mismatch="IGNORE_CC_MISMATCH=1"; else ignore_mismatch=''; fi
		export IGNORE_CC_MISMATCH=$gcc_mismatch
	)
	proc=$(grep -E -c "processor.*[0-9]{,2}" /proc/cpuinfo)
}
## PAY ATTENTION : With RT kernel, drivers could install properly but they could also not init at Xorg start.
## Do not ever overwrite current used kernel by RT one.
rt_options(){
# test if kernel is realtime.
	is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
	if [ $is_RT = 1 ]; then
		## user warning
		_title="$_zen_title"
		_text=$( cat <<-TXT
			${rBB}REALTIME Kernel Detected${end}
			${vB}ATTENTION :${v} You are about to install driver on a realtime kernel.

			Don't forget Nvidia kernel is not normaly made for realtime.
			Troubles init at boot time could happen.
			Think about making a root partition backup if you have no fallback.

			${j}"<b> dd if=/dev/sdxx of=root.img bs=1024k status=progress </b>"${end}
			(from a live usb)

			Do you really want to use compilation over realtime kernel ?${end}${end}
			TXT
		)
		$d_zen --question $win_icon $icon_name=dialog-warning --no-wrap \
		--cancel-label="Abort" --ok-label="Proceed" --title="$_title" --text="$_text"
		# yes 0, no 1
		if [ $? = 0 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		else
			base_menu
		fi
	fi
}
nv_drv_list(){
	unset _drv_list
	for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
		if [ $(grep -owc "$drv" /etc/modprobe.d/nvidia-blacklist.conf) -eq 0 ]; then _drv_list+=("$drv"); fi
	done
	echo "${_drv_list[*]}"
}
## vars in functions
## some sets have to be place as function to be re-used at multi levels.
version(){
	test -f $nvdir/version.txt && cat $nvdir/version.txt || echo "0"
	return
}
new_version(){
	if [ $from_install = 1 ]; then
			if [ "$LAST_PACK" ]; then
				echo "$LAST_PACK"
			else
				echo "$run_pkg" | sed -En "s/^.*-(.*)/\1/; s/.run//g;p"
			fi
	else
# 		test $LAST_BETA && echo $LAST_BETA || echo "$(version)"
		echo "$(version)"
	fi
	return
}
old_version(){
	if [ $from_install = 1 ]; then
		$d_modinfo -F version nvidia -k $KERNEL &>/dev/null
		if [ $? -eq 0 ]; then
			if test -f $tmp_old; then
				cat $tmp_old
			else
				$d_modinfo -F version nvidia -k $KERNEL
			fi
		else
			echo "0"
		fi
	else
		## in case of archive restoration, the old version is current version in te kernel.
		if [ "$present_version" ]; then
			test -f $present_version && cat $present_version || echo "0"
		else
			echo "0"
		fi
	fi
	return
}
nv_old(){
	echo "$(old_version)"| sed -n "s/\.//g;p"
	return
}
nv_new(){
	if [ "$(new_version)" ]&&[ "$(new_version)" != "0" ]; then
		echo "$(new_version)"| sed -n "s/\.//g;p"
	else
		echo "$(version)"| sed -n "s/\.//g;p"
	fi
	return
}
mod_installed(){ # used by nv_build_dkms only
 	test -d $kernel_path && find $kernel_path -name "nvidia.*[ko\|ko.xz]" -print0 | xargs -0 modinfo -F version
 	return
}
chk_version(){ echo "$(new_version)"| cut -d'.' -f1; }
## initramfs tools detect and config.
initramfs_tools(){
	## try to find 'dracut' first, then fallbback to 'update-initramfs' if not found.
	## look the possibility to add /usr/bin/mkinitcpio -p linux. how-to ?
	## if none are found, disable ramfs rebuild and warn.
	if test $i_sys; then
		echo "$i_sys -f --kver"
	elif test $i_init; then
		echo "update-initramfs -u -k"
	elif test $i_cpio; then
		echo "mkinitcpio -p linux --kernel"
	else
		echo 0
	fi
}
test_ramfs_tool(){
## detect if ramfs tool exist then send to initramfs_warn if none.
	test "$(initramfs_tools)" = 0 && echo 0 || echo 1
}
initramfs_warn(){
	if [ $(test_ramfs_tool) = 0 ]; then
		## send alert
		## and ask to proceed with modprobe reload if initramfs tool is no detected.
		_text=$( cat <<-WRN
			<b>No tool were found to rebuild initramfs</b>
			Modprobe reload could work for the used kernel,
			but probably not for an extra kernel.
			Updated Modules wont probably load at reboot.

			You have been warn !
		WRN
		)
		zenity --question $icon_name=dialog-warning --no-wrap \
		--cancel-label="Abort" --ok-label="Proceed" --title="$_title" --text="${v}$_text${end}"
		if [ $? = 1 ]; then
			exec_mod_tool=0
			base_menu
		else
			exec_mod_tool=1
		fi
	fi
}
## commands ###
exec_depmod(){
	 if [[ -f /boot/System.map-$1 ]]; then
        /usr/sbin/depmod -a "$1" -F "/boot/System.map-$1"
    else
        /usr/sbin/depmod -a "$1"
    fi
    return $?
}
exec_mod_load(){
	## from DKMS script (partly)
	# ATTENTION modprobe on device only ?
	#nv_pci=$(grep "10de" <<< ${pci_n[*]}|cut -d, -f2 )
# 	nv_pci=${slot[0]}
	#find /sys/devices -regextype sed -regex ".*$nv_pci.*modalias" -print0 | xargs -0 cat | xargs modprobe -b
# 	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.gz"
	# or modprobe on all mandatory ?
	find /sys/devices -name modalias -print0 | xargs -0 cat | xargs modprobe -a -b -q
	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.gz"
	if [ -f /lib/systemd/system/systemd-modules-load.service ]; then
		$d_sys restart systemd-modules-load.service
	fi
	return $?
}
exec_initramfs(){
## rebuild initramfs if modules reload service found is uselees in the case.
	## progress message is place before fuction exec and formated like this :
	## progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; } for zenity.
	## progress_msg(){ echo -en "\r# ($m%) - Rebuilding INITRAMFS"; } for terminal.
	## last 'echo' is for zenity progress bar only. ex:
	# 	echo "# Updating $KERNEL initramfs."; sleep 2
	# 	progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; }
	# 	m=1 ;
# 	progress "$INITRAM --kver $KERNEL"; . $tmp_c ; rm -f $tmp_c
# 	progress "dracut --add-drivers $(nv_drv_list) --kver $KERNEL"; . $tmp_c ; rm -f $tmp_c
	progress "$(initramfs_tools) $KERNEL"; . $tmp_c ; rm -f $tmp_c
	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.gz"
	return $?
}
nv_open_switch(){ # TODO remove blank lines ?
	probe_open=/etc/modprobe.d/open-NVIDIA.conf
	kernel_path=/lib/modules/$KERNEL/$(module_dest_location)
	reverse_conf(){
		[ $open_drv -ne $old_open_drv ]&& sed -Ei "s/^(open_drv)=.*$/\1=$old_open_drv/" $basic_conf
		[ $use_open -ne $old_use_open ]&& sed -Ei "s/^(use_open)=.*$/\1=$old_use_open/" $basic_conf
		menu_modif
	}
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -ne $old_use_open ]; then
			if [ $use_open -eq 1 ]; then
				drv_on='open-nvidia'
				drv_off='nvidia'
			else
				drv_on='nvidia'
				drv_off='open-nvidia'
			fi
				confirm_msg=$( cat <<-MSG
					${j}${bf}$drv_on switch${end}${end}
					${v}You are going to switch from ${j}$drv_off${end} to ${j}$drv_on${end}
					Are you sure ?${end}
				MSG
				)
				val_title="$_zen_title" #TEXT
				val_confirm="Yes, switch to $drv_on" #TEXT
				val_back="No, reverse to $drv_off" #TEXT
				val_cancel="reverse_conf" #TEXT
				val_exit="reverse_conf" #EXIT CMD
				win_confirm
				switch_txt="DRIVER SWITCH from DKMS $drv_on build"
			## Switch exec start here
			{	echo "# Switching from $drv_off to $drv_on."
				if [ -d /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module ]; then
					cp -f /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
					echo -e "# Depmod $KERNEL modules ..."
					sleep 2
					progress_msg(){ echo -e "# Depmod $KERNEL modules ($m sec.)"; }
					m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
				else
					## in case of a fresh kernel update, only the predifined type is compile and install by dkms
					## and thus, var/lib/dkms module dir doesn't exist.
					## It is there need to recompile the all stuff
					tmp_b=$(mktemp --tmpdir zn_vars.XXX)
					nv_build_dkms
				fi
				if [[ $drv_on == "nvidia" ]]; then
					license="NVIDIA"
				else
					license="Dual MIT/GPL"
				fi
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "$license" ]]; then
					echo "# License is $license"
				else
					echo "# ERROR!: License is steal $license, reversing all."
					reverse_conf
				fi
				sleep 2
				## add or remove open-driver kernel options.
				if [ $use_open -eq 1 ]; then
					echo "# Set $drv_on kernel options."
					cat <<-CONF > $probe_open
						options nvidia NVreg_OpenRmEnableUnsupportedGpus=1
					CONF
				else
					echo "# Unset $drv_off kernel options."
					[ -f $probe_open ]&& rm -f $probe_open
				fi
				## systemctl restart systemd-modules-load.service
				progress_msg(){ echo "#  - Exec $KERNEL modules reload ($m sec.)"; echo "$m"; } ; m=1; do_slp=1
				exec_mod_load
				sleep 2
				## add no-autoinstall blank file
				touch /etc/dkms/no-autoinstall
				## set DKMS AUTOINSTALL values for each driver type.
				echo "# Set $drv_on DKMS AUTOINSTALL option to \"yes\"."
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/$drv_on-$(version)/dkms.conf
				sed -Ei "s/AUTOINSTALL=\".*\"//" /usr/src/$drv_off-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
				sed -n "s/AUTOINSTALL.*$/*/i;{/^.*\*$/d;s/^\ //i;p}" /usr/src/$drv_off-$(version)/dkms.conf
				## set diplayed license by driver type.
				sleep 2
				echo "# Reboot for $drv_on to take effect."
				sed -Ei "s/^(use_open)=.*$/\1=$use_open/" $basic_conf
			} | $d_zen --width=450 $win_icon --title="$_zen_title" --progress --pulsate \
			--text="${v}$switch_txt${end}"
		fi
	else
		if [ $open_drv -ne $old_open_drv ]; then
			confirm_msg=$( cat <<-MSG
			${j}${bf}Open Driver removal${end}${end}
			${v}You are going to remove open source driver from driver tree.
			Are you sure ?${end}
			MSG
			)
			val_title="$_zen_title" #TEXT
			val_confirm="Yes, remove" #TEXT
			val_back="No, preserve" #TEXT
			val_cancel="reverse_conf" #TEXT
			val_exit="reverse_conf" #EXIT CMD
			win_confirm
			## remove dkms driver tree.
			{	sleep 2
				echo "# Remove open source drivers from DKMS tree"
				/usr/sbin/dkms remove -m "open-nvidia"/$(version) -all
				sleep 2
				echo "# Restoring default Nvidia drivers."
				cp -f /var/lib/dkms/nvidia/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
				sleep 2
				echo "# Executing depmod"
# 				depmod -a -kver $KERNEL
				progress_msg(){ echo -e "# Depmod $KERNEL modules ($m sec.)"; }
				m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
				sleep 2
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "NVIDIA" ]]; then
					echo "# License is back to NVIDIA"
				else
					echo "# ERROR!: License is still Dual MIT/GPL, abort."
					reverse_conf
					exit 1
				fi
				## remove no-autoinstall blank file
				test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
				echo "# Set Nvidia DKMS AUTOINSTALL option to \"yes\"."
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/nvidia-$(version)/dkms.conf
				sed -Ei "s/AUTOINSTALL=\".*\"//" /usr/src/open-nvidia-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
				sed -n "s/AUTOINSTALL.*$/*/i;{/^.*\*$/d;s/^\ //i;p}" /usr/src/nvidia-$(version)/dkms.conf
				sleep 2
				echo "# Unset $drv_off kernel options (if any)."
				[ -f $probe_open ]&& rm -f $probe_open
				sleep 2
				echo "# Set back Configuration file to NVIDIA only."
				sed -Ei "s/^(open_drv)=.*$/\1=0/" $basic_conf
				sed -Ei "s/^(use_open)=.*$/\1=0/" $basic_conf
				sleep 2
				echo "# Reboot for change to take effect."
			} | $d_zen --width=450 $win_icon --title="$_zen_title" --progress --pulsate \
			--text="${v}Open Source Drivers deletion${end}"
		fi
	fi
}
blacklist_nouveau(){
## TO REMOVE
# 	grub_cfg=$(find /boot -wholename "*/grub.cfg")
# 	grub_def=/etc/default/grub
	blacklist='nouveau.modeset=0 rd.driver.blacklist=nouveau'
 	drmset=' nvidia-drm.modeset'
	test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='.* '
	if [ $(grep -c "GRUB_CMD.*nouveau" $grub_def) -gt 0 ]; then
		if [ $(cat $grub_def| grep -E -c "^GRUB_CMD.*$blacklist.*$") -eq 0 ]|| \
		[ $(cat $grub_def| grep -E -c "^GRUB_CMD.*$blacklist$drmset.*$") -eq 1 ]; then
			echo "# - GRUB conf updated (nouveau driver blacklisting and options)."; sleep 2
			## then, replace default env grub with new vars and update grub.cfg.
			sed -Ei "s/^(GRUB_CMD.*)=\"(.*) ($grub_orig.*)\"$/\1=\"$blacklist \3\"/" $grub_def
			$d_grub-mkconfig -o $grub_cfg
		fi
	else
		echo "# Create GRUB conf for nouveau driver blacklisting."; sleep 2
		sed -En "s/^GRUB_CMD.*=\"(.*)\"$/grub_orig='\1'/p" $grub_def > $(user_CF_DIR)/grub-orig
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$blacklist \2\"/" $grub_def
		$d_grub-mkconfig -o $grub_cfg
	fi
	## add nouveau blacklist to modeprobe.d configs list.
	if [ ! -f /etc/modprobe.d/blacklist-nouveau.conf ]; then
		echo "# Update modprobe blacklist for nouveau driver."; sleep 2
		echo "blacklist nouveau" > /etc/modprobe.d/blacklist-nouveau.conf
	fi
	## take care of modeset 1 for 515 serie too.
	if [ $use_drm = 1 ]||[ $opti_preset = 1 ]; then
		old_drm_modset=$drm_modset
		if [ $opti_preset = 1 ]; then drm_modset=1; drm_msg='Optimus'; else drm_msg=$(chk_version)' serie'; fi
		if [ $drm_modset -ne $old_drm_modset ]; then
			sed -Ei "s/^drm_modset=.*$/\1=$drm_modset/" $basic_conf
		fi
		echo "# Update modprobe nvidia-drm option for $drm_msg."; sleep 2
		echo "options nvidia_drm modeset=$drm_modset" > /etc/modprobe.d/nvidia-drm.conf
	fi
}
nv_blacklist_modules_conf(){
		## set modprobe.d files
		black_file=/etc/modprobe.d/nvidia-blacklist.conf
		## move to post_install
		if [ ${#black_conf[*]} -gt 0 ]; then
			IFS=$(echo -en "\n\b")
			for mod_sets in ${black_conf[@]}; do
				mod=$(echo "$mod_sets"| cut -d';' -f1)
				used_val=$(echo "$mod_sets"| cut -d';' -f2)
				black_text=$(echo "$mod_sets"| cut -d';' -f3)
				# update basic conf.
				if [ $(grep -c "$mod" $basic_conf) -gt 0 ]; then
					sed -Ei "s/^($mod)=[0-9]$/\1=$used_val/g" $basic_conf
				fi
				# update or modifiy nvidia-blacklist.conf
				if [ -f $black_file ]; then
					if [ $(grep -c "$black_text" $black_file) -gt 0 ]; then
						if [ $used_val -eq 0 ]; then replace="$black_text"; else replace=''; fi
						sed -Ei "s/^$black_text$/$replace/g" $black_file
					fi
				else
					if [ $used_val -eq 0 ]; then
						cat <<-CONF >> $black_file
							$black_text
						CONF
					fi
				fi
			done
			IFS=$ifs
			## removed blanck lines from file if any.
			sed -i "/^[[:space:]]*$/d;s/^\ //g" $black_file
		fi
}
## configuration ###
prime_setup(){ ## TODO UNUSED YET
	## check for DM here.
	## xorg defs are config in xorg_conf section.
	if [ $opti_preset = 1 ]; then
		xrandr_conf=$(
			cat <<-CONF
				xrandr --setprovideroutputdevice modesetting NVIDIA-0
				xrandr --auto
			CONF
		)
		if [ "$dm_serv" == "lightdm" ]; then
			## add conf
			echo -e "#! /bin/bash\n\n$xrandr_conf\n" > /etc/lightdm/prime_ini
			chmod 755 /etc/lightdm/prime_ini
			## change Seat /etc/lightdm/lightdm.conf
			cp -f /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak
			sed -Ei "s/^.*(display-setup-script)=.*/\1=\/etc\/lightdm\/prime_ini/" /etc/lightdm/lightdm.conf
		elif [ "$dm_serv" == "sddm" ]; then
			## modify conf /usr/share/sddm/scripts/Xsetup
			cp -f /usr/share/sddm/scripts/Xsetup /usr/share/sddm/scripts/Xsetup.bak
			echo -e "$xrandr_conf" > /usr/share/sddm/scripts/Xsetup
		elif [ "$dm_serv" == "gdm" ]; then
			# /usr/share/gdm/greeter/autostart/optimus.desktop
			# /etc/xdg/autostart/optimus.desktop
			desktop_conf=$(cat <<-CONF
				[Desktop Entry]
				Type=Application
				Name=Optimus
				Exec=sh -c "xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto"
				NoDisplay=true
				X-GNOME-Autostart-Phase=DisplayServer
			CONF
			)
			echo "$desktop_conf" > /usr/share/gdm/greeter/autostart/optimus.desktop
			echo "$desktop_conf" > /etc/xdg/autostart/optimus.desktop

	# 	elif [ "$dm_serv" == "" ]; then
		fi
		## TODO, in progress.
	# 		if [ $opti_preset = 1 ]; then
	# 			cat <<-CONF >> $dm_conf
	# 				xrandr --setprovideroutputdevice modesetting NVIDIA-0
	# 				xrandr --auto
	# 			CONF
	# 				#xrandr --output LVDS-1-1 --primary
	# 				#xrandr --output VGA-0 --off
	# 		fi
	fi
}
## TODO ADD OPTI_SETUP here.

xorg_conf(){
## creation order :
## 	sec_files		x 1
## 	sec_layout		x X
## 	sec_device		x X
## 	sec_option_df	x X/1
## 	sec_screen		x X/1
	sec_files(){
		if [ $ELF_TYPE -eq 64 ]; then
			ELF=$ELF_64
		else
			ELF=''
		fi
		conf_date=$(date +%D-%T)
		cat <<-XF > $x_conf_dir/xorg.conf.nvidia
			## xorg conf originaly created by $(new_version) nvidia installer.
			## Edited automaticaly by Zenvidia > $conf_date

		XF
		if [ $(chk_version) -lt 430 ]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "Files"
			   ModulePath "$nv_root/nvidia/xorg/modules"
			   ModulePath "/usr/$master$ELF/xorg/modules"
			EndSection

			XF
		fi
	}
	sec_layout(){
		layout_screen(){
			for e in $pci_dev_nb; do
				if [ $opti_preset = 0 ]; then
					cat <<-XF
						   Screen ${dev_n[$e]}   "Screen${dev_n[$e]}" 0 0
					XF
				else
					if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
						cat <<-XF
						   Screen ${dev_n[$e]}   "Screen${dev_n[$e]}" 0 0
						XF
					else
						cat <<-XF
						#   Screen ${dev_n[$e]}   "Screen${dev_n[$e]}" 0 0
						   Inactive   "Device${dev_n[$e]}"
						XF
					fi
				fi
			done
		}
		## layout section may differ with second card (optimus).
		## main screen become nvidia's.
		if [ $opti_preset = 0 ]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"Xinerama" "0"
				EndSection

			XF
		else
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"Xinerama" "0"
				   Option	"AllowNVIDIAGPUScreens"
				EndSection

			XF
		fi
		cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "ServerFlags"
				# allows the server to start up even if the mouse does not work
			   AllowMouseOpenFail
			EndSection

		XF
	}
	sec_device(){
			pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				Section "Device"
				   Identifier	"Device${dev_n[$e]}"
				   Driver	"nvidia"
				   VendorName	"${vnd[$e]}"
				   BusID	"PCI:$pci_slot"
			XF
			else
				if [ $opti_preset = 1 ]; then
					pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
					cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
						Section "Device"
						   Identifier	"Device${dev_n[$e]}"
						   Driver	"modesetting"
						   VendorName	"${vnd[$e]}"
						   BusID	"PCI:$pci_slot"
						   Option "TearFree" "true"
					XF
				fi
			fi
	}
	sec_option_df(){
	## compute X screen DPI ex : (1080x25.4)/286. From Nvidia Doc formula.
		## FIXME function is apprently looping with multi devicees.

		if [ /usr/bin/xdpyinfo ]; then
			w_pix=$(printf "$x_pixel"| cut -d';' -f1)
			h_pix=$(printf "$x_pixel"| cut -d';' -f2)
			w_mil=$(printf "$x_milli"| cut -d';' -f1)
			h_mil=$(printf "$x_milli"| cut -d';' -f2)
			## formule
			dpi_w=$(echo "($w_pix*25.4+$w_mil-1)/$w_mil"| bc -l| sed -n "s/\..*$//p")
			dpi_h=$(echo "($h_pix*25.4+$h_mil-1)/$h_mil"| bc -l| sed -n "s/\..*$//p")
			## inclusion
			x_dpi=$dpi_w" x "$dpi_h
		else
			## fallback value.
			x_dpi="96 x 96"
		fi
		## get display current def and freq
		x_plore=$(xrandr --current | grep -m1 "*")
		def=$(printf "$x_plore"| awk '{print $1}')
		freq=$(printf "$x_plore"| sed -En "s/.* ([0-9]{2,3}\.[0-9]{2})\*.*$/\1/g;p")
		freq_prim=$(printf "$freq"| cut -d. -f1)
		freq_scnd=$(printf "$freq"| cut -c 4)
		if [ $freq_scnd -gt 5 ]; then freq=$(($freq_prim+1)); else freq=$freq_prim; fi
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			if [ $opti_preset = 1 ]; then
				cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
					   Option	"PrimaryGPU" "yes"
					   Option	"AllowEmptyInitialConfiguration"
				XF
			fi
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				   Option	"NoLogo" "true"
				#   Option	"DPMS"
				   Option	"UseEDID" "true"
				   Option	"ProbeAllGpus" "false"
				#   Option	"UseDisplayDevice" "none"
				#   Option	"ConnectedMonitor" "DFP"
				#   Option	"DynamicTwinView" "false"
				#   Option	"AddARGBGLXVisuals"
				   Option	"SLI" "Off"
				#   Option	"MultiGPU" "Off"
				   Option	"BaseMosaic" "off"
				#   Option	"UseEdidDpi" "false"
				   Option	"Coolbits" "8"
				#   Option	"AllowGLXWithComposite" "true"
				#   Option	"TripleBuffer" "true"
				   Option	"Stereo" "0"
				   Option	"RenderAccel" "true"
				   Option	"DPI" "$x_dpi"
				   Option	"nvidiaXineramaInfoOrder" "DFP-0"
				   Option	"metamodes" "${def}_${freq} +0+0"
				EndSection

			XF
		else
		## here second card option merge to Device section.
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				EndSection

			XF
		fi
	}
	sec_screen(){
		cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "Screen"
				Identifier	"Screen${dev_n[$e]}"
				Device	"Device${dev_n[$e]}"
				Monitor	"Monitor${dev_n[$e]}"
				DefaultDepth	24
			EndSection

		XF
	}
	x_conf_dir=/etc/X11
	mv -f $x_conf_dir/xorg.conf.nvidia $x_conf_dir/xorg.conf.nvidia.bak

	sec_files
	sec_layout
	for e in $pci_dev_nb; do
		 sec_device
		 sec_option_df
		 sec_screen
	done
	## xorg conf is secondary in optimus case because iGPU is the main device.
	[ $optimus -gt 0 ] || ln -sfr $x_conf_dir/xorg.conf.nvidia $x_conf_dir/xorg.conf
}
## ### AFTER INSTALL ###
clean_old_version(){ # post install part.
	( unset drv_src
		dkms_clean(){
			$p_dkms remove -m nvidia/$(old_version) --all
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
				rm -rf /var/lib/dkms/$rep_clean/$(old_version)
			fi
		}
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
		fi
		for rep_clean in ${drv_src[*]}; do
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
				progress_msg(){ echo "# ($m sec.) - Cleaning $rep_clean $(old_version) DKMS tree"; echo "$m"; }; m=1
				do_slp=1; progress "$(dkms_clean)"
			fi
			if [ -d /usr/src/$rep_clean-$(old_version) ]; then
				echo "# - Cleaning $rep_clean $(old_version) source tree"; sleep 2
				rm -rf /usr/src/$rep_clean-$(old_version)
			fi
		done
	) | $d_zen --width=450 $win_icon --title="$_zen_title" --progress  \
		--text="# - Cleaning old $(old_version) source and DKMS tree" --auto-close
}
post_install(){ # PROGRESS : TODO optimus section.
	echo "# ($n%) - Post install routines"; sleep 2
	echo "# ($n%) Create XORG config file for Nvidia device"; sleep 2
	xorg_conf # 8
	n=$[ $n+2 ]; echo "$n" # 8
	echo "# ($n%) - Linking $nv_root libs to system"; sleep 2
	n=$[ $n+2 ]; echo "$n" # 9
	if [ ! -s /etc/ld.so.conf.d/nvidia-$master$ELF_TYPE ]; then
		unset elf_lib_list
		elf_lib_list=("$ELF_64" "$ELF_32")
		for nv_lib in "${elf_lib_list[@]}"; do
			ld_conf=$nv_root/nvidia/$master$nv_lib
			[[ $nv_lib == 64 ]]|| nv_lib=32
			nv_lib_file='/etc/ld.so.conf.d/nvidia-'$master$nv_lib'.conf'
			printf "$ld_conf" > $nv_lib_file
		done
		report_log+=("${vB}Post install:\t\t${end}${gB} ldconfig\t\t${end}> ${y}Nvidia librairies linked to system${end}.\n")
	fi
	# libnvidia-wfb.so is broken with old version, need to be replace with xorg server libwfb.so. If exist in nvidia's dirs.
	if [ $(chk_version) -le 418 ]; then
		## 418 and above don't need nvidia libwfb.so to be replace anymore
		if [ -e $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so ]; then
			mv -f $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so.orig
			ln -sf /usr/$master$ELF_64/xorg/modules/libwfb.so $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so
			report_log+=("\t\t\t${gB} libwfb\t\t${end}> ${y}link to system${end}.\n")
		fi
	fi
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/install-$new_version.log; fi
	echo "# ($n%) - Fixing broken libs and links if needed"; sleep 2
	elf_lib=( "$master$ELF_64" "$master$ELF_32" )
	## Remove previous version libs if needed.
	unset lib_x fixed_lib_log
	for lib_X in "${elf_lib[@]}"; do
		for old_lib in {allocator,fbc,cfg,gtk2,gtk3,vulkan-producer,wayland-client}; do
			if [ -s $install_dir/$lib_X/libnvidia-$old_lib.so.$(old_version) ]; then
				rm_lib=libnvidia-$old_lib.so.$(old_version)
				rm -f $install_dir/$lib_X/$rm_lib
				if [ -h $install_dir/$lib_X/libnvidia-$old_lib.so ]||[ -h $install_dir/$lib_X/libnvidia-$old_lib.so.1 ]; then
					rm -f $install_dir/$lib_X/libnvidia-$old_lib.so*
				fi
				fixed_lib+=("$old_lib")
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ "$lib_X" =~ "64" ]]; then lib_x="x86_64"; else lib_x="i386"; fi
			fixed_lib_log+=(" cleaned ($lib_x)\n")
		fi
	done
		## send report from previous list before.
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			for line in ${fixed_lib_log[*]}; do
				report_log+=("\t\t\t${gB} lib fix\t\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
			done
		fi
		## fix lib64 prefix libs links if needed
		unset fixed_lib_log
		r_dir=$install_dir/$master$ELF_64
		## wayland on vulkan libs do not install by default, this not critical.
		## then we inquire for any broken link in install dir.
		## and add any missing libs if needed.
		## wayland libs can broke some software display, thus this is optional.
		[ $wayland_link = 1 ] && wayland=',wayland-client'
		for links in {fbc,cfg,gtk2,gtk3,vulkan-producer$wayland}; do
			if [ ! -e $r_dir/libnvidia-$links.so.$(new_version) ]; then
				cp -f $nvtmp/$extracted_release/libnvidia-$links.so.$(new_version) $r_dir/
			fi
			if [ ! -h $r_dir/libnvidia-$links.so.1 ]; then
				if [ -f $r_dir/libnvidia-$links.so.$(new_version) ]; then
					ln -sfr $r_dir/libnvidia-$links.so.1 $r_dir/libnvidia-$links.so
					ln -sfr $r_dir/libnvidia-$links.so.$(new_version) $r_dir/libnvidia-$links.so.1
					fixed_lib_log+=("$links,")
				fi
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ $ELF_64 =~ "64" ]]; then elf_x='(x86_64)'; else elf_x='(i386)'; fi
			fixed_lib_log+=(" links updated $elf_x")
			report_log+=("\t\t\t${gB} link fix\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
		fi
	## symlink libvdpau_nvidia to system
	if [ $(chk_version) -lt 430 ]; then
		for lib_V in "${elf_lib[@]}"; do
			link_v=$(file -p /usr/$lib_V/vdpau/libvdpau_nvidia.so.1| grep -c "nvidia.$(new_version)")
			if [ $link_v -eq 0 ]; then
				[ -d /usr/$lib_V/vdpau ]|| mkdir -p /usr/$lib_V/vdpau
				ln -sfr /usr/$lib_V/vdpau/libvdpau_nvidia.so /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
				ln -sf $nv_root/nvidia.$(new_version)/$lib_V/vdpau/libvdpau_nvidia.so.$(new_version) /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
			fi
		done
	fi
	n=$[ $n+2 ]; echo "$n" # 10
	## link now all new libraries
	echo "# ($n%) - Validating new librairies (ldconfig)"; sleep 2
	if [ ! -h /usr/share/nvidia ]; then
		rm -f /usr/share/nvidia
		ln -sf -T $install_dir/share/nvidia /usr/share/nvidia
	fi
	ldconfig
	## old driver version (here optimus laptop case) doesn't create nvidia devs. ATTENTION IN PROGRESS
	if [ $(chk_version) -le 430 ]; then
		## partly inspired by Alexandre Freire dos Santos work in Batocera.PLUS
		## https://github.com/AlexxandreFS/Batocera.PLUS/blob/master/script/nvidia-driver-udev-rules.sh
		## thanks to him.
		unset nv_mod_opts
		test $use_drm -eq 1 && nv_mod_opts+=('-m')
		test $use_uvm -eq 1 && nv_mod_opts+=('-u')
		for dev in ${dev_id[@]}; do
			#SUPPORTED_GPUS_JSON=$nvi_docs'/supported-gpus/supported-gpus.json'
			UDEV_RULES='/etc/udev/rules.d/01-nvidia-driver.rules'
			test -f ${UDEV_RULES} || touch ${UDEV_RULES}
			cat <<-UDEV >> ${UDEV_RULES}
			ACTION=="add", DEVPATH=="/bus/pci/drivers/nvidia", RUN+="$d_nv_probe -c 0 ${nv_mod_opts[*]}"
			UDEV
		done
	fi
	## here systemctl power management.
	if [ $opti_preset = 1 ]&&[ $enable_powerd = 1 ]; then
		cp -f $install_dir/share/doc/NVIDIA_GLX-1.0/nvidia-dbus.conf to /etc/dbus-1/system.d
		ln -sf $install_dir/bin/nvidia-powerd /usr/bin/nvidia-powerd
		systemctl enable nvidia-powerd.service
	fi
	## if driver version greater than 430.xx, backup xorg modules content to default libs dirs. Just in case.
	if [ $(chk_version) -ge 430 ]; then
		if [ -s $xorg_def/modules/extensions/libglxserver_nvidia.so ]; then
			mkdir -p $nv_root/nvidia.$(new_version)/xorg/modules/{extensions,drivers}
			cp -rf $xorg_def/modules/extensions/libglxserver_* $nv_root/nvidia.$(new_version)/xorg/modules/extensions/
			cp -f $xorg_def/modules/drivers/nvidia_drv.so $nv_root/nvidia.$(new_version)/xorg/modules/drivers/
		fi
	fi

	n=$[ $n+2 ]; echo "$n" # 11
	echo "# ($n%) - Blacklisting and other routines"; sleep 2
	echo "# ($n%) - GRUB conf update if needed"; sleep 2
	blacklist_nouveau
	n=$[ $n+2 ]; echo "$n" # 12
	echo "# ($n%) - Blacklist conf update if needed"; sleep 2
	nv_blacklist_modules_conf
	n=$[ $n+2 ]; echo "$n" # 13
	## NVIDIA_GLX-1.0 changelog file is replace even if the file is older than the installed one.
	## To prevent overwwrite in case of downgrade, file copied in zenvidia doc dir, then update
	## if changelog file is newer than the previous.
	if [ -f $zen_docs/NVIDIA_Changelog ]; then
		if [ $zen_docs/NVIDIA_Changelog -ot $nvi_docs/NVIDIA_Changelog ]; then
			cp -f $nvi_docs/NVIDIA_Changelog $zen_docs/
		fi
	else
		cp -f $nvi_docs/NVIDIA_Changelog $zen_docs/
	fi
	## clean old install dir
	if [ -d $nv_root/nvidia.$(new_version) ]; then
		if [ -d $nv_root/nvidia.$(old_version) ]; then
			echo "# ($n%) - Cleaning old $(old_version) source and DKMS tree if needed."; sleep 2
			rm -rf $nv_root/nvidia.$(old_version)
			report_log+=("\t\t\t${gB} old version\t\t${end}> ${y}$(old_version) directory cleaned${end}.\n")
			clean_old_version
			report_log+=("\t\t\t${gB} old source\t\t${end}> ${y}All $(old_version) version cleaned${end}.\n")
			n=$[ $n+2 ]; echo "$n" # 14
		fi
	fi
}
## COMPIL & COMPIL CONF TOOLS ###
## check for patch in new version.
nv_build_options(){
	## nvidia build evolve in time, there need to set different options
	## along side versions.
	# define driver file locations
	nv_xorg_dir=$nv_root/nvidia.$(new_version)/xorg
	xorg_def=/usr/$master$ELF_64/xorg
	kernel_path=/lib/modules/$KERNEL/$(module_dest_location)
	no_check='--no-check-for-alternate-installs'
	no_net='-N'
	[ $use_indirect = 0 ]|| force_glvnd='--force-libglx-indirect'
	[ $use_glvnd = 0 ]|| add_glvnd='--install-libglvnd'
	## since 515 series, open drivers are available. Default is none.
	extract_open=0
	ask_open_build=0
	if [ $(chk_version) -ge 390 ]; then
		compat32='--compat32-libdir='$master$ELF_32
		compat64='--opengl-libdir='$master$ELF_64
		gl_headers='--opengl-headers'
		no_net=''
	fi
	if [ $(chk_version) -ge 410 ]; then
		gl_headers=''
	fi
	if [ $(chk_version) -ge 430 ]; then
		nv_xorg_dir=$xorg_def
	fi
	if [ $(chk_version) -ge 430 ]; then
		wine_special='--wine-prefix='$nv_root'/nvidia.'$(new_version)
	fi
	if [ $(chk_version) -ge 515 ]; then
		extract_open=1; ask_open_build=1
		enable_powerd=1
	fi
}
nv_cmd_dkms_conf(){
	## check if source dir exit
	chk_dirs(){ [ -d /usr/src/$_src-$(new_version) ]||mkdir -p /usr/src/$_src-$(new_version); }
	## special IGNORE_PREEMPT_RT_PRESENCE script install.
	## add a pre install script for further kernel update through dkms.
	chk_RT(){
		if [ $is_RT -eq 1 ]; then
			if [ ! -e /usr/src/$_src-$(new_version)/nvidia.sh ]; then
				cat <<-SCP > /usr/src/$_src-$(new_version)/nvidia.sh
				#! /bin/bash

				if [ \$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$(uname -r)) -gt 0 ]; then
					export IGNORE_PREEMPT_RT_PRESENCE=1
				fi
				SCP
				chown root:root /usr/src/$_src-$(new_version)/nvidia.sh
				chmod 744 /usr/src/$_src-$(new_version)/nvidia.sh
			fi
		fi
	}
	# Create DKMS conf
	echo "# Create DKMS conf file..."; sleep 1
	## loop between open and private.
	if [ $(chk_version) -le 355 ]; then
		_src='nvidia'
		chk_dirs
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' KERNEL_UNAME=\${kernelver} modules"
		CLEAN="'make' clean"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"
		EOT
		if [ $use_uvm = 1 ]; then
			cat <<-EOT >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[1]="\${PACKAGE_NAME}-uvm"
			BUILT_MODULE_LOCATION[1]="uvm/"
			DEST_MODULE_LOCATION[1]="/$(module_dest_location)"
			EOT
		fi
	fi
	if [ $(chk_version) -lt 515 ]; then
		_src='nvidia'
		chk_dirs
		## dkms config part.
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' IGNORE_CC_MISMATCH='$gcc_mismatch' KERNEL_UNAME=\${kernelver} modules"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

		EOT
		o=1
		mods_list+=( "uvm" )
		mods_list+=( "modeset" )
		mods_list+=( "drm" )
		for mods in ${mods_list[@]}; do
			cat <<-EOT >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
			DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"
			EOT
			((o++))
		done
	fi
	## test if version support open driver version.
	if [ $(chk_version) -ge 515 ]; then
		unset drv_src
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
			AUTOINSTALL='AUTOINSTALL="yes"'
		fi
		for _src in ${drv_src[@]}; do
			chk_dirs
			chk_RT
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL=''; else AUTOINSTALL='AUTOINSTALL="yes"'; fi
				else
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL='AUTOINSTALL="yes"'; else AUTOINSTALL=''; fi
				fi
			fi
			unset mods_list
			if [ $is_RT -eq 1 ]; then
				PRE_BUILD='PRE_BUILD="nvidia.sh"'
			fi
			cat <<-EOT > /usr/src/$_src-$(new_version)/dkms.conf
			PACKAGE_NAME="nvidia"
			PACKAGE_VERSION="$(new_version)"
			$PRE_BUILD
			$AUTOINSTALL
			MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' \\
			IGNORE_CC_MISMATCH='$gcc_mismatch' \\
			KERNEL_UNAME=\${kernelver} modules $POST_BUILD"

			BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
			DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

			EOT
			o=1
			mods_list+=( "uvm" )
			mods_list+=( "modeset" )
			mods_list+=( "drm" )
			for mods in ${mods_list[@]}; do
				cat <<-EOT >> /usr/src/$_src-$(new_version)/dkms.conf
				BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
				DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"

				EOT
				((o++))
			done
		done
	fi
}
nv_dkms_mok_key(){
	## something can go wrong during module signing, need to figure out.
	# 	/lib/modules/6.1.10-100.fc36.x86_64/build/scripts/sign-file sha512 /var/lib/dkms/mok.key /var/lib/dkms/mok.pub /var/lib/dkms/nvidia/390.157/build/nvidia.ko
	# 	strip -g /var/lib/dkms/nvidia/390.157/build/nvidia.ko

	## for an unknown reason (at least not found) it happens that DKMS MOK keys are not generated.
	## and prevent DKMS compilation to succeed. Then, if not found we're create new self-signed ones.
	mok_signing_key="/var/lib/dkms/mok.key"
	mok_certificate="/var/lib/dkms/mok.pub"
	## this part is more or less taken from dkms script. Thankfully.
	if [ ! "$mok_signing_key" ] || [ ! "${mok_certificate}" ]; then
		echo "# DKMS MOK key/certificate are missing, generating new one for modules signin process."
		$d_ssl req -new -x509 -nodes -days 36500 -subj "/CN=DKMS module signing key" \
		-newkey rsa:2048 -keyout "$mok_signing_key" \
		-outform DER -out "$mok_certificate" &>/dev/null
		if [ ! -f "$mok_signing_key" ]; then
			echo "# MOK $mok_signing_key key not found and/or can't be generated, modules won't be signed"
			## send ERROR and abort.
			w_text=$( cat <<-ERROR
				${r}MODULES SIGNATURE ERROR${end}.
				$(new_version) compilation can't be done successfully.

				$mok_signing_key and $mok_certificate can't be found
				and attempt to create new ones failed.

				Very sorry about that.
			ERROR
			)
			$d_zen --width=450 --title="$_zen_title" $win_icon $icon_name=xkill --error --no-wrap \
			--ok-lable="OK" --text="${v}$w_text${end}"
			kill $zen_pid
		fi
		$d_sys restart dkms.service
	fi
}
build_dkms(){
	## test and fix mok keys if needed.
 	nv_dkms_mok_key
	unset drv_src
	## all script here is inserted in xterm for better display of process.
	## known bug : it appears on unknown reason that DKMS script do not install modules.
	## exploring some solutions, but not sure of them.
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	show_dkms=' (dkms)'
	[ -f $tmp_b ] && echo -e "show_dkms=' (dkms)'" >> $tmp_b
		mod_move(){
			## if modules detected in dkms version tree, move.
			if [ -f nvidia.*[ko\|ko.xz] ]; then
				echo -e "#${r} Error : No $_dkms ${j}$(new_version)${end} modules found in kernel path $kernel_path.${end}"
				sleep 2
				echo -e "#${v} Workaround : Copying ${y}$_dkms${end} modules in $kernel_path from DKMS repository.${end}"
				#echo -e "# moving"
				echo -e "# ${ge}* Compressing $_dkms modules if needed."
# 				test $is_RT -eq 0 ||
				xz -T12 *.ko | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				cp -vf nvidia.ko.xz $kernel_path/nvidia.ko.xz
				if [[ -s nvidia-uvm.ko.xz ]]; then cp -vf nvidia-uvm.ko.xz $kernel_path/nvidia-uvm.ko.xz; fi
				if [[ -s uvm/nvidia-uvm.ko.xz ]]; then cp -vf uvm/nvidia-uvm.ko.xz $kernel_path/nvidia-uvm.ko.xz; fi
				if [[ -s nvidia-modeset.ko.xz ]]; then cp -vf nvidia-modeset.ko.xz $kernel_path/nvidia-modeset.ko.xz; fi
				if [[ -s nvidia-drm.ko.xz ]]; then cp -vf nvidia-drm.ko.xz $kernel_path/nvidia-drm.ko.xz; fi

				if [[ -s $kernel_path/nvidia.*[ko\|ko.xz] ]]; then
					echo -e "# ${ge}* Exec $KERNEL modules depmod"
					sleep 2
					progress_msg(){ echo " * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
					progress /usr/sbin/depmod -an $KERNEL | \
					while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
					rm -f $tmp_c
					$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
					pass=$?
				else
					pass=1
				fi
				if [ $pass = 0 ]; then
					vermagic=$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\|ko.xz]| awk '{print $1}')
					echo -e "# ${y}* All Clear modules loaded ($(new_version) modules moved from dkms dir)${end}."
					echo -e "pass=$pass" >> $tmp_b
				else
					echo -e "#${r} --- ERROR ---  Driver not found in path --- ${end}"
					echo -e "pass=1" >> $tmp_b
					echo -e "# ${r}* You can try ${y}Update Driver${end} menu > ${y}Update from source${end} as workaround install${end}"
					with_error="${r} (ERROR, safe modules not copied)${end}"
				fi
			else
				echo -e "#${r} --- ERROR ---  Driver not found in path ---- ${end}"
				echo -e "pass=1" >> $tmp_b
				echo -e "# ${r}* You can try ${y}Update Driver${end} menu > ${y}Update from source${end} as workaround install${end}"
				with_error="${r} (ERROR, no safe modules found)${end}"
			fi
		}
		mod_check(){
		## when previous driver is higher than in install one's, dkms, even if build and install return succes, doesn't install
		## the drivers. Thus, we install those driver manually with cp.
			if [ -d /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module ]; then
				pushd /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module
				echo -e "# ${y}* Checking $(new_version) in DKMS $KERNEL path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				mod_move
				popd
			elif [ -d /var/lib/dkms/$_dkms/$(new_version)/build ]; then
				pushd /var/lib/dkms/$_dkms/$(new_version)/build
				echo -e "# ${y}* Checking $(new_version) in DKMS $KERNEL build path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				mod_move
				popd
			else
				echo -e "# ${r}* No modules found in DKMS build path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				echo -e "# ${r}* You can try ${y}Update Driver${end} menu > ${y}Update from source${end} as workaround install${end}"
				with_error="${r} (ERROR, no modules found)${end}"
			fi
		}
		remove_add(){
			# ATTENTION Remove driver tree only ? or remove all ?
			remove_seq(){
				#$headings
				echo -e "#${v} Removing previous ${j}$(old_version)${end} ${y}$_dkms${end} DKMS modules from DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				#echo -e "# remove $_dkms"
				if [ $(nv_old) -gt $(nv_new) ]; then
					#echo -e "# remove seq all"
					$p_dkms remove -m $_dkms/$(old_version) --all | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
				else
					#echo -e "# remove seq kernel"
					$p_dkms remove -m $_dkms/$(old_version) -k $KERNEL | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
				fi
				sleep 2
			}
			add_seq(){
				echo -e "#${v} Add ${j}$(new_version)${end} ${y}$_dkms${end} modules to DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				#echo -e "# add $_dkms"
				$p_dkms add -m $_dkms/$(new_version) -k $KERNEL | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
			}
			## remove previous known and unknown version if any before installing new one.
			## TODO add a more strict filter on already present modules.
			mod_installed=$(mod_installed)
			old_inst(){ # used by nv_build_dkms only
				test "$mod_installed" && sed -n "s/\.//g;p" <<< $mod_installed || echo "0"
			}
			## is a old modules installed ?
			if [ $(nv_old) -gt 0 ] && ( [ $(nv_old) = $(old_inst) ] && [ $(nv_old) -ne $(nv_new) ] ); then
					#echo -e "# remove seq 1"
					remove_seq
			else
			## if not :
			## is the modules version present in dkms tree ?
				if [ "$(old_inst)" ] && [ $(old_inst) -gt 0 ]; then
					## check its status.
					if [ $($p_dkms status -m $_dkms/$mod_installed -k $KERNEL| grep -E -c "built|installed") -gt 0 ]; then
						# if build or installed, and not same as new one, check status ans 'remove' it.
						if [[ $(old_inst) -ne $(nv_new) ]]; then
							#echo -e "# remove seq 2"
							remove_seq
						fi
					else
						## if not in the dkms tree, just remove them, and make a depmod to clear things.
						if [ $(old_inst) -ne $(nv_new) ]; then
							echo -e "#${ge}* Removing out of DKMS tree $mod_installed $_dkms from kernel modules path.${end}"
							echo $(($n+$o)); o=$(($n+$o)) #3
							sleep 2
							#echo -e "# ** rm mods"
							rm -f $kernel_path/*
							echo -e "# ${ge}* Executing clean depmod before next step.${end}"
							sleep 2
							#echo -e "# ** exec depmod"
							progress_msg(){ echo " * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
							progress /usr/sbin/depmod -an $KERNEL | \
							while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
							rm -f $tmp_c
							#/usr/sbin/depmod -a $KERNEL
							echo -e "# ${ge}* Done.${end}"
							sleep 2
						fi
					fi
				else
					echo -e "# ${ge}* No previous driver found. Installing $(new_version) $_dkms.${end}"
					echo $(($n+$o)); o=$(($n+$o)) #3
					sleep 2
				fi
			fi
			if [ $($p_dkms status -m $_dkms/$(new_version) -k $KERNEL| grep -E -c "added|built|installed") -eq 0 ]; then
				add_seq
			fi
		}
		build_seq(){
			build_seq_1(){
				echo -e "#${v} Building ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				#echo -e "# build $_dkms"
				if [ -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module/nvidia.*[ko\|ko.xz] ]; then
					echo -e "# ${y}* All Clear for $(new_version) $_dkms already build.${end}"
				else
					$p_dkms build -m $_dkms/$(new_version) -k $KERNEL $force 2>&1 | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
					echo -e "# ${y}* All Clear for $(new_version) $_dkms is build.${end}"
				fi
				echo -e "#${y} ---  $_dkms script ended  --- \n${end}"
				echo $(($n+$o)); o=$(($n+$o)) #6
				sleep 2
			}
			build_seq_2(){
				echo -e "#${v} Build and Install ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				#echo -e "# install classic $_dkms"
				$p_dkms install -m $_dkms/$(new_version) -k $KERNEL $force 2>&1 | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
				$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
				pass=$?
				echo -e "pass=$pass" >> $tmp_b
				echo -e "#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} modules in $kernel_path ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #6
				if [ $pass = 0 ]; then
					echo -e "# ${ge}* Check validated (pass=$pass)${end}"
				else
					echo -e "# ${ge}* Check unvalidated (pass=$pass)${end}"
				fi
				sleep 2
				if [ $pass = 1 ]; then
					mod_check
				else
					vermagic=$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\|ko.xz]| awk '{print $1}')
					echo -e "# ${y}* All Clear for $(new_version) $_dkms in $KERNEL kernel.${end}"
					echo $(($n+$o)); o=$(($n+$o)) #7
					sleep 2
				fi
				echo -e "# ${y} ---  $_dkms script ended  --- \n${end}"
			}
			if [[ $_dkms =~ ^open ]]; then
				if [ $use_open = 0 ]; then
					build_seq_1
				else
					build_seq_2
				fi
			elif [[ $_dkms =~ ^nvidia ]]; then
				if [ $open_drv = 1 ]; then
					if [ $use_open = 0 ]; then
						build_seq_2
					else
						build_seq_1
					fi
				else
					build_seq_2
				fi
			fi
		}
		post_treatment(){
			echo -e "#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} build log presence${end}"
			echo $(($n+$o)); o=$(($n+$o))
			if [ -s /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log ]; then
				test -d $nvlog/dkms/$_dkms/ || mkdir -p $nvlog/dkms/$_dkms/
				cp -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log $nvlog/dkms/$_dkms/
				#echo -e "# copy log"
				make_log_file=$nvlog/dkms/$_dkms/make.log
				echo -e "make_log_file=$make_log_file" >> $tmp_b
				echo -e "# ${ge}* $_dkms $(new_version) log found.${end}"
				echo -e "# ${ge}* $_dkms make log copied to $make_log_file.${end}"
			else
				echo -e "# ${ge}* No $(new_version) $_dkms build log found.${end}"
			fi
			if [[ $_dkms =~ ^open ]]; then sleep 4; else sleep 2; fi
		}
		n=15
		o=0
		test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ]
		#set -x
		for _dkms in ${drv_src[@]} ; do
			echo -e "#${v}${mf} Compiling ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules ${end}${end}"
			echo $(($n+$o)); o=$(($n+$o)) #1
			echo -e "#${y} ---  $_dkms script start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) #2
			sleep 2
			remove_add
			build_seq
			post_treatment
			echo -e "# "
		done
		echo -e "#${v} Done$with_error${end}"
		echo -e "# "
		echo -e $esc_message
		$x_sleep
		echo 100
}
nv_build_dkms(){
	echo "# Build & install DKMS modules..."; sleep 1
	build_dkms | \
	$d_yad --width=600 --height=300 --title "Zenvidia" $win_icon --progress --center --hide-text \
 	--enable-log='' --log-expanded --log-height=300 $x_hold \
 	--text="${v}Installing ${j}$(new_version)${end} driver over ${y}$KERNEL${end} kernel with DKMS${end}"
}
build_source(){
	unset drv_src
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	[ -f $tmp_b ]&& echo -e "show_dkms=' (from source)'" > $tmp_b
	## prepare modules signing (with dmsk mok files)
	nv_dkms_mok_key
	module_signing(){
		if [ -f "$(find -L $kernel_src -name "sign-file")" ]; then
			## list modules.
			for mod in $(ls -1 *.ko); do
				echo -e "# ${ge}* Signing $mod ...${end}";
				sleep 1
				## find the sign-file script in kernel source
				$(find -L $kernel_src -name "sign-file") sha512 $mok_signing_key $mok_certificate $mod
				## strip on uncompressed modules only
				strip -g $mod
			done
		fi
	}
	copy_mods(){
		echo -e "#${v} $seq_type ${j}$(new_version)${end} ${y}$module${end} in $install_path:${end}"; echo $(($n+$o)); o=$(($n+$o)) # 5
		sleep 2
		test -d $install_path || mkdir -p $install_path
		echo -e "# ${ge}* Compressing $module modules${end}" # 7
# 			pushd $install_path
# 			test $is_RT -eq 0 ||
		xz -T12 *.ko | \
		while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
		echo -e "# ${ge}* Copying $module modules in $install_path${end}"; echo $(($n+$o)); o=$(($n+$o)) # 6
# 		echo -e "# ${ge}* Making $module module copy.${end}" # 7
			cp -f nvidia.ko.xz $install_path/nvidia.ko.xz
			if [[ -s nvidia-uvm.ko.xz ]]; then cp -f nvidia-uvm.ko.xz $install_path/nvidia-uvm.ko.xz; fi
			if [[ -s uvm/nvidia-uvm.ko.xz ]]; then cp -f uvm/nvidia-uvm.ko.xz $install_path/nvidia-uvm.ko.xz; fi
			if [[ -s nvidia-modeset.ko.xz ]]; then cp -f nvidia-modeset.ko.xz $install_path/nvidia-modeset.ko.xz; fi
			if [[ -s nvidia-drm.ko.xz ]]; then cp -f nvidia-drm.ko.xz $install_path/nvidia-drm.ko.xz; fi
			## compress modules.
# 			popd
			if [ $dep_check = 1 ]; then
				echo -e "# ${ge}* Executing $module $KERNEL depmod${end}"
				#/usr/sbin/depmod $KERNEL -a
# 				$( exec_depmod "$KERNEL" )
				progress_msg(){ echo " * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
				progress /usr/sbin/depmod -an $KERNEL | \
				while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
				rm -f $tmp_c
			fi
	}
	mod_check(){
		if [ -e /usr/src/$module-$(new_version)/nvidia.ko ]; then
			echo -e "#${y} ---  $module Compilation done  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 4
			sleep 2
			echo -e "#${v} Signing ${j}$(new_version)${end} ${y}$module${end} modules.${end}"
			module_signing; echo $(($n+$o)); o=$(($n+$o))
			if [ $use_open -eq 1 ]; then
				if [[ $module =~ ^open ]]; then
					install_path=$kernel_path
					dep_check=1
					seq_type='Installing'
					copy_mods
				else
					echo -e "#${v} Reserving: Not installing, ${j}$(new_version)${end} ${y}$module${end} is not used.${end}"; echo $(($n*2+$o)); o=$(($n*2+$o)) # 5
					install_path=/usr/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
					dep_check=0
					seq_type='Backup'
					copy_mods
				fi
			else
				if [[ $module =~ ^nvidia ]]; then
					install_path=$kernel_path
					dep_check=1
					seq_type='Installing'
					copy_mods
				else
					echo -e "#${v} Reserving: Not installing, ${j}$(new_version)${end} ${y}$module${end} is not used.${end}"; echo $(($n*2+$o)); o=$(($n*2+$o)) # 5
					install_path=/usr/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
					dep_check=0
					seq_type='Backup'
					copy_mods
				fi
			fi
		else
			echo -e "#${r} ---  ERROR  ---  No modules found in source path  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 4
			with_error=" ${r}with ERRORs${end}"
		fi
	}
	post_treatment(){
		echo -e "#${v} Checking ${j}$(new_version)${end} ${y}$module${end} build log presence.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 8
		if [ -s /usr/src/$module-$(new_version)/make.log ]; then
			[ -d $nvlog/source/$module ]|| mkdir -p $nvlog/source/$module
			cp -f /usr/src/$module-$(new_version)/make.log $nvlog/source/$module
			make_log_file=$nvlog/source/$module/make.log
			[ -f $tmp_b ]&& echo -e "make_log_file=$make_log_file" >> $tmp_b
			echo -e "#${ge} * $module $(new_version) log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
			echo -e "#${ge} * $module make log copied to $make_log_file.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 10
		else
			echo -e "#${ge} * No $(new_version) $module build log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
		fi
		if [ $dep_check = 1 ]; then
			$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
			pass=$?
		else
			pass=0
		fi
		if [ $pass = 0 ]; then
			echo -e "#${ge} * $module control passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
		else
			echo -e "#${ge} * $module control not passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
			echo -e "#${r} ---  ERROR  ---  No modules found in destination path  --- ${end}";
			with_error=" ${r}with ERRORs${end}"
		fi
		[ -f $tmp_b ]&& echo -e "pass=$pass" >> $tmp_b
		if [[ $module =~ ^open ]]; then sleep 4; else sleep 2; fi
	}

	if [ $upgrade_other = 1 ]; then
		make_env='env KERNEL_UNAME='$KERNEL' KERNEL_SOURCES='$kernel_src
	fi
	if [ $(chk_version) -lt 355 ]; then
		opts_355="cd uvm/; make -j$proc; cd ../"
	fi
	n=10
	o=0
	test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ]
	for module in ${drv_src[@]} ; do
		pushd /usr/src/$module-$(new_version)
		sleep 1
		echo -e "# ${v}${mf} Compiling ${j}$(new_version)${end} from ${y}$module${end} modules source:${end}${end}"; echo $(($n+$o)); o=$(($n+$o)) # 1 10
# 		echo -e "# "
		sleep 2
		if [ -d /usr/src/$module-$(new_version) ]; then
			echo -e "#${y} ---  $module compilation start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 2 20
			sleep 2
			echo -e "#${ge} Compilation $make_env.${end}" # 3 30
			$make_env make -j$proc | fmt -w 120 | \
			while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; echo "${line}" &>> make.log; done
			$opts_355
			sleep 2
			mod_check
			sleep 2
			post_treatment
		else
			echo -e "# ${v}Source ${j}$(new_version)${end} ${y}$module${end} unaviable.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 2
			echo -e "# ${v}Check your kernel source three.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 3
			[ -f $tmp_b ]&& echo -e "pass=1" >> $tmp_b
			with_error=" ${r}with ERRORs${end}"
		fi
		make clean
		echo -e "# "
		popd
	done
	echo -e "#${v} Done$with_error.${end}"
	sleep 2
	echo -e "# "
	echo -e $esc_message
	$x_sleep
	echo 100
	. $tmp_b
}
nv_cmd_make_src(){
	echo "# Build & install modules from source..."; sleep 1
	build_source | \
	$d_yad --width=600 --height=300 --title "Zenvidia" $win_icon --progress --center --hide-text \
 	--enable-log='' --log-expanded --log-height=300 $x_hold \
 	--text="${v}Installing ${y}$KERNEL${end} kernel modules from ${j}$(new_version)${end} source directory${end}"
}
nv_cmd_install_driver(){
		## prevent installer to doing think for 'upgrade an other kernel'.
		upgrade_other=0
		if [[ $($d_modinfo -F version nvidia) != $(new_version) ]]; then
			[ -d /usr/src/nvidia-$(new_version) ] ||mkdir -p /usr/src/nvidia-$(new_version)
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel/* /usr/src/nvidia-$(new_version)
			if [ $extract_open = 1 ]; then
				test $ask_open_build -eq 1 && nv_open_modules_set
			fi
			if [ $use_dkms = 1 ]; then
				if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel ]; then
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo "# DKMS compilation ERROR !!"; sleep 2
					fi
				fi
			fi
			if [ $use_dkms = 0 ]; then
				echo "# Nvidia MODULES compilation from source..."; sleep 1
				nv_cmd_make_src
			fi
		else
			[ -f $tmp_b ] && echo -e "pass=1" >> $tmp_b
		fi
}
nv_cmd_update(){
	driver_logfile=$nvlog/$(new_version)-$KERNEL.log
	tmp_b=$(mktemp --tmpdir zn_vars.XXX)
	## check for for patch in new version.
	rt_options
	nv_build_options
	if [ $extract_open = 1 ]; then
		if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open/* /usr/src/open-nvidia-$(new_version)
		fi
	fi
	## check for open modules presence.
	test $ask_open_build -eq 1 && nv_open_modules_set
	if [ $use_dkms = 1 ]; then
		[ $from_install = 1 ] && nv_cmd_dkms_conf
		nv_build_dkms
		. $tmp_b
		make_log=$make_log_file
		if [ $pass -eq 1 ]; then
			echo "# DKMS compilation ERROR !!"; sleep 2
		fi
	else
		if [ $use_dkms = 0 ]; then
			echo "# Nvidia MODULES compilation from source..."; sleep 1
			nv_cmd_make_src
			. $tmp_b
			make_log=$make_log_file
		fi
	fi
	if [ $pass -eq 0 ]; then
		## rebuild initramfs in case of trouble booting.
		echo "# Updating $KERNEL modules."; sleep 1
		$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
		if [ $? = 0 ] ; then
			if [ $exec_mod_tool = 1 ]; then
				echo "# - Exec $KERNEL modules reload "; sleep 2
				exec_mod_load
			else
# 				if [ $upgrade_other = 1 ]; then
					progress_msg(){ echo "# - Rebuilding $KERNEL INITRAMFS ($m sec.)"; echo "$m"; }; m=1; do_slp=1
					exec_initramfs
# 				else
# 					echo "# - Exec $KERNEL modules reload "; sleep 2
# 					exec_mod_load
# 				fi
			fi
		else
			echo "# ERROR ! $KERNEL modules do not match $(new_version). Abort."; sleep 3; exit 0
		fi
 	fi
 	install_log_messages
 	blacklist_nouveau
}
nv_cmd_install_libs(){ # TODO CHECK REGULARY AT DRIVER UPGRADE
## INFOS ABOUT NVIDIA-INSTALLER OPTIONS :
#  --opengl-prefix=OPENGL-PREFIX
#      The prefix under which the OpenGL components of the NVIDIA driver will be installed; the default is:
#      '/usr'.  Only under rare circumstances should this option be used.  The Linux OpenGL ABI
#      (http://oss.sgi.com/projects/ogl-sample/ABI/) mandates this default value.
# --opengl-libdir=OPENGL-LIBDIR
#      The path relative to the OpenGL library installation prefix under which the NVIDIA OpenGL components will
#      be installed.  The default is 'lib' on 32bit systems, and 'lib64' or 'lib' on 64bit systems, depending on
#      the installed Linux distribution.  Only under very rare circumstances should this option be used.
#  --wine-prefix=WINE-PREFIX
#      The prefix under which Wine components of the NVIDIA driver will be installed.  The default is '/usr'.
#  --wine-libdir=WINE-LIBDIR
#      The path relative to the Wine installation prefix under which Wine components of the NVIDIA driver will be
#      installed.  The default is '<opengl-libdir>/nvidia/wine', where <opengl-libdir> is the path determined for
#      --opengl-libdir above.
#	-b --no-sigwinch-workaround --no-distro-scripts $no_check \	
#	--x-prefix=$xorg_dir --x-module-path=$xorg_dir/modules --opengl-prefix=$croot_all \
#	sh $run_pkg -a $quiet -z -Z --no-x-check --ui=none $unified \
#	--kernel-source-path=$kernel_src --kernel-install-path=$kernel_path  --no-abi-note \
#	sh $run_pkg -s -z -N --no-x-check \
## EXTRA INFOS
#	$nocheck --no-kernel-module --no-opengl-files --skip-module-unload \
#	--no-recursion --opengl-headers --install-libglvnd --glvnd-glx-client --force-libglx-indirect  --opengl-libdir=$master$ELF_64 \
#	--utility-prefix=$install_dir --utility-libdir=$install_dir/$master$ELF_64 \
# 	temp="--tmpdir=$buildtmp"

	pushd $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)
	( echo "20"
	$install_bin -s -z $no_net --no-x-check --no-distro-scripts \
	$nocheck --no-kernel-module --skip-module-unload --no-recursion $gl_headers \
	$add_glvnd $force_glvnd --install-compat32-libs \
	--compat32-prefix=$nv_root/nvidia.$(new_version) $compat32 $compat64 \
	--x-prefix=/usr --x-library-path=$nv_root/nvidia.$(new_version) --x-module-path=$nv_xorg_dir/modules \
	--opengl-prefix=$nv_root/nvidia.$(new_version) $wine_special --utility-prefix=$install_dir \
	$docs $profile --tmpdir=$buildtmp --log-file-name=$lib_logfile 2>&1 | fmt -w 100 | \
	while read -r line; do echo -e "# ${y}${sf}${line}${end}${end}"; done
	echo -e "# "
	echo -e $esc_message
	$x_sleep
	echo "100"
	) | $d_yad --width=600 --height=300 --title "Zenvidia" $win_icon --progress --center --hide-text \
 	--enable-log='' --log-expanded --log-height=300 $x_hold \
 	--text="${v}Installing ${j}$(new_version)${end} librairies to $nv_root/nvidia.$(new_version)${end}"
	popd
	## link to sys.
	ln -sfr -T $nv_root/nvidia.$(new_version) $nv_root/nvidia
}
## ### INSTALL MODULE AND LIBRARIES PROCESS ###
## ### MAIN SECTION ###
install_log_messages(){
	## install log messages
	if [ $pass -eq 0 ]; then
		echo "# Modules build done."; sleep 2
		report_log+=("${vB}Driver build$show_dkms:\t${end}${gB} success\t\t${end}> ${y}Installation complete with no error${end}\n")
	else
		echo "# Modules build ERROR."; sleep 2
		report_log+=("${vB}Driver build:\t\t${end}${rB} failure\t\t${end}> ${y}ERROR, 'make' exit with 'failed' state${end}\n")
		w_text=$( cat <<-ERROR
			${r}MODULES BUILD RETURN ERRORS.${end}.
			$(new_version) compilation failed.
			Source make.log has been saved in <i>$make_log_file</i>.

			Do you want to read $make_log_file ?
		ERROR
		)
		$d_zen --width=450 --title="$_zen_title" $win_icon $icon_name=xkill --question --no-wrap \
		--ok-label="Yes" --cancel-label="No thanks, shits happens" \
		--text="${v}$w_text${end}"
		fatal_error=$?
		kill $zen_pid
		if [ $fatal_error = 0 ]; then
			$d_zen --width=800 --height=400 --title="$_zen_title" --text-info \
			--ok-label="Close" --cancel-label='' --filename="$make_log_file"
		fi
	fi
	## realtime report messages.
	if [ $is_RT -eq 1 ]; then
		report_log+=("\t\t\t${gB} kernel option\t${end}>${y} Kernel $KERNEL is REALTIME${end}.\n")
	fi
	## open driver install report messages.
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -eq 1 ]; then append="open driver loaded"; else append="close source loaded"; fi
		report_log+=("${vB}Open Driver:\t\t${end}$gB compiled\t\t${end}>${y} $append${end}\n")
	fi
}
install_report_log(){
	## display final message depends of exit status.
	$d_zen --title="Zenvidia" --question --no-wrap $win_icon --width=500 \
	--text="${j}${bf}$(new_version) Install Report${end}${end}${v}:\n $(cat <<< ${report_log[*]})${end}\n$rep_msg" \
	--ok-label="edit now" --cancel-label="edit later"
	if [ $? = 0 ]; then edit_xorg_conf; fi
}
## ### INITIAL OR UPGRADE INSTALL PROCESS ###
install_drv(){
	## tell script that all post_install process came from global install.
	from_install=1
	## vars for auto confirmation window sets below 'win_confirm'
	confirm_msg="$menu_msg\n${v}Installing driver${end} ${j}$(new_version)${end} ${v}for hardware :${end} ${j}$dev_name${end}."
	val_confirm="Install"
	val_back="$MM"
	val_exit="menu_install"
	val_cancel="base_menu" #TEXT
	val_title="$_zen_title"
	## check for for patch in new version.
	nv_build_options
	rt_options
	## define modules to build at compil/dkms time.
	nv_modules_set
	win_confirm
	# child process doesn't send back install check result, it need to be
		# set in a temp file.
		tmp_b=$(mktemp --tmpdir zn_vars.XXXX)
		# set a second temp file for old-version backup when new modules installed
		tmp_old=$(mktemp --tmpdir zn_vars.XXXX)
		# then push version var in second temp to be used as old-version var during installation.
		echo "$($d_modinfo -F version nvidia -k $KERNEL)" > $tmp_old
	if [[ -s $run_pkg ]] ; then
	{	## set start count
		zen_pid=$(pgrep zenity)
		n=1
		## check compatiblity files before executng anything. (4)
		echo "# ($n%) - Checking compatibility data files"; sleep 2
		DRV=$(new_version)
		for e in ${pci_dev_nb[@]}; do
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
				$(hardware_compat)
				. $tmp_b
			fi
		done
		echo "$install_msg" ; n=$[ $n+5 ]; echo "$n"; sleep 2 # 1
		## extract .run package for install processes (22)
		extract_build
		test $tmp_c && . $tmp_c
		echo "$n"
		## at install only, nvidia-installer is located in temp rep.
		install_bin="./nvidia-installer"
		echo "# ($n%) - Backing up old driver version, if any"; sleep 2
		# backup driver repository (shits happens!)
		unset report_log
		if [ -d $nv_root/nvidia.$(old_version) ]; then
			bak_version=$(old_version)
			if [[ -s $nvbackup/nvidia.$bak_version.tar.gz ]]; then
				report_log+=("${vB}Previous version:\t${end}${gB} passed\t\t${end}> ${y}previously backed up${end}\n")
			else
				backup_old_version
				report_log+=("${vB}Previous version:\t${end}${gB} success\t\t${end}> ${y}$bak_version normal backup process${end}\n")
			fi
		else
			report_log+=("${vB}Previous version:\t${end}${jB} warning\t\t${end}> ${y}no directory to archive.${end}\n")
		fi

		n=$[ $n+5 ] ; echo "$n" # 2 ### ?
		## temp value to n
		p=$n
		echo "# ($n%) - Starting install"; sleep 1
		cd $nv_root
		# nv_cmd processes (install without X crash )
		echo "# ($n%) - Package compil and install"; sleep 1
		# install driver first, then control if everything ok (14 Initramfs)
		nv_cmd_install_driver
		. $tmp_b
		n=$[ $n+5 ]; echo "$n" # 3
		install_log_messages
		if [ $pass -eq 0 ]; then
		## rebuild initramfs or modprobe reload.
		## exec_mod_reload works with update driver tools, but not when fresh install.
		## until a proper method found, initramfs is kept and other syntax only uncommented.
# 			if [ $exec_mod_tool = 1 ]; then
# 				echo "# - Exec $KERNEL modules reload "; sleep 2
# 				exec_mod_load
# 			else
		## progress count depends of CPU calculation power. If CPU is too slow, the cound is too high
		## and goes beyond zenity 100 max count. So, global evaluation is made here.
# 		progress_msg(){ echo "# ($m%) - Exec $KERNEL modules init/reload"; echo "$m"; }; m=$n; do_slp=1
# 		exec_initramfs
# 		. $tmp_c
		progress_msg(){ echo "# ($m%) - Exec $KERNEL modules init/reload"; echo "$m"; }; m=0; do_slp=1
		exec_initramfs
		n=$[ $n+20]
# 			fi
		fi
		echo "$n"
		inst_mod_version=$($d_modinfo -F version nvidia -k $KERNEL)
		## create base libs install directories
		for d in {$nv_root/$predifined_dir,$nv_root/nvidia.$(new_version)/$master$ELF_32,$nv_root/nvidia.$(new_version)/$master$ELF_64,$nv_xorg_dir}; do
			[ -d $d ] || mkdir -p $d
		done
		# nvidia-installer librairies log file
		lib_logfile=$nvlog/libinstall-$(new_version).log
		## install default libs with nvidia-installer
		echo "# ($n%) - Install Nvidia default librairies"; sleep 1
		nv_cmd_install_libs
		## report nvidia installer log message
		if [ $(cat $lib_logfile| grep -c "WARNING") -gt 0 ]; then
			if [ $(cat $lib_logfile| grep "WARNING"| grep -c "libGL.so") -gt 0 ]; then
				report_log+=("${vB}Nvidia-installer:\t${end}${jB} no effect\t\t${end}> ${y}WARNING on missing /usr/lib(32/64)/LibGL.so link,\n\t\t\t\t\t\t    LibGL.so is already link in default nvidia's libraies directory${end}.\n")
			elif [ $(cat $lib_logfile| grep "WARNING"| grep -c "libglvnd") -gt 0 ]; then
				report_log+=("\t\t\t${jB} no effect\t\t${end}> ${y}WARNING missing libglvnd developpement files.${end}\n")
			fi
		fi
		## control if libraries are properly installed
		if [[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| grep -c ".*") -lt 40 ]]|| \
		[[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| grep -c ".*") -lt 40 ]]; then
			$d_zen --width=450 --title="$_zen_title" $win_icon --error --no-wrap \
			--text="${v}${r}LIBS INSTALL CONTROL RETURN ERRORS.${end}.\nCheck $lib_logfile for more details.${end}"
			kill $zen_pid
# 			if [ $? = 0 ]; then base_menu; fi
		else
			report_log+=("${vB}Libraries install:\t${end}${gB} success\t\t${end}> ${y}normal install process${end}.\n")
		fi
		n=$[ $n+5 ]; echo "$n" # 4
		cd $nvtmp
		if [[ -s $nvtmp/$extracted_release/nvidia-installer ]]; then
			echo "# ($n%) - Backup new Nvidia-Installer to $nvdir"; sleep 2
			cp -f NVIDIA-Linux-$ARCH-$(new_version)/nvidia-installer $nvdir
			n=$[ $n+1 ]; echo "$n" # 5
		fi
		echo "# ($n%) - Update new driver version file"; sleep 2
		printf "$(new_version)" > $nvdir/version.txt
		n=$[ $n+1 ]; echo "$n" # 6
		# Backup installed binary from release to release dir archive
		if [ ! -f $nvdl/nv-update-$(new_version) ] ; then
			cp -f $run_pkg $nvdl/nv-update-$(new_version)
			if [[ -f $nvdl/nv-update-$(new_version) ]] ; then
				echo "# ($n%) - Driver $(new_version) release package backup success"; sleep 2
			else
				$d_zen --width=450 --title="$_zen_title" $win_icon --error --no-wrap \
				--ok-label="Go it, let's go on."--text="\n${v}Driver ${j}$(new_version)${end} release repos backup mistake.${end}"
			fi
		else
			echo "# ($n%) - nv-update-$(new_version) already present in path, skip"; sleep 2
		fi
		n=$[ $n+2 ]; echo "$n" # 7
		post_install
		echo "99"; sleep 2
		echo "100"
		## Install report display.
		if [[ $inst_mod_version == $(new_version) ]]; then
			if [ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| grep -c ".*") -gt 40 ]|| \
			[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| grep -c ".*") -gt 40 ]; then
			rep_msg=$( cat <<-RPT
			${vB}${bf}<i>Congratulations !</i>${end}${end}
			${jB}$(new_version)${end} ${vB}driver is now succefully installed${end}.

			${v}You may now configure your ${j}xorg.conf${end} file to fit with your current default display before restarting
			your computer with the new installed drivers.
			You may also do it later if you like, but it's not really recommanded.

			What do you want to do ?${end}
			RPT
			)
			install_report_log
			fi
		else
			error_log=$(
			cat <<-RPT
				${rB}${bf}Unexpected ERROR.${end}${end}
				${jB}$inst_mod_version isn't $(new_version)${end}.
				Really weird. ${jB}O_o${end} !
				Some unknown bug pops up during driver installation.
				Or developper fucked out something ?
				Can't tell.
			RPT
			)
			$d_zen $win_icon --width=450 --title="$_zen_title" --error \
 			--text="${v}$error_log${end}"
 			kill $zen_pid
		fi
		} | $d_zen $win_icon --width=450 --title="$_zen_title" --progress --percentage=1 --auto-close
		rm -f $tmp_b
		base_menu
	else
		error_log=$(
		cat <<-RPT
			${rB}${bf}Ouch!${end}${end}
			${jB}No proper Nvidia package found in repository${end}.
			Go to the NVIDIA download site :
			${y}http://www.nvidia.fr/Download/Find.aspx?lang=en${end}
			or to NVIDIA ftp repo, here :
			${y}https://download.nvidia.com/XFree86/${end}
		RPT
		)
		$d_zen $win_icon --width=450 --title="$_zen_title" --error \
		--text="${v}$error_log${end}"
		if [ $? = 0 ]; then base_menu; fi
	fi
}
extract_build(){
	[ -d $nvtmp ]|| mkdir -p $nvtmp
	[ -d $buildtmp ]|| mkdir -p $buildtmp
	pushd $nvtmp
	if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version) ]; then
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo "# ($n%) - $(new_version) package already extracted"; sleep 2
		n=$[ $n+30 ]
	else
		[ ! -d NVIDIA-Linux-$ARCH-* ]|| rm -Rf NVIDIA-Linux-$ARCH-*
		## save dir name for install and post install process.
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo "# ($n%) - Primary package extraction"; sleep 2
		progress_msg(){ echo "# ($m%) - Extracting $extracted_release"; echo "$m"; }; m=$n; do_slp=1
		progress "$run_pkg -x" #; . $tmp_c; rm -f $tmp_c
		sleep 1
		if [ "$(new_version)" ]&&[ "$(new_version)" != "$(old_version)" ]; then
			cp -f $nvtmp/$extracted_release/nvidia-installer .
			echo -e "$(new_version)" > $nvdir/new_version.txt
		else
			$d_zen --width=450 --title="$_zen_title" --error \
			--text="${j}${bf}Nvidia repository not found${end}${end}.${v} Extraction failure.${end}"
			base_menu
		fi
	fi
	popd
}
## BACKUP & PROGRESS COUNT ###
tar_count(){
	( eval "$1" &>/dev/null ) & \
	( count_msg )
	m=$(($m+1))
}
progress(){
	test $tmp_c || tmp_c=$(mktemp --tmpdir zn_count.XXX)
	local exitval=0
	local pid progresspid
	if [[ $1 ]]; then
		eval_pid(){
			on_exit(){
				kill $(jobs -p) 2>/dev/null
				wait $(jobs -p) 2>/dev/null
			}
			trap on_exit EXIT
			while [ -d /proc/$pid ]; do
				( progress_msg )
				sleep $do_slp &
				#test $do_slp = 1 && sleep 1 &
				wait $!
				((m++))
			done
			echo -e "n=$m" > $tmp_c
		}
		( eval "$1" &>/dev/null ) & \
		pid=$! eval_pid & \
		progresspid=$!
		wait $pid 2>/dev/null
		exitval=$?
		kill $progresspid 2>/dev/null

		wait $progresspid 2>/dev/null
   fi
   ## line to paste in global progress count
	#	. $tmp_c ; rm -f $tmp_c
	return $exitval
}
backup_old_version(){
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	if [ -d $nv_root/nvidia.$bak_version ]; then
		cd $nvbackup
		## make the archive.
		m=1
		count_msg(){ echo "# ($m%) - Backup : $bak_version tar ball creation"; sleep 1; echo "$m"; }
		do_slp=1; progress_msg(){ echo "# ($m%) - Backup : $bak_version GZIP archive creation"; echo "$m"; }
		tar_count "tar cf nvidia.$bak_version.tar /etc/OpenCL"
		tar_count "tar uf nvidia.$bak_version.tar /etc/ld.so.conf.d/nvidia-*"
		test -f /etc/modprobe.d/open-NVIDIA.conf && tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/open-NVIDIA.conf"
		test -f /etc/udev/rules.d/01-nvidia-driver.rules && tar_count "tar uf nvidia.$bak_version.tar /etc/udev/rules.d/01-nvidia-driver.rules"
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/blacklist-nouveau.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/nvidia-blacklist.conf"
		## if backup is create with a use_open var to 1 and the present driver config is different,
		## open-NVIDIA.conf file is not enought to tell the right way of use. User's use_open var must be saved too.
		tar_count "tar uf nvidia.$bak_version.tar /home/$(def_user)/.zenvidia/basic.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf.nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-hibernate.service.wants"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-suspend.service.wants"
		## take care of dkms auto install behaviour upon open source driver installation.
		test -f /etc/dkms/no-autoinstall && tar_count "tar uf nvidia.$bak_version.tar /etc/dkms/no-autoinstall"
		tar_count "tar uf nvidia.$bak_version.tar /lib/modules/$KERNEL/$(module_dest_location)/nvidia*"
		tar_count "tar uf nvidia.$bak_version.tar /lib/firmware/nvidia/$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia.$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar /usr/lib/systemd/system/nvidia-*"
#  		test -d /usr/$master$ELF_32/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
#  		test -d /usr/$master$ELF_64/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
 		[ -d /usr/$master$ELF_32/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
 		[ -d /usr/$master$ELF_64/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*"
		make -C /usr/src/nvidia-$bak_version clean
		tar_count "tar uf nvidia.$bak_version.tar /usr/src/nvidia-$bak_version"
		if [ -d /usr/src/open-nvidia-$bak_version ]; then
			make -C /usr/src/open-nvidia-$bak_version clean
			tar_count "tar uf nvidia.$bak_version.tar /usr/src/open-nvidia-$bak_version"
		fi
		tar_count "tar uf nvidia.$bak_version.tar $install_dir/bin/nvidia-*"
		if [[ $(ls -1 /usr/local/$master$ELF_32/libnvidia-*| grep -c $bak_version) -le 3 ]]; then
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_32/libnvidia-{fbc{.so,.so.1},*.$bak_version}"
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}"
		else
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}"
 		fi
# 		tar_count "tar uf nvidia.$bak_version.tar $install_dir/share/nvidia/nvidia-application-profiles-$bak_version*"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/dkms/nvidia/$bak_version/{source,$KERNEL}"
		[ -d /var/lib/dkms/open-nvidia/$bak_version ] && \
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/dkms/open-nvidia/$bak_version/{source,$KERNEL}"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/nvidia/{dirs,log}"
		tar_count "tar uf nvidia.$bak_version.tar $nvdir/version.txt"
## compress in gz.
		progress "gzip -c nvidia.$bak_version.tar > nvidia.$bak_version.tar.gz"
		echo "" > $tmp_c
		echo "# Backup: $bak_version GZIP archive created"; sleep 1
		rm -f nvidia.$bak_version.tar
	fi
}
## UPDATE DRIVER SECTION ###
upgrade_new_kernel(){
	unset kern_list
	up_version=$(version)
	ls_kern=$(ls -1 /boot| grep -v "rescue"| grep "vmlinuz"| sed -n 's/^[[:alpha:]]*-//p')
	for linuz in ${ls_kern}; do
		kern_list+=("false")
		kern_list+=("$linuz")
	done
	w_text=$( cat <<-MSG
		$menu_msg
		${v}Driver install ${j}$up_version${end} for hardware ${j}${dev[0]}${end}.
		Pick the up to date kernel${end}
	MSG
	)
	NEW_KERNEL=$($d_zen --height=300 $win_icon --title="$_zen_title" --list --radiolist --hide-header \
	--text "$w_text" --column "set" --column "action" --separator=";" "${kern_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	if [ $(echo -e "$NEW_KERNEL"| grep -E -c "[0-9]+") -gt 0 ]; then
		upgrade_kernel
	fi
}
upgrade_kernel(){
	if [[ $NEW_KERNEL ]];then
		KERNEL=$NEW_KERNEL
	fi
	if [ $upgrade_other = 1 ]; then
		kernel_path="/lib/modules/$KERNEL/$(module_dest_location)/"
# 		kernel_src="/usr/src$alt/$KERNEL"
	fi
	kernel_src="/usr/src$alt/$KERNEL"
	drv_release=$(ls $nvdl/ | grep "$(new_version)")
	confirm_msg="${v}Kernel update ${j}$KERNEL${end} :$d${end}"
	val_title="$_zen_title"
	val_confirm="$CC"
	val_back="$MM"
	val_cancel="base_menu" #TEXT
	val_exit="base_menu"
	win_confirm
	( echo "# Kernel update $KERNEL ..."
	cd $nvdl/
	nv_cmd_update
	if [ $pass -gt 0 ]||[ ! -e $kernel_path/nvidia.*[ko\|ko.xz] ]; then
		$d_zen $win_icon --width=450 --title="$_zen_title" --error \
		--text="${j}INSTALL ABORT ABNORMALY, check $(echo "$logfile" | sed -n 's/^.*=//p')${end}."
		exit 0
	fi
	new_version=$(version)
	) | $d_zen $win_icon --width=450 --title="$_zen_title" --progress --pulsate --auto-close
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/update-$KERNEL.log; fi
	base_menu
}
## FROM A REMOTE/USER DIRECTORY ###
from_directory(){
	nv_dir(){
		unset list_drv
		table_opts='--column "set" --column "action" --separator=";"'
		zen_opts='--list --radiolist --hide-header'
		cd $nvdl; n=1
		for local_drv in ${nvdl_list[@]}; do
			if [ $_drive ]&&[[ "$local_drv" =~ "$_drive" ]]; then
				list_drv+=("true")
			else
				list_drv+=("false")
			fi
			list_drv+=("$local_drv")
		done
		w_text=$(
		cat <<-INFO
			${j}${bf}Install from stock${end}${end}

			${vB}Driver list in $nvdl :${end}

			$loaded
		INFO
		)
		drv_pick=$($d_zen --width=400 --height=220 $win_icon --title="$_zen_title" $zen_opts \
		--text="$w_text" $table_opts ${list_drv[@]})
		if [ $? = 0 ]; then
			if [ "$drv_pick" != '' ]; then
				run_pkg=$nvdl/$drv_pick
			else
				from_directory
			fi
		else
			if [ $_drive ]; then base_menu; else menu_install; fi
		fi
	}
	home_dir(){
		unset list_drv
		table_opts='--column "set" --column "2" --column "action" --separator=";" --hide-column=2'
		zen_opts='--list --radiolist --hide-header'
		for local_drv in ${home_list[@]}; do
			list_drv+=("false")
			list_drv+=("$local_drv")
			list_drv+=("$(sed -En "s|^.*\/||g;p" <<< $local_drv)")
		done
		w_text=$(
		cat <<-INFO
			${j}${bf}Install from user directory${end}${end}

			${vB}Select a driver from ${j}$(def_user)${end} download directory${end}

			$loaded
		INFO
		)
		drv_pick=$($d_zen --width=400 --height=220 $win_icon --title="$_zen_title" $zen_opts \
		--text="$w_text" $table_opts ${list_drv[@]})
		if [ $? = 0 ]; then
			if [ "$drv_pick" != '' ]; then
				chmod a+x $drv_pick
				run_pkg=$drv_pick
			else
				from_directory
			fi
		else
			menu_install
		fi
	}
	test $(version) && loaded="${v}<i>($(version) actually installed and loaded)</i>${end}"
	nvdl_list=( $(ls -1 $nvdl| grep -v ".sum"| tac) )
	home_list=( "$(find $(user_DL_DIR)/ -regextype sed -regex "^.*NVIDIA-Linux-.*\.run"| tac)" )
	if [ $ui_mod = 1 ]; then
		A="Use Zenvidia stock directory"
		B="Use a user local directory"
		zen_opts='--list --radiolist --hide-header'
		table_opts='--column "set" --column "2" --column "action" --separator=";" --hide-column=2'
		w_text=$(
		cat <<-INFO
			${j}<b>Local NVIDIA drivers STOCK</b>${end}

			Zenvidia release stock : ${j}${#nvdl_list[*]}${end} object(s) found.
			User home directory : ${j}${#home_list[*]}${end} object(s) found.

			${v}<b>Select the directory to install from.</b>${end}
		INFO
		)

		from_cmd=$($d_zen --width=400 --height=220 $win_icon --title="$_zen_title" $zen_opts \
		--text="${v}$w_text${end}" $table_opts false 1 "$A" false 2 "$B" )
		if [ $? = 1 ]; then base_menu; fi
		case $from_cmd in
			"1") nv_dir ;;
			"2") home_dir ;;
			*) menu_install ;;
		esac
	elif [ $ui_mod = 2 ]; then
		nv_dir
	fi
	new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
	install_drv
}
from_net(){
# download functions
		cd $buildtmp
		download_menu
		run_pkg=$nvdl/nv-update-$LAST_PACK
		if [ -f $buildtmp/$run_pack ]; then
			$d_zen --info $win_icon --title="$_zen_title" --no-wrap $icon_name=swiss_knife \
			--text="${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
			mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
			chmod 755 $nvdl/nv-update-$LAST_PACK
		fi
		new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
		install_drv
}
net_version_selector(){
	if [ $hlp_txt = 1 ]; then
		hlp_tip="\n$hlp_01b"
		hlp_tip=$( cat <<-HLP

		${vB}Select the driver version type to install${end}
		   - ${vB}Look up for latest${end}:
		   Look for the last available packges from Nvidia repos site.0
		   - ${vB}Look up for older version${end}:
		   Look for a previous packeges available in Nvidia repos site.
		HLP
		)
		if [ $zenity_ver -le 3420 ]; then
		w_height='--height=300'
		else
			w_height='--height=400'
		fi
	else
		hlp_tip="\n${vB}Select the driver version type to install${end}"
		if [ $zenity_ver -le 3420 ]; then
		w_height='--height=200'
		else
			w_height='--height=300'
		fi
	fi
	menu_select=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	true 1 "Look for latest version" false 2 "Look for older version")
	if [ $? = 1 ]; then base_menu; fi
	case $menu_select in
		"1") check_for_newer ;;
		"2") check_for_older ;;
		*) base_menu ;;
	esac
	check_update
}
check_for_older(){
# 	drv_list=( "$(tac $(user_CF_DIR)/notify/drvlist)" )
	unset rem_packages_list old_pack_list
	rem_packages_list=( $(tac $(rem_drv_list)) )
	for pack_list in "${rem_packages_list[@]}"; do
		old_pack_list+=("false")
		old_pack_list+=("$pack_list")
		n=$[ $n+1 ]
	done
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=300'
	else
		w_height='--height=400'
	fi
	older_pack=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}" \
	--column "set" --column "action" \
	"${old_pack_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	LAST_DRV=$older_pack
	legacy_drv=1
}
check_for_newer(){
	(	wget -q -O $upcompat/last_update https://$nvidia_ftp-$ARCH/latest.txt
		sleep 2
	) | $d_zen --width=400 $win_icon --title="$_zen_title" --progress --pulsate --auto-close \
	--text="${v}NVIDIA Download center data check${end}"
	LAST_DRV=$(cat $upcompat/last_update | awk '{ print $1 }')
	legacy_drv=0
}
## UPDATED RELEASE CHECK ###
hardware_compat(){
	{ wget -q -O $upcompat/upt_compat https://$nvidia_ftp-$ARCH/$DRV/README/supportedchips.html
		sleep 2
	}| $d_zen --width=400 $win_icon --title="$_zen_title" --progress --pulsate \
	--auto-close --text="${v}NVIDIA Download center compatibility check (${j}$DRV${end})...${end}"

	cat $upcompat/upt_compat | sed -n "/<h3>/,/Below are the legacy/{;/<tr\|<td\|<\/tr>/p}"| \
	perl -n -pe "s|(<(/\|)t[r,d](>\| id=\"))||,s|(\">\|</td>)\n|,|p" > $nvcompat/compat.$DRV

	## build a genaral compatibility list for series drivers classes.
	upt_compat_list=$(user_CF_DIR)/updates/upt_compat_list
	upt_local_conf=$(rem_drv_list)

	cat $upcompat/upt_compat | sed -n "/<h3>/,/name=\"subsys/p"| \
	perl -n -pe "s|(<(/)?t[r,d,a,b](ble\|ody)?(>\| id=\")?)||;s|(\">\|</td>)\n|,|; \
	s|.*legacy_(.*.xx)\">.*|* \1|;s|.*<[/]?[dtpc].*$||p"| \
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p" > $upt_compat_list
	## add a separator at the end.
	echo -e "------" >> $upt_compat_list

	## here start the compatibility tool.
	unset COMPAT class_list sed_output
	[ -d $nvcompat ]|| mkdir -p $nvcompat/series
	IFS=$(echo -en "\n\b")
	## define the separation chapter series section.
# 	COMPAT+=("Current NVIDIA GPUs")
	COMPAT+=("<h3>")
	COMPAT+=("$(grep -E "\* *[0-9]{2,4}((.xx)|(\.*[0-9]{2,3}.xx))" $upt_compat_list)")
	if [ $(ls -1 $nvcompat/series/ | grep -E -c "^[0-9]*\.[0-9]*\.[0-9]*$") -gt 0 ]; then
		rm -f $nvcompat/series/* | grep -E "^[0-9]*\.[0-9]*\.[0-9]*$"
	fi
	for line in ${COMPAT[@]}; do
		if [[ $line =~ ".xx" ]]; then
			drv_class=$(echo -e "$line"| sed -En "s/\* (.*).xx$/\1/p")
			line=$(cut -d' ' -f2 <<< $line)
		else
			drv_class=$(echo "$DRV"| cut -d. -f1)
		fi
		drv_end=$(cat <<< ${COMPAT[*]}| grep -A1 "$line"| sed -En "s/^\* (.*).xx$/\1/g;\$p")
		test "$drv_end" = "$drv_class" && drv_end='-----'
		## send result in separate compat files.
		sed_output=( $( sed -En "/$line/,/$drv_end.xx/p" $upt_compat_list) )
		sed -En "/$line/,/$drv_end.xx/p" $upt_compat_list | grep -E "^devid" > $nvcompat/series/$drv_class
	done
	IFS=$ifs
	## build compat file list from created.
	class_list=("$(ls -1 $nvcompat/series/| sort -n)")
	## dig for device id and usual name.
	pci_class=${dev[$e]}
	pci_brand=${slot_id[$e]}
	## check compat.
	if [ $(grep -ic "devid$pci_brand" $nvcompat/series/$(echo "$DRV"| cut -d. -f1)) -gt 0 ]; then
		## send message for the install_drv section.
		if [ $from_install = 1 ]; then
# 			install_msg="# Compatiblity found in $(echo "$DRV"| cut -d. -f1) serie, proceed to install"
			echo -e "install_msg=\"# Compatiblity found in $(echo "$DRV"| cut -d. -f1) serie, proceed to install\"" > $tmp_b
		else
			legacy=0
			echo -e "comp_result=+\"$DRV,$legacy\"" >> $upt_comp_tmp
		fi
	else
		for comp_file in ${class_list[@]}; do
			if [ $(grep -ic "devid$pci_brand" $nvcompat/series/$comp_file) -gt 0 ]; then
				## message for install_drv section.
				if [ $from_install = 1 ]; then
# 					install_msg="# Your $pci_brand is not compatible with $DRV, look in $comp_file serie instead."
# 					echo -e "# Your $pci_brand is not compatible with $DRV, look in $comp_file serie instead." > $tmp_b
					error_log=$(cat <<-ERR
						${rB}${bf}<i>UNCOMPATIBLE DRIVER</i>${end}${end}
						${v}The ${j}$pci_class${end} is not compatible with ${j}$DRV${end} driver.
						Check in ${j}$comp_file${end} serie instead.
						Abort.${end}
					ERR
					)
					$d_zen --width=450 --title="$_zen_title" --error --no-wrap \
					--text="$error_log" \
					$icon_name=xkill --ok-label="Got it"
					kill $zen_pid
				fi
				## serie driver class for the update/install section.
				family=$comp_file
			fi
		done
		## define vazrs for the update/isntall section.
		if [ $family ]; then
			if [ $family -ne $(chk_version) ]; then
				family_last=$(cat "$upt_local_conf" | grep "$family" | sed -n '$p')
# 				legacy_found=1
				legacy=1
				((comp_display_legacy++))
			else
				legacy=0
			fi
			family_check=1
		else
			## send fatal in no driver support.
# 			install_msg="# Your $pci_brand is not supported by NVIDIA's drivers."
# 			echo -e "# Your $pci_brand is not supported by NVIDIA's drivers." > $tmp_b
			if [ $from_install = 1 ]; then
				error_log=$(cat <<-ERR
					${rB}${bf}<i>UNCOMPATIBILITY ISSUE</i>${end}${end}
					${v}The ${j}$pci_class${end} is not supported by ${j}NIVDIA${end} driver.
					and there's no solution here except maybe reverse to ${j}Nouveau${end} driver.
					Abort.${end}
				ERR
				)
				$d_zen --width=450 --title="$_zen_title" --error --no-wrap \
				--text="$error_log" \
				$icon_name=xkill --ok-label="Got it"
				kill $zen_pid
# 				base_menu
			else
				legacy=0
			fi
			family_check=0
		fi
# 		echo "$DRV,$family_check,$legacy_found,$family,$family_last," >> $upt_comp_tmp
# 		echo -e "comp_result=+\"$DRV,$family_check,$legacy_found,$family,$family_last\"" >> $upt_comp_tmp
		echo -e "comp_result=+\"$DRV,$legacy\"" >> $upt_comp_tmp
		echo -e "family_last=$family_last" >> $upt_comp_tmp
		echo -e "family=$family" >> $upt_comp_tmp
# 		echo -e "legacy=$legacy_found" >> $upt_comp_tmp
		echo -e "legacy=$legacy" >> $upt_comp_tmp
		echo -e "comp_family=$family_check" >> $upt_comp_tmp
		echo -e "comp_display_legacy=$comp_display_legacy" >> $upt_comp_tmp
	fi
# 	comp_check+=("$DRV,$comp_check,$legacy_found")
# 	echo "$DRV,$comp_check,$legacy_found" >> $upt_comp_tmp
}
check_update(){
	unset DIFF_list
	LAST_IN=$(version)
	LAST_BETA=$(tac $(rem_drv_list) | sed -n 1p)
	upt_comp_tmp=$(mktemp --tmpdir zn_vars.XXXX )
	## COMPATIBILTY SECTION
	# first chack if alpha = beta or not.
	if [[ $LAST_DRV == $LAST_BETA ]] ; then
			DIFF_list=$LAST_DRV
	else
			DIFF_list="$LAST_DRV $LAST_BETA"
	fi
	## reset old compatibilty sets.
	legacy_found=0
	family_check=0
	legacy=0
	comp_family=0
	comp_display_legacy=0

	w_height=355
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=355'
	else
		w_height='--height=455'
	fi
	unset dl_allow COMP_L COMP_I LOCAL_DRV comp_check comp_result
	## desktop could have more than one device managed. So check.
	for e in $pci_dev_nb; do
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			for DRV in $DIFF_list; do
				## test existence of the new driver version in remote tree and compatibilities.
				$(hardware_compat)
				. $upt_comp_tmp
				## and prepare optional messages to display.
				if [ $(cat $(rem_drv_list)| grep -c $DRV) -gt 0 ]; then
					dl_allow=1
				else
					dl_allow=0
				fi
				# mark driver stocked in local repos.
				in_pack=$(ls -1 $nvdl/ | grep -c "$DRV")
				test "$DRV" == "$LAST_IN" && _installed=1 || _installed=0
				if [ "$LAST_BETA" ]&&[ "$LAST_BETA" != "$LAST_DRV" ]; then
					if [ $legacy_drv = 1 ]; then
						test "$DRV" == "$LAST_BETA" && _is_beta=0 || _is_beta=1
					else
						test "$DRV" == "$LAST_BETA" && _is_beta=1 || _is_beta=0
					fi
					test $legacy_drv -gt 0 && _is_beta=0
				else
					_is_beta=0
				fi
				DEV_filter=$(cat $nvcompat/compat.$DRV| grep -E -i "devid${slot_id[$e]}")
				dev_compat=$(cat $nvcompat/compat.$DRV| grep -E -ic "devid${slot_id[$e]}")
				VDPAU_class=$(printf "$DEV_filter"|cut -d"," -f4) # J
				LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow")
			done
		fi
	done
	## write it in default script directory for further use.
	echo -e "${COMP_I[@]}" > $nvcompat/compat.update
	sed -i "/^[[:space:]]*$/d;s/^\ //g" $nvcompat/compat.update
	win_update
}
win_update(){
	## define window messages and display compatibilities.
	in_local_repos=0
	in_dl_repos=0
	in_installed=0
	in_compat_list=0
# 	end_msg="What do you want to do ?"
	unset DOWN_list main_msg more_msg
	## get driver list from check_update to define local presence and what to display.
	# LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow")
	# '364.12,0,0,0,"0",GeForce RTX 2060,,1'
	# '525.85.05,1,0,0,"1",GeForce RTX 2060,J,1'
	IFS=$(echo -en "\n\b")
	for local_drv in ${LOCAL_DRV[@]}; do
		_drive=$(echo "$local_drv"|cut -d',' -f1)
		_exist=$(echo "$local_drv"|cut -d',' -f2)
		_insta=$(echo "$local_drv"|cut -d',' -f3)
		_beta=$(echo "$local_drv"|cut -d',' -f4)
		_dev_comp=$(echo "$local_drv"|cut -d',' -f5)
		_name=$(echo "$local_drv"|cut -d',' -f6)
		_vclass=$(echo "$local_drv"|cut -d',' -f7)
		_dl_ok=$(echo "$local_drv"|cut -d',' -f8)
		## messageries
		end_msg="What do you want to do ?"

		case $_insta in
			0) set_in='' ;;
			1) set_in=" (installed)"; ((in_installed++)) ;;
		esac
		if [ "$_vclass" ]; then comp_v="(VDPAU class $_vclass)"; fi
		case $_dl_ok in
			0) dl_warn="\n${y}but is not downloadable yet (wont be list)${end}" ;;
			1) dl_warn='' ;;
		esac

		case $_dev_comp in
			0) comp_a="${vB}uncompatible${end}"
				comp_b="${y}$_drive${end} ${rB} driver doesn't manage your hardware${end}\n"
			;;
			1) comp_a="compatible"
# 				comp_b="compatible. $comp_v"
				comp_b="${j}$_drive${end} ${v} driver fit your hardware${end} ${y}$(echo -e '\u2764')${end}\n" # or 2714
				((in_compat_list++))
			;;
		esac
		case $_beta in
			0)
			if [ $legacy_drv = 0 ]; then
				set_beta='official'; _drv_title='official'; tab=''
			else
				if [ "$_drive" == "$LAST_BETA" ]; then
					set_beta='official'; _drv_title="last release"; tab=''
				else
					set_beta='legacy' ; _drv_title='legacy'; tab='  '
				fi
			fi
			;;
			1) set_beta='beta'; _drv_title='beta'; tab='- -';;
		esac
		case $_exist in
			0) in_repos='is not in your repository'
				DOWN_list+=("false"); DOWN_list+=("$_drive"); DOWN_list+=("($_drv_title)"); ((in_dl_repos++))
			;;
			1) in_repos='is in your repository'; ((in_local_repos++))
			;;
		esac

		COMP_L+=("${j}$_name${end} ${v}($_drive), $comp_a${end}")
		COMP_L+=("$comp_b")
		main_msg+=("\n${v}The $set_beta version is :${end}${ge} ${tab} - - - - - - ${end}${y}$_drive${end}")
		more_msg+=("\n${j}$_drive${end}${vB} $in_repos.${end}${v}$set_in${end}$dl_warn")
		## define the appropriate UI.
		case $in_local_repos in
			0|1) ui_mod=1		# dl/inst selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg='Nothing to do.' ;;
					1) if [ $in_dl_repos -eq 0 ]; then
								ui_mod=2
						fi
						if [ $in_installed -eq 1 ]; then ui_mod=0; end_msg='Nothing to do.'; fi
					;;
				esac
			;;
			2|3) ui_mod=2		# inst local selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg='Nothing to do.' ;;
					1) if [ $in_dl_repos -gt 0 ]; then
							ui_mod=1
						fi
					;;
				esac
			;;
		esac
	done
	## this section is for lagacy driver part and has to be display only once.
	if [ $comp_display_legacy -ge 1 ]; then # normal
# 	if [ $comp_display -eq 0 ]; then # test
		case $comp_family in
			0) comp_c="${y}this driver is not supported anymore${end}"
				test $legacy -gt 0 && comp_d='\n'
			;;
			1) case $legacy in
					0) comp_d='' ;;
					1) comp_d="\n${v}Last ${y}$family_last${end} will be list.${end}"
						if [ $(ls -1 $nvdl/ | grep -c "$family_last") = 1 ]; then
							in_repos='is in your repository'
							ui_mod=2
						else
							in_repos='is not in your repository'
							DOWN_list+=("false")
							DOWN_list+=("$family_last")
							DOWN_list+=("(last legacy)")
						fi
						more_msg+=("\n${j}$family_last${end}${vB} $in_repos.${end}")
					;;
				esac
				comp_c="\n${v}Devices compatibility found in ${y}$family${end} serie${end}$comp_d"

			;;
		esac
		COMP_L+=("$comp_c")
	fi
	compat_msg=$(cat <<< ${COMP_L[*]})
	IFS=$ifs

	extra_msg="\n${more_msg[@]}\n\n${v}$end_msg${end}"
	case $ui_mod in
		0)	zen_opts="--info $icon_name=swiss_knife --ok-label=OK"
			table_opts=''
			list_opts=''
			;;
		1)	zen_opts='--list --radiolist --hide-header'
			table_opts='--column "set" --column "2" --column "action" --separator=";" --hide-column=2'
			list_opts="false 1 Install false 2 Download ";;
		2)	zen_opts="--question --ok-label=Install --cancel-label=Abort"
			table_opts=''
			list_opts=''
			;;
	esac
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=180'
	else
		w_height='--height=280'
	fi
	w_text=$(cat <<-MSG
		${jB}${bf}Available drivers${end}${end}

		${v}Driver version installed :${end}${ge} - - - - - ${end}${j}$drv_installed${end}
		$(cat <<< ${main_msg[@]})

		$compat_msg
		$extra_msg
	MSG
	)
	sel_cmd=$($d_zen --width=300 $w_height $win_icon --title="$_zen_title" $zen_opts \
	--text="$w_text" $table_opts $list_opts )
	if [ $? = 0 ]; then
		case $ui_mod in
			0) base_menu ;;
			1) case $sel_cmd in
					"1") ok_label='Install'; from_net ;;
					"2") ok_label='Download'; download_only ;;
				esac ;;
			2) from_directory ;;
			*) menu_install ;;
		esac
	else
		base_menu
	fi
}
download_menu(){
# 	IFS=$(echo -en "\n\b")
# 	if [ ${#DOWN_list[*]} -le 3 ]; then
# 		w_dim='--width=200 --height=100'
# 		zen_opts="--question --ok-label=$ok_label --cancel-label=Abort"
# 		table_opts=''
# # 		list_opts=''
# 		w_text=$( cat <<-INFO
# 			${jB}${bf}Downloads${end}${end}
#
# 			${y}${DOWN_list[1]}${end}${v} will be downloaded.
#
# 			Please confirm.${end}
# 		INFO
# 		)
# 		output_type=0
# 	else
# 		IFS=$(echo -en "\n\b")
		w_dim='--width=300 --height=220'
		zen_opts='--list --radiolist --hide-header'
		table_opts='--column "set" --column "2" --column "action" --separator=";"'
# 		list_opts="$(echo -e "")"
		w_text=$( cat <<-INFO
			${jB}${bf}Downloads${end}${end}
			${v}Select the drivers version you wish to install/download.
			in the list below${end}
		INFO
		)
		output_type=1
# 	fi
	dl_cmd=$($d_zen $w_dim $win_icon --title="$_zen_title" $zen_opts \
	--text="$w_text" $table_opts "${DOWN_list[@]}" )
	if [ $? = 1 ]; then
		base_menu
	else
		if [ "$dl_cmd" ]; then
			LAST_PACK=$dl_cmd
		else
			test ${#DOWN_list[*]} -le 3 && LAST_PACK=${DOWN_list[1]} || base_menu
		fi
	fi
# 	IFS=$ifs
	last_pack
}
download_only(){
	cd $buildtmp
	download_menu
	if [ -f $buildtmp/$run_pack ]; then
		$d_zen --info $win_icon --title="$_zen_title" --no-wrap $icon_name=swiss_knife \
		--text="${v}Driver download ${j}$LAST_PACK${end} ended.\n$MM${end}"
		test -f $buildtmp/$run_pack.sha256sum && rm -f $buildtmp/$run_pack.sha256sum
		mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
		chmod 755 $nvdl/nv-update-$LAST_PACK
		base_menu
	else
		$d_zen --width=450 $win_icon --title="$_zen_title" --error \
		--text="${v}Driver download ${j}$LAST_PACK${end} failure.\n The package ${j}$run_pack${end} doesn't exist.\n$MM.${end}"
		base_menu
	fi
}
## ### UPDATE FUNCTION, FROM INTERNET. ###
last_pack(){
	track(){
    # picked up & inspired by winetricks download progress commande:
    # Parse a percentage, a size, and a time into $1, $2 and $3
    # then use them to create the output line.
   	perl -p -e "$| = 1; s|^.* +([0-9]+%) +([0-9,.]+[GMKB]) +([0-9hms,.]+).*$|\1\n# $run_pack\t(\1): time left \3\t\2\/s|"
	}
	download_cmd(){
		$p_wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack $buildtmp/ 2>&1
	}
	download_error(){
		$d_zen --height=100 --error $win_icon $icon_name=xkill --no-wrap \
		--text="${v}$w_text${end}" --ok-label="Heeeh !?"
		if [ $? = 0 ]; then base_menu; fi
	}
	$p_wget -q -O $nvtmp/bug_list https://$nvidia_ftp-$ARCH/$LAST_PACK/
	if [ -s $nvtmp/bug_list ]; then
		(	cat $nvtmp/bug_list | grep -E -o "href='NVIDIA.*[0-9]+.*'"| perl -pe "s/^.*\'(.*)\'/\1/p" \
			> $nvtmp/selector
			sleep 2
		) | $d_zen --width=500 $win_icon --progress --pulsate --auto-close --text="${v}Remote content control...${end}"
		if [ $(cat $nvtmp/selector | grep -c "$LAST_PACK") -gt 0 ] ; then
			RUN_PACK=$(cat $nvtmp/selector)
		fi

		unset drv_list
		for line in $RUN_PACK; do
			drv_list+=("false")
			drv_list+=("$line")
		done
		run_pack=$($d_zen --width=450 --height=300 $win_icon --title="$_zen_title" --list \
		--text="${v}Choose the version to install${end}" --radiolist --hide-header \
		--column "set" --column "action" "${drv_list[@]}" --separator=";")
		if [ $? = 1 ]; then exit 0; fi
		## from there, look into 'selector' file for sha256sum file.
		if [ $(cat $nvtmp/selector| grep -c "sha256sum") -gt 0 ]; then
			run_pack_sha=$run_pack.sha256sum
		fi
		( 	test $run_pack_sha && $p_wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack_sha $buildtmp/ &>/dev/null
			download_cmd | track
		) | $d_zen --width=500 $win_icon --progress --auto-close --title="$_zen_title"
		err=$?
		if test $err -gt 128; then
			if pid=`ps -A | grep ."wget" | awk '{print $1}'`; then
					echo User aborted download, killing wget
					kill $pid
			fi
		fi
		# get weight of the pack in ko.
		_local=$(du -h $buildtmp/$run_pack | awk '{print $1}'| grep -o "[0-9]*")
		_remote=$(cat $nvtmp/bug_list | grep -A1 "$run_pack<"|sed -En "s/^.*>(.*)<\/.*>.*$/\1/g;2p"| grep -o "[0-9]*")
		if [ -f $buildtmp/$run_pack.sha256sum ]; then
			local_sha=$buildtmp/$run_pack.sha256sum
			sha256sum $run_pack
			sha256sum --status -c $local_sha
			if [ $? = 1 ]; then
				w_text="${j}<b>Download check sum error</b>${end}.\nTransaction aborted\nTry to restart driver download from ${vB}Update${end} menu"
				download_error
			fi
		fi
		if [ $_remote -ne $_local ]; then
			w_text="${j}<b>Download unexpected end</b>${end}.\nPlease restart driver download from ${vB}Update${end} menu"
			download_error
		fi
		return $err
   else
		icone='xkill'
		w_label="Got it!"
		w_text="${rB}$fatal_dev\Remote directory is empty.\n${end}${v}Nvidia devs have probably forgoten to upload data.\nFeel free to try at a later time.${end}"
		win_warning
		base_menu
	fi
}
## TOOLS ###
win_confirm(){
	## Popup confirmation window to be clomplete with the following vars:
	#	confirm_msg="" #TEXT
	#	val_title="" #TEXT
	#	val_confirm="" #TEXT
	#	val_back="" #TEXT
	#	val_cancel="" #CMD
	#	val_exit="" #EXIT CMD
	confirm_w=$($d_zen --title="$val_title" $win_icon --list --radiolist \
	--hide-header --text "$confirm_msg\n\n${v}What do you want to do ?${end}" --hide-column "2" \
	--column "set" --column "2" --column "action" --separator=";" \
	false 1 "$val_confirm" false 2 "$val_back")
	if [ $? = 1 ]; then ${val_cancel} ; fi
	case $confirm_w in
		"1") shift ;;
		"2") ${val_exit};;
		*) ${val_cancel};;
	esac
}
win_open_switch(){
	if [ $open_drv -gt 0 ]; then
		if [ $use_open -gt 0 ]; then OPEN='TRUE'; PROP='FALSE'; else OPEN='FALSE'; PROP='TRUE'; fi
		old_open_drv=$open_drv
		old_use_open=$use_open
		_text=$( cat <<-MSG
			${j}${bf}Driver switch${end}${end}
			${v}Driver type selection (open source / proprietary).
			<i>(driver license $($d_modinfo -F license nvidia -k $KERNEL) loaded)</i>${end}
		MSG
		)
		_title="$_zen_title"
		driver_swt=$($d_zen --width=500 --list $win_icon --title="$_title" --text="$_text" \
		--column="check" --column="hide" --column="driver" --radiolist --print-column=2 --hide-column=2 \
		--separator='' --hide-header $PROP "0" "Load proprietary drivers" $OPEN "1" "Load Open Source Drivers")
		if [ $? = 1 ]; then menu_modif; fi
		if [ $? = 0 ]; then
			use_open=$driver_swt
			if [ $use_open -ne $old_use_open ]; then
				nv_open_switch
				menu_modif
			fi
		fi
	fi
}
## PACKAGE MANAGING ###
manage_pcks(){
	w_height='--height=300'
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=300'
	else
		w_height='--height=400'
	fi
	hlp_tip=''
	w_text=$( cat <<-MSG

		${v}<b>Manage Drivers Packages</b>:

		<u>Note</u> : <i>In case of issue after restoration (ex: driver not loading),
		try command line tools in first place after reboot.
		Many distro auto reload desktop manager at boot. If you meet this issue,
		you have to disable the desktop manager with systemcl before operating
		with "zenvidia rebuild [version]" command line</i>.${end}
		MSG
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(cat <<-HLP

		${v}- <b>Remove downloaded packages</b>:
			Manage downloaded packages in Zenvidia directory.
		- <b>Backup tools</b>:
			Make a drivers and librairies backup of the current version.
		- <b>Restore tool</b>:
			Make a restoration of previously backed up drivers installation.
		- <b>Remove Nvidia and restore to default</b>:
			Remove completly Nvidia Drivers installation and restore default Nouveau drivers.${end}
		HLP
		)
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=400'
		else
			w_height='--height=500'
		fi
	fi
	menu_packs=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Manage drivers packages${end}${end}$w_text$hlp_tip" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	false 1 "Remove downloaded package" false 2 "Backup tools" false 3 "Restore a backup" false 4 "Remove Nvidia and restore to default")
	if [ $? = 1 ]; then menu_modif; fi
	case $menu_packs in
		"1") remove_pcks ;;
		"2") backup_tools ;;
		"3") restore_pcks ;;
		"4") remove_nvidia ;;
		*) menu_modif ;;
	esac
}
remove_pcks(){
	# list package in release directory
	unset rm_packs packs_list
	for pack in $(ls -1 $nvdl); do
		packs_list+=("false")
		packs_list+=("$pack")
	done
	w_text=$( cat <<-MSG
		${j}${bf}Remove downloaded package${end}${end}
		Select on or more packages to be removed.
	MSG
	)
	rm_packs=$($d_zen --width=400 --height=300 $win_icon --list --multiple \
	--checklist --hide-header --title="$_zen_title" \
	--text "${v}$w_text${end}" \
	--column "set" --column "action" --separator=" " \
	"${packs_list[@]}" )
	if [ $? = 1 ]; then manage_pcks; fi
	w_text=$( cat <<-MSG
		Selected to be removed:
		${j}$rm_packs${end} driver(s).

		Please, confirm.
	MSG
	)
	# check that list not empty before proceed.
	if [[ $rm_packs ]]; then
		$d_zen --width=300 $win_icon --title="$_zen_title" --question \
		--text="${vB}$w_text${end}" \
		--ok-label="$CC" --cancel-label="$PM"
		if [ $? = 0 ]; then
			for vers in ${rm_packs[@]}; do
				pack_vers=$(printf "$vers"|sed -n "s/^.*-//g;p")
				vers_ref=$(printf "$pack_vers"|sed -n "s/\.//p")
				ls -d /var/lib/dkms/nvidia/$pack_vers &>/dev/null
				if [ $? = 0 ]; then
					w_text=$(cat <<-INFO
						<b>$pack_vers still exist in DKMS tree</b>.

						Remove all associated package and directory ?
						<i>(All reference in $nv_root will be also removed if found)</i>

						Please, confirm.
					INFO
					)
					$d_zen --width=300 $win_icon --title="$_zen_title" --question \
					--text="${v}$w_text${end}"
					if [ $? = 0 ]; then
						if [[ $ver_pack = $ver_txt ]]; then
							w_text=$( cat <<-WRN
							The associated directory you're about to remove is the same as the actually running.
							This action will fataly break ${j}$pack_vers${end} installation
							You don't want to do this.

							Action skipped."
							WRN
							)
							$d_zen --height=100 $win_icon --title="$_zen_title" \
							$icon_name=xkill --error --no-wrap --text="${v}$w_text${end}" \
							--ok-label="I understand my mistake"
						else
							test -d $nv_root/nvidia.$pack_vers && rm -Rf $nv_root/nvidia.$pack_vers
							rm -f $nvdl/nv-update-$pack_vers
							$p_dkms remove nvidia/$pack_vers --all
							test -d /var/lib/dkms/open-nvidia/$pack_vers && $p_dkms remove open-nvidia/$pack_vers --all
						fi
					fi
				else
					test -d $nv_root/nvidia.$pack_vers && rm -Rf $nv_root/nvidia.$pack_vers
					test -f $nvdl/nv-update-$pack_vers && rm -f $nvdl/nv-update-$pack_vers
				fi
			done
			$d_zen --height=100 $win_icon --title="$_zen_title" \
			$icon_name=swiss_knife --info --text="${vB}Driver(s):\n${j}$rm_packs${end}\npackage(s) removed.${end}" --no-wrap
			manage_pcks
		else
			manage_pcks
		fi
	else
		manage_pcks
	fi
}
remove_baks(){
	# list package in release directory
	unset rm_bak bak_list
	for back in $(ls -1 $nvbackup); do
		bak_list+=("false")
		bak_list+=("$back")
	done
	w_text=$( cat <<-MSG
		${j}${bf}Remove backed up package${end}${end}
		Select on or more archives to be removed.
	MSG
	)
	rm_bak=$($d_zen --width=400 --height=300 $win_icon --list --multiple \
	--checklist --hide-header --title="$_zen_title" \
	--text "${v}$w_text${end}" \
	--column "set" --column "action" --separator=" " \
	"${bak_list[@]}" )
	if [ $? = 1 ]; then manage_pcks; fi
	# check that list not empty before proceed.
	if [[ $rm_bak ]]; then
		rem_list=$(echo -n "$rm_bak"| sed -En "s/ /\n/g;p")
		w_text=$( cat <<-MSG
			Selected driver(s) to be removed:
			${j}$rem_list${end}

			Please, confirm.
		MSG
		)
		$d_zen --width=300 $win_icon --title="$_zen_title" --question \
		--text="${vB}$w_text${end}" \
		--ok-label="$CC" --cancel-label="$PM"
		if [ $? = 0 ]; then
			for vers in ${rm_bak[@]}; do
				test -f $nvbackup/$vers && rm -f $nvbackup/$vers
			done
			$d_zen --height=100 $win_icon --title="$_zen_title" \
			$icon_name=swiss_knife --info --text="${vB}Driver(s) Archive(s) removed.${end}" --no-wrap
			manage_pcks
		else
			manage_pcks
		fi
	else
		manage_pcks
	fi
}
remove_nvidia(){
## clean remove of nvidia packeges and nouveau restoration.
	## display warn before process. Zenity hare.
	w_text=$( cat <<-MSG
		NVIDIA driver installation will be completaly removed.
		Only Nouveau driver will usable after reboot.

		Please, confirm.
	MSG
	)
	$d_zen --width=300 $win_icon --title="$_zen_title" --question \
	--text="${vB}$w_text${end}" --ok-label="$CC" --cancel-label="$PM"
	if [ $? = 1 ]; then manage_pcks; fi
	{
	echo "# Nvidia Removing ..."; sleep 2
	## nvidia version backup.
	if [ ! -f $nvbackup/nvidia.$(version).tar.gz ]; then
		echo "# Making security $(version) backup."; sleep 2
		backup_pcks
	fi
	echo "# Nvidia Installation removal ..."; sleep 2
	## then remove nvidia files.
		rm -f /etc/OpenCL/vendors/nvidia.ics
		rm -f /etc/ld.so.conf.d/nvidia-*
		test -f /etc/modprobe.d/open-NVIDIA.conf && rm -f /etc/modprobe.d/open-NVIDIA.conf
		test -f /etc/udev.d/01-nvidia-driver.rules && rm -f /etc/udev.d/01-nvidia-driver.rules
		rm -f /etc/modprobe.d/blacklist-nouveau.conf
		test -f /etc/modprobe.d/nvidia-drm.conf && rm -f /etc/modprobe.d/nvidia-drm.conf
		test -f /etc/modprobe.d/nvidia-blacklist.conf && rm -f /etc/modprobe.d/nvidia-blacklist.conf
		#rm -f /home/$(def_user)/.zenvidia/basic.conf
		rm -f /etc/X11/xorg.conf
		rm -f /etc/X11/xorg.conf.nvidia
		rm -f /etc/systemd/system/systemd-hibernate.service.wants
		rm -f /etc/systemd/system/systemd-suspend.service.wants
		rm -f /lib/modules/$KERNEL/$(module_dest_location)/nvidia*
		rm -f /lib/firmware/nvidia/$(version)
		rm -f $nv_root/nvidia
		rm -Rf $nv_root/nvidia.$(version)
		rm -f /usr/lib/systemd/system/nvidia-*
 		[ -d /usr/$master$ELF_32/nvidia ]&& rm -Rf /usr/$master$ELF_32/nvidia
 		[ -d /usr/$master$ELF_64/nvidia ]&& rm -Rf /usr/$master$ELF_64/nvidia
		rm -f /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so
		rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*
		rm -Rf /usr/src/nvidia-$(version)
		if [ -d /usr/src/open-nvidia-$(version) ]; then
			rm -Rf /usr/src/open-nvidia-$(version)
		fi
		rm -f $install_dir/bin/nvidia-*
		if [[ $(ls -1 /usr/local/$master$ELF_32/libnvidia-*| grep -c $(version)) -gt 0 ]]; then
			rm -f $install_dir/$master$ELF_32/libnvidia-*
			rm -f $install_dir/$master$ELF_64/libnvidia-*
		else
			rm -f $install_dir/$master$ELF_64/libnvidia-*
 		fi
 		rm -Rf $install_dir/share/nvidia
 		rm -f /usr/share/nvidia
		rm -Rf /var/lib/dkms/nvidia
		[ -d /var/lib/dkms/open-nvidia ] && rm -Rf /var/lib/dkms/open-nvidia
		rm -Rf /var/lib/nvidia*
		rm -f $nvdir/version.txt

		echo "# Libraries registry update."; sleep 2
		## retore library path to default.
		ldconfig
		echo "# Grub update."; sleep 2
		test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='rhgb quiet'
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$grub_orig\"/" $grub_def
		$d_grub-mkconfig -o $grub_cfg
		echo "# Perform modules dependencies and initramfs update."; sleep 2
		## restore kernel sys link to default.
		progress_msg(){ echo -e "# Depmod $KERNEL modules ($m sec.)"; }; m=0; do_slp=1
		progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c
		#exec_depmod
		#depmod -a
		progress_msg(){ echo "# Exec $KERNEL modules init/reload ($m sec.)"; }; m=0; do_slp=1
		exec_initramfs
		} | $d_zen $win_icon --width=450 --title="$_zen_title" --progress --pulsate --auto-close
		w_text=$( cat <<-MSG
			${j}NVIDIA driver installation is now completaly removed${end}.

			Restart the computer for change to take effect.

		MSG
		)
		icone='xkill'
		w_label="Got it!"
		w_text="${vB}$w_text${end}"
		win_warning
		base_menu
}
backup_tools(){
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=180'
	else
		w_height='--height=280'
	fi
	hlp_tip=''
	w_text=$( cat <<-MSG

		${v}Select the driver tool to use.${end}
	MSG
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$( cat <<-INFO

			${v}<b>Make a backup</b> :
			- Back up the current isntalled driver installation.
			<b>Remove a backup</b> :
			- Remove archived installation driver packages.
			${end}
		INFO
		)
	fi
	menu_backup=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Backup manager${end}${end}$hlp_tip$w_text" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	false 1 "Make a backup" false 2 "Remove a backup")
	if [ $? = 1 ]; then menu_modif; fi
	case $menu_backup in
		"1") backup_pcks ;;
		"2") remove_baks ;;
		*) manage_pcks ;;
	esac
}
backup_pcks(){
	bak_version=$(version)
	if [ -f $nvbackup/nvidia.$bak_version.tar.gz ]; then
		$d_zen --width=250 --height=100 $win_icon --title="$_zen_title" --info \
		$icon_name=swiss_knife --no-wrap \
		--text="${j}$bak_version${end}${v} is already backed up.\nNo reason to do it again.${end}"
		if [ $? = 0 ]; then menu_modif; fi
	else
		w_text=$( cat <<-WRN
			You are going to backup ${j}$bak_version${end} driver installation
			Please, confirm.
		WRN
		)
		$d_zen --width=250 --height=100 $win_icon --title="$_zen_title" --question \
		--text="${v}$w_text${end}" \
		--ok-label="$CC" --cancel-label="$R"
	fi
	if [ $? = 0 ]; then
		( backup_old_version ) | $d_zen --width=450 $win_icon --title="$_zen_title" --progress  \
		--text="Backup : $bak_version backup archive creation" --auto-close
		manage_pcks
	else
		manage_pcks
	fi
}
restore_pcks(){
	alert_message(){
	# current version overwrite ALERT message
		warning_msg=$( cat <<-WRN
			${jB}Driver install overwrite${end}

			${v}The backup you are going to restore is the same as the one used by the system.

			To prevent data loss when restoring and others ugly deasagrements (like X server crash),
			Zenvidia wont replace the actual install by overwriting ${j}$res_version${end} over itself.

			If you really wish to overwrite, use the command line tool with desktop manager
			service disabled and closed the actual desktop session
			(<i>ex: systemctl disable lightdm.service</i>)${end}
		WRN
		)
		$d_zen --error --title="$_zen_title" $icon_name=xkill \
		--text="$warning_msg" --no-wrap --ok-label="Thanks for the advice!"
		base_menu
	}
	nv_build_options
	# list package in release directory
	from_install=0
	unset drive_list
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	nv_root_repo=$(ls -1 $nvbackup | grep "nvidia."| sed -n "s/.tar.gz//p")
	for drive in $nv_root_repo; do
		drive_list+=("false")
		drive_list+=("$drive")
	done
	w_text=$( cat <<-MSG
		${j}${bf}Restoration tool${end}${end}
		${v}Choose the driver you want to restore.${end}
	MSG
	)
	drive_packs=$($d_zen --width=400 --height=300 $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "$w_text" --column "set" --column "action" --separator=";" \
	"${drive_list[@]}" )
	if [ $? = 1 ]; then manage_pcks; fi
	# check that list not empty before proceed.
	if [[ $drive_packs ]]; then
		export present_version=$(mktemp --tmpdir zn_old.XXX)
		res_version=$(printf "$drive_packs"|sed -n "s/nvidia.\([0-9]*\)/\1/p")
		ver_res=$(printf "$res_version"| sed -n "s/\.//g;p")
		ver_mod=$(printf "$(version)"| sed -n "s/\.//g;p")
		echo "$(version)" > $present_version
# 		old_back_version=$(cat $present_version)
		if [ ! -d $nv_root/$drive_packs ]; then
			confirm_msg="${v}Restoring ${j}$res_version${end} will replace actual${end} ${j}$(version)${end}."
			val_title="$_zen_title"
			val_confirm="Yes, restore and replace."
			val_back="$PM"
			val_cancel="base_menu"
			val_exit="manage_pcks"
			win_confirm
			## $d_zen window open here.
			{ echo "# Restoring from nvidia.$res_version.tar.gz..."; sleep 2
			if [ "$res_version" != "$(version)" ]; then
				rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$(version)
				rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$(version)
				rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$(version)
			fi
			# p: preserve perm, h: preserve sym, f: file.
			progress_msg(){ echo "# ($m sec.) - Restoring from nvidia.$res_version.tar.gz"; echo "$m"; }
			m=1; do_slp=1;progress "tar -zxf $nvbackup/nvidia.$res_version.tar.gz -C /"; rm -f $tmp_c
			ldconfig
			progress_msg(){ echo "# ($m sec.) - Rebuild modules dependencies (depmod)"; echo "$m"; }
			m=1; do_slp=1 ; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
			## restore or rebuild drivers.
			$d_modinfo -F version nvidia -k $KERNEL | grep "$res_version" &>/dev/null
			if [ $? -eq 1 ]; then
				echo "# Rebuilding missing $res_version drivers for $KERNEL kernel.."
				sleep 2
				rt_options
				if [ -d /usr/src/nvidia-$res_version ]||[ -d /usr/src/open-nvidia-$res_version ]; then
# 					version(){ echo $res_version; }
					restore_msg=" (restored)"
					driver_logfile=$nvlog/$(version)-$KERNEL.log
					tmp_b=$(mktemp --tmpdir zn_vars.XXX)
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo "# FAILURE : DKMS compilation ERROR !!"; sleep 2
						echo "# FAILURE : See 'update modules menu' to force build."; sleep 2
						manage_pcks
					fi
				else
					echo "# FAILURE : No source directory found for $res_version"; sleep 2
					manage_pcks
				fi
				## exec_mod_load is useless here, a modprobe reload all doesn't catch change on kernel init.
				progress_msg="Rebuilding INITRAMFS (required)\t\t\t"
				msg_suffix=" sec."
				progress_msg(){ echo "# ($m sec.) - Rebuilding INITRAMFS"; echo "$m"; }; m=1; do_slp=1
				exec_initramfs
			else
				echo "# Clear : $res_version modules checked in $KERNEL kernel."
				sleep 2
				echo "# Restore $res_version modules system symlinks for $KERNEL kernel."
				# exec_mod_load seems to work here when archive modules are already build for active kernel.
				exec_mod_load
				## when it want, so fallback to initramfs.
# 				progress_msg(){ echo "# ($m sec.) - Rebuilding INITRAMFS"; echo "$m"; }; m=1; do_slp=1
# 				exec_initramfs
			fi
			## remove /opt/nvidia.prev_version for compatibility future restore purpose
# 			test -d $nv_root/nvidia.$(old_version) && rm -Rf $nv_root/nvidia.$(old_version)
			if [ -d $nv_root/nvidia.$(old_version) ]&&[ "$(old_version)" != "$res_version" ]; then
				rm -Rf $nv_root/nvidia.$(old_version)
			fi
			}| $d_zen --width=450 --title="$_zen_title" $win_icon --progress --pulsate --auto-close \
			--text="${v}Restore driver $res_version and missing modules.${end}"
		else
			# current version overwrite ALERT message
			alert_message
		fi
	else
		manage_pcks
	fi
	manage_pcks
}
## EDITION TOOLS ###
edit_script_conf(){
	## build list
	unset conf_list orig_conf cnf_list conf_base conf_chg
	IFS=$(echo -en "\n\b")
	conf_list=( $(cat $basic_conf | sed -En "s/^# (.*):.*/\1/p") )
	for conf_set in "${conf_list[@]}"; do
		cnf_text="$conf_set"
		setted=$(grep -A1 "$cnf_text" $basic_conf | sed -n "2p")
		set_id=$(echo "$setted"|sed -En "s/(.*)=(.*)/\1/p")
		set_val=$(echo "$setted"|sed -En "s/(.*)=(.*)/\2/p")
		if [ $set_val -gt 0 ]; then setted='TRUE'; else setted='FALSE'; fi
		if [ $set_val -gt 1 ]; then extra_val=$set_val; else extra_val=''; fi
		cnf_list+=("$setted")
		cnf_list+=("$cnf_text")
		cnf_list+=("($set_id)")
		cnf_list+=("$set_val")
		cnf_list+=("$extra_val")
		cnf_list+=("#")
		orig_conf+=("($set_id);$set_val;$extra_val")
	done
	help_tip="${v}\nDefine options and functions you would like to use\n${end}"
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=500'
	else
		w_height='--height=600'
	fi
	conf_base=$($d_zen --width=550 $w_height $win_icon --list \
	--multiple --editable --checklist --title="$_zen_title" \
	--text "${j}${bf}Zenvidia Configuration${end}$help_tip${end}" \
	--column "Set" --column "Definition" --column "Conf Set" --column "4" --column "Extra" \
	--column "6" --hide-column=4,6 --print-column=3,4,5,6 \
	--separator=";" \
	"${cnf_list[@]}" )
	## output : use help tip;hlp_txt;0;cairo;1;28 etc
	if [ $? = 1 ]; then IFS=$ifs; base_menu; fi
	IFS=$ifs
	## split ouput in readable list
	## and remove blank lines.
	conf_orig=( $orig_conf )
	conf_chg=( $(echo -e "${conf_base[*]}"|sed -n "s/#/\n/g;p"|sed -n "s/^;\|;$//g;p"|\
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p") )
	## some previous set have to be saved before read and change.
	## check open_drv setiing before changing anything
	if [ $open_drv ]; then
		old_open_drv=$open_drv
		if [ $use_open ]; then old_use_open=$use_open; fi
	fi
	old_drm_modset=$drm_modset
	## modify new set value.
	for output in ${conf_chg[@]}; do
			set=$(echo "$output"| cut -d';' -f1| sed -n "s/(\|)//g;p")
			value=1
			bis_value=$(echo "$output"| cut -d';' -f3)
			if [[ "$bis_value" ]]&&[[ "$bis_value" != '' ]]; then value=$bis_value; fi
			if [ $(grep -E -c "$set=$value" $basic_conf) -eq 0 ];then
				sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
				if [[ $set == "use_open" ]]; then export use_open=$value; fi
			fi
			eval $set=$value
	done
	## modifiy unset value.
	for input in ${orig_conf[@]}; do
		if [ $(grep -c "$input" <<< ${conf_chg[@]}) -eq 0 ]; then
			set=$(echo "$input"| cut -d';' -f1| sed -n "s/(\|)//g;p")
			value=0
			bis_value=$(echo "$input"| cut -d';' -f3)
			if [[ "$bis_value" ]]&&[[ "$bis_value" != '' ]]; then value=$bis_value; fi
			if [[ $set != 'xt_delay' ]]; then
				if [ $(grep -E -c "$set=$value" $basic_conf) -eq 0 ];then
					sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
					if [[ $set == "use_open" ]]; then export use_open=$value; fi
				fi
			fi
			eval $set=$value
		fi
	done
	## if drm_modset is change nivdia modprobe options has to be change accordingly.
	if [ $drm_modset -ne $old_drm_modset ]; then
		echo "options nvidia_drm modeset=$drm_modset" > /etc/modprobe.d/nvidia-drm.conf
	fi
	## if open_drv is change, DKMS autoinstall boot time command has to be change by adding the blank file
	## 'no-autoinstall' in /etc/dkms directory. Method seems to work without issue except for package manager
	## udpate program that apprently need 'autoinstall all' to be set (fedora here).
	if [ $open_drv -ne $old_open_drv ]; then
		if [ $open_drv = 1 ]; then
			touch /etc/dkms/no-autoinstall
		else
			test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
		fi
	fi
	## if use_open is change, then apply open/close source switch.
	if [ $use_open -ne $old_use_open ]; then
		w_text=$( cat <<-WRN
			${jB}Driver Switch${end}
			${vB}Open driver settings have been change.

			Do you want to apply now ?${end}
		WRN
		)
		$d_zen --width=450 --title="$_zen_title" $win_icon --question --no-wrap \
		--text="$w_text" $icon_name=xkill --cancel-label="No, I'll apply later" --ok-label="Yes, apply"
		if [ $? = 0 ]; then
			nv_open_switch
		fi
	fi
	## then go back to Section Menu.
	menu_modif
}
edit_color_conf(){
	## color tmep file test preview
	color_TMP=$(mktemp --tmpdir nv_color.XXXX)
	cat $color_conf > $color_TMP
	edit_color_gui(){
		test_text=$(
		cat <<-SPL
			DISPLAY PREVIEW :
			${rBB}TITLE${end}
			${j}${bf}Sub TTILE${end}${end}
			TEXT, main and alternate text :
			${v}Once upon a time in south west ? I don't care !${end}.
			${y}But I can alternate between Est and West,
			but I still don't care ...${end}.
			LOGS :
			${vB}Command cleared${end}\t\t${gB}passed${end}\t> ${y}log message values.${end}
			${vB}Command issue warning${end}\t${jB}warning${end}\t> ${y}log message values.${end}
			${vB}Command non fatal error${end} ${rB}error${end}\t\t> ${y}log message values.${end}
		SPL
		)
		w_text=$(
		cat <<-TXT
			${j}${bf}Basic font colors and style${end}${end}
			${v}Change GUI font colors to fit your desktop theme.${end}
		TXT
		)
		sample=$(
		cat <<-SPL
			${rBB}TITLE${end}\t${j}${bf}Sub TTILE${end}${end}
			${v}main text${end} ${y}Log messages${end}
			${gB}Log cleared${end} ${jB}Log warnings${end} ${rB}Log Errors${end}
		SPL
		)
		w_tip=$(
		cat <<-TIP
			${j}NOTICE${end}${v}: Colors will appled immediatly after validation.
			Do not forget Xterm only support a limited type of colors.${end}
		TIP
		)
		style1=$(grep -E -io "[a-z]*$" <<< $font1)
		style0=$(grep -E -io "[a-z]*$" <<< $font0)
		font_color=$(
		$d_yad --width=300 --height=300 --title "Zenvidia" --center \
			--window-icon=$img_zen_desktop --text "$w_text" \
			--button='Abort:1' --button='Preview;;Reload with newly setted values:2' --button='Done:0' \
			--form --separator="|" --item-separator=";" --borders=15 --field="":LBL '' \
			--field="${v} Title and warning messages font color${end}":CLR "$title" \
			--field="${v} Sub window title font color${end}":CLR "$sub" \
			--field="${v} Main window font color\t\t${end}":CLR "$main" \
			--field="${v} Log message font color\t\t${end}":CLR "$log_msg" \
			--field="${v} Log clear font color\t\t${end}":CLR "$log_grn" \
			--field="${v} Log warning font color\t\t${end}":CLR "$log_warn" \
			--field="${v} Log error font color\t\t${end}":CLR "$log_err" \
			--field="${v} Sub Titles font type${end}":FN "$font1 $style1 $size1" \
			--field="${v} Normal font type${end}":FN "$font0 $style0 $size0" \
			--field="":LBL '' \
			--field="${v} Xterm forground color${end}":CLR "$fg_xterm" \
			--field="${v} Xterm background color${end}":CLR "$bg_xterm" \
			--field="":LBL '' \
			--field="$test_text":LBL '' \
			--field="":LBL '' \
			--field="$w_tip":LBL ''
		)
		out=$?
		if [ $out = 0 ]; then
			menu=menu_modif
		elif [ $out = 1 ]; then
			base_menu
		elif [ $out = 2 ]; then
			menu="$@ edit_color_gui"
		fi
		if [ $out -eq 2 ]; then
			color_base=$color_conf
			color_conf=$color_TMP
		else
			if [ $color_base ]; then
				color_conf=$color_base
			fi
		fi
		IFS=$(echo -en "\n\b")
		unset input_colors output_colors output_conf
		input_colors=$(cat $color_conf | cut -d'=' -f1)
		output_colors=( $(echo -e "$font_color"| sed -En "s/^\||[\|]{3}$//g;s/\|/\n/g;p") )
		C=0
		for type in ${input_colors[@]}; do
			if [[ $type =~ font* ]]; then
				font_n=$(echo "$type"| grep -o "[0-9]")
				eval style=\$'style'$font_n
				new_font=$(echo "${output_colors[$C]}"|grep -E -io ".*[a-z]")
				new_style=$(echo "$new_font"|awk '{print $3}')
				if [[ $new_style == '' ]]; then stylish=' '$style; else stylish=''; fi
				output_conf+=("$type;$new_font$stylish")
				shift 0
			elif [[ $type =~ size* ]]; then
				output_conf+=("$type;$(echo "${output_colors[$C]}"|grep -E -o "[0-9].*$")")
				((C++))
			else
				output_conf+=("$type;${output_colors[$C]}")
				((C++))
			fi
		done
		for sets in ${output_conf[@]}; do
			setting=$(printf "$sets"| cut -d';' -f1)
			value=$(printf "$sets"| cut -d';' -f2)
			if [ $(grep -c "$setting='$value'" $color_conf) -eq 0 ]; then
				sed -Ei "s/^($setting)=.*$/\1='$value'/g" $color_conf
			fi
		done
		IFS=$ifs
		if [ $out -eq 2 ]; then
			. $color_conf
			zen_colors
		fi
		${menu}
	}
	if [ $d_yad ]; then
		edit_color_gui
	fi
}
edit_xorg_conf(){
	xorg_cfg=/etc/X11/xorg.conf.nvidia
	hlp_tip=$(
	cat <<-HLP
	${v}Edit or manage Xorg config and options.${end}

	HLP
	)
	menu_xorg=$($d_zen --width=400 --height=300 $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Edit Xorg Config File${end}${end}\n$hlp_tip" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	TRUE 1 "Edit full Xorg config file" FALSE 2 "Manage Device Options only" FALSE 3 "Execute Xorg auto config")
	if [ $? = 1 ]; then
		if [ $from_install = 0 ]; then menu_modif; fi
	fi
	case $menu_xorg in
		"1") edit_xorg_full_text ;;
		"2") edit_xorg_options ;;
		"3") xorg_conf; edit_xorg_conf ;;
	esac
}
edit_xorg_options(){
	unset options options_list options_orig options_new options_old
	IFS=$(echo -en "\n\b")
	options=$(sed -En '/Section "Screen"/,/EndSection/p' $xorg_cfg| grep "Option")
	for e in $pci_dev_nb; do
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			options=$(sed -En "/Identifier.*\"Device${dev_n[$e]}\"/,/EndSection/p" $xorg_cfg| grep "Option")
		fi
	done
	for line in ${options[@]}; do
		if [[ $line =~ \#.*$ ]]; then setted='FALSE'; else setted='TRUE'; fi
		option=$(printf "$line"| sed -En "s/^.*Option\t(\".*\") (\".*\")$/\1/p"|sed -n "s/\"//g;p")
		if [ ! $option ]; then
			option=$(printf "$line"| sed -En "s/^.*Option\t(\".*\")$/\1/p"|sed -n "s/\"//g;p")
		fi
		value=$(printf "$line"| sed -En "s/^.*Option\t(\".*\") (\".*\")$/\2/p"|sed -n "s/\"//g;p")
		options_list+=("$setted")
		options_list+=("$option")
		options_list+=("$value")
		options_list+=("#")
		options_orig+=("$option;$value")
	done
	hlp_tip=$(
	cat <<-HLP
	${v}Select/unselect options you need.

	Options added manually will be displayed here also.${end}

	HLP
	)
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=500'
	else
		w_height='--height=600'
	fi
	options_conf=$($d_zen --width=550 $w_height $win_icon --list \
	--multiple --editable --checklist --title="$_zen_title" \
	--text "${j}${bf}Zenvidia Configuration${end}${end}\n${v}$hlp_tip${end}" \
	--column "Set" --column "Option" --column "Set" \
	--column "4" --hide-column=4 \
	--print-column=2,3,4 \
	--separator=";" \
	"${options_list[@]}" )
	if [ $? = 1 ]; then IFS=$ifs; edit_xorg_conf; fi
	options_old=( $(echo -e "${options_orig[*]}") )
	options_new=( $(echo -e "${options_conf[*]}"|sed -n "s/#/\n/g;p"|sed -n "s/^;\|;$//g;p"|\
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p") )

	## modify new set value.
	for output in ${options_new[@]}; do
			output_set=$(echo "$output"| cut -d';' -f1)
			value=$(echo "$output"| cut -d';' -f2)
			if [[ "$value" ]]; then reg_val=' (\".*\")' ; opt_val=" \"$value\""; else reg_val=''; opt_val=''; fi
			if [ $(grep -c "^#.*$output_set" <<< $options ) -gt 0 ]|| \
			[ $(grep -c "$output_set.*$value" <<< $options) -eq 0 ]; then
				sed -Ei "s/^[#]?(.*Option\t\"$output_set\")$reg_val/\1$opt_val/" $xorg_cfg
			fi
	done
	## modifiy unset value.
	for input in ${options_orig[@]}; do
		input_set=$(echo "$input"| cut -d';' -f1)
		value=$(echo "$input"| cut -d';' -f2)
		if [ $(grep -c "$input_set" <<< $options_conf) -eq 0 ]; then
			if [ $(grep -E -c "#.*Option.*\"$input_set\"" $xorg_cfg) -eq 0 ];then
				if [[ "$value" ]]; then reg_val=' (\".*\")' ; opt_val=" \"$value\""; else reg_val=''; opt_val=''; fi
				sed -Ei "s/^(.*Option\t\"$input_set\")$reg_val/#\1$opt_val/" $xorg_cfg
			fi
		fi
	done
	IFS=$ifs
	edit_xorg_conf
}
edit_xorg_full_text(){
	edit_xorg=$($d_zen --width=500 --height=400 $win_icon --title="$_zen_title" --text-info --editable \
	--text="${v}Edit xorg config file${end}" --filename="$xorg_cfg" \
	--checkbox="Confirm to overwrite" )
	if [[ $(printf "$edit_xorg"| sed -n '1p') != '' ]]; then
		printf "$edit_xorg\n" > $xorg_cfg
	fi
	if [ $? = 0 ]; then edit_xorg_conf; fi
}
edit_distro_conf(){
	## warn about no config file
	w_text=$(cat <<-WRN
	${j}<b>You are going to modify $plug_version configuration file</b>${end}

	Variables and datas from this file are very sensitives and could potentialy
	breaks Zenvidia.

	Are you sure about what you are doing ?
	WRN
	)
	$d_zen --width=450 $win_icon --title="$_zen_title" --question --no-wrap \
	--text="${vB}$w_text${end}" --ok-label="I live dangerously" --cancel-label="Well, I'm finally a coward"
	if [ $? = 1 ]; then menu_modif; fi
	## edit config file.
	edit_plug_conf=$( $d_zen --width=640 --height=400 $win_icon --title="$_zen_title" \
	--text-info --editable --filename="$(user_CF_DIR)/$plug_conf" \
	--checkbox="Confirm to overwrite" --cancel-label="Abort (panic button)" --ok-label="Write")
	if [ $? = 0 ]; then
		echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf
	else
		menu_modif
	fi
}
read_help(){
	$d_yad --width=680 --height=400 --title="Zenvidia" --window-icon=$img_zen_desktop --button="yad-close" \
	--center --text-info --formatted < $zen_docs/HELP.txt
	menu_manage
}
read_about(){
	$d_yad --width=680 --height=400 --title="Zenvidia" --window-icon=$img_zen_desktop --button="yad-close" \
	--center --text-info --formatted < $zen_docs/README.txt
	menu_manage
}
read_nv_help(){
	IFS=$(echo -en "\n\b")
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=500'
	else
		w_height='--height=600'
	fi
	if [[ ${#chapter_index[@]} -le 1 ]]; then
		unset chapter_index chapters_list
		chapters_list=$(sed -En "/TABLE OF.*$/,/1A. ABOUT.*$/p" $nvi_docs/README.txt | sed -n "/^___.*$/,/^___.*$/p"| grep -E "^Chapter|^Appendix")
		for chapter in ${chapters_list[@]}; do
			chapter_index+=("FALSE")
			chapter_index+=("$chapter")
		done
	fi
	## display index first
	index=$( $d_zen --width=550 $w_height $win_icon --list \
	--radiolist --title="$_zen_title" \
	--text "${j}${bf}Nvidia Documentation ${end}$help_tip${end}" \
	--column=" " --column "Chapters" \
	"${chapter_index[@]}" )
	if [ $? -eq 1 ]; then base_menu; fi
	if [ "$index" != '' ]; then
		chap_start=$(printf "$index"| sed -n "s/(.*)//g;p")
		## then if chapter tag is not empty, dispaly chapter.
		chap_end=$(grep -E -A1 "$chap_start" <<< $chapters_list | sed -n 2p | sed -n "s/(.*)//g;p")
		chap_brief="$chap_start : "$(sed -En "/^$chap_start/,/^$chap_end/p" $nvi_docs/README.txt | sed -En "/^____/,/^____/p")
		$d_zen --width=600 $w_height --title="$_zen_title" --text-info \
		--ok-label="Back to index" --cancel-label="Exit to main" \
		cat <<< "$chap_brief"
		if [ $? -eq 1 ]; then menu_manage; else IFS=$ifs; read_nv_help; fi
		IFS=$ifs
 	else
		IFS=$ifs; menu_manage
 	fi
}
read_changelog(){
	unset entry_list entrylog_list
	IFS=$(echo -en "\n\b")
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=400'
	else
		w_height='--height=500'
	fi
	relist_title=''; catch_title=''; txt_val=0
	brief(){
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$( cat <<-BRIEF
			Nvidia changelog ( $entrylog ) :
			$log_brief
			BRIEF
			)
		else
# 		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
# 			log_brief=$( cat <<-BRIEF
# 			Nvidia changelog ( $entrylog ) :
# 			$(cat $zen_docs/NVIDIA_Changelog | \
# 			sed -En "/$entrylog/,/$log_end/p"| \
# 			sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
# 			BRIEF
# 			)
# 		else
			log_brief=$(echo -e "Nvidia changelog ( $entrylog ) :\n\nNothing to display here.\n\nLog file empty.")
		fi
			$d_zen --width=600 $w_height --title="$_zen_title" $win_icon --text-info \
			--ok-label="Back to list" --cancel-label="Exit to menu" \
			cat <<< "$log_brief"
			if [ $? -eq 1 ]; then
				IFS=$ifs; menu_manage
			else
				if [[ $relist_title != '' ]]; then
					relist
				else
					relist_title=''
					IFS=$ifs ; read_changelog
				fi
			fi
	}
	relist(){
		if [[ $relist_title != '' ]]; then
			cancel_btn='--cancel-label=Back to list'
		else
			cancel_btn='--cancel-label=Back to menu'
		fi
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			for log_line in ${entry_list[@]}; do
				entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
			done
		fi
		entrylog=$( $d_zen --width=550 $w_height $win_icon --list \
		--radiolist --title="$_zen_title" \
		--text "${j}${bf}Nvidia Change Logs list $relist_title${end}${end}" $cancel_btn \
		--column=" " --column "Versions" \
		"${entrylog_list[@]}" )
		if [ $? -eq 1 ]; then
			if [[ $relist_title != '' ]]; then
				IFS=$ifs; read_changelog
			else
				IFS=$ifs; menu_manage
			fi
		else
			if [[ $entrylog != '' ]]; then
				if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
					log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
					log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
					sed -n "s/^===.*$//g;p")
				else
					log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
					[ "$log_end" != "" ] || log_end="====.*$"
					log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
					sed -n "s/^===.*$//g;p")
				fi

				if [[ $relist_title != '' ]]; then
					if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
						log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
						sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
					else
						log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
						sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
					fi
					brief
				else
					log_brief=$(cat <<< $log_list | sed -En "s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}" )
				fi
			else
				IFS=$ifs; menu_manage
			fi
		fi
	}
	entry_list=$(grep -E -e "=====" $zen_docs/NVIDIA_Changelog | sed -En "s/[ ]?={8}[ ]?//g;p")
	relist
	if [[ $log_list =~ .*[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
		unset entry_list entrylog_list entry_catch
		if [ $(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$") -gt 0 ]; then
			txt_key="$(cat <<< $log_brief | sed -n '1p' | grep "\* [A-Z].*$"|sed -n "s/\* //g;p")"
			txt_val=$(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$")
			entry_list+=("First $entrylog Log")
		fi
		entry_catch=$(cat <<< $log_list | grep -E ".*[0-9]{4}-[0-9]{2}-[0-9]{2}"|sed -En "s/ ([0-9]{4})/\1/g;p")
		for catch in ${entry_catch[*]}; do
			entry_list+=("$catch")
		done
		relist_title=": ${y}$entrylog${end}"; catch_title=$entrylog
		relist
	else
		relist_title=''; catch_title=''
		brief
	fi
	IFS=$ifs
}
read_zen_changelog(){
	unset entry_list entrylog_list
	if [[ "$notif_desk_opt" =~ 'z' ]]; then log_from_local=1; else log_from_local=0; fi
	if [ $log_from_local = 1 ]; then
		log_pages=$(user_CF_DIR)/src/zen_git.log # from user dir
	else
		log_pages=$zen_docs/Changelog.txt # from install dir
	fi
	IFS=$(echo -en "\n\b")
	w_height='--height=260'
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=300'
	else
		w_height='--height=400'
	fi
	brief(){
		log_version=$(echo "$entrylog"| grep -E -o "v[0-9].[0-9](.[0-9]{1,2})?")
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$( cat <<-BRIEF
			Zenvidia changelog : ( $log_version )

			$log_brief
			BRIEF
			)
		else
			log_brief=$(echo -e "Zenvidia changelog ( $log_verion ) :\n\nNothing to display here.\nLog file empty.")
		fi
			zenity --width=600 $w_height --title="$_zen_title" --text-info \
			--ok-label="Back to list" --cancel-label="Exit to main" \
			cat <<< "$log_brief"
			if [ $? -eq 1 ]; then
				IFS=$ifs; base_menu
			else
				IFS=$ifs; read_zen_changelog
			fi
	}
	relist(){
		cancel_btn='--cancel-label=Back to main'
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			for log_line in ${entry_list[@]}; do
				entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
			done
		fi
		entrylog=$( zenity --width=550 $w_height --list \
		--radiolist --title="$_zen_title" \
		--text "${j}${bf}Zenvidia Change Logs list ${end}${end}" $cancel_btn \
		--column=" " --column "Versions" \
		"${entrylog_list[@]}" )
		if [ $? -eq 1 ]; then
			IFS=$ifs; base_menu
		else
			if [[ $entrylog != '' ]]; then
				if [ $log_from_local = 1 ]; then
					entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
				else
					entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
				fi
				log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
				if [ "$log_end" != '' ]; then
					if [ $log_from_local = 1 ]; then
						log_end=$(echo -e "$log_end"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
					else
						log_end=$(echo -e "$log_end"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
					fi
				else
					log_end='^     $'
				fi
				log_list=$(cat $log_pages | sed -En "/$entrylog/,/$log_end/p"	)
				if [ $log_from_local = 1 ]; then
					log_brief=$(grep -E "^.*-" <<< $log_list) # from user dir
				else
					log_brief=$(grep -E "^[ ]{,3}-" <<< $log_list) # from install dir
				fi
			else
				IFS=$ifs; base_menu
			fi
		fi
	}
	if [ $log_from_local = 1 ]; then
		entry_list=$(grep -E -e "^*[Aa-Zz]{3} [0-9]{1,2} [0-9]{4} :" $log_pages) # from user dir
	else
		entry_list=$(grep -E -e "^* [0-9]{4}-[0-9]{1,2}-[0-9]{2} -" $log_pages | sed -n "s/^* //p") # from install dir
	fi
	relist
	brief
	IFS=$ifs
}
nv_config(){
	[ -x $d_nv_settings ] && \
	gpu_set=$($d_nv_settings -q gpus | grep -i "nvidia" | sed -En "s/^.*\[gpu:([0-9])\].*(\(.*\)).*$/GPU \1 - \2/g;p")
	$su_cmd "$(def_user)" $d_nv_settings -p "$gpu_set"
	menu_modif
}
zen_notif_setup(){ # optionnaly TODO use notif_desk_opt vars instead.
	setup_validation(){
		notif=$($d_zen --height=100 $win_icon --title="$_zen_title" --question --no-wrap \
		--text="${vB}Autostart launcher will be set to :\n<b>></b>${end} ${j}$_notif${end}" \
		--ok-label="Ok" --cancel-label="$PM")
		if [ $? = 1 ]; then menu_modif; fi
		sed -Ei "s/(Exec=zen_notify) -[a-z]/\1 $_set/" $notif_desk_file
		menu_modif
	}
	#notif_desk_file=/home/$(def_user)/.config/autostart/zen_notify.desktop
	unset setup_list setup_option c_set_list
	setup_option=(
	"Check driver update only;driver check only;n"
	"Check zenvidia and driver update;driver and zenvidia check;z"
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$( cat <<-HLP

		${v}<i>You can leave it as it is or choose between
		one of the sets below</i>.${end}
		HLP
		)
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=350'
		else
			w_height='--height=450'
		fi
	else
		hlp_tip=''
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=300'
		else
			w_height='--height=400'
		fi
	fi
	st=1
	c_set_opt=$(cat $notif_desk_file |grep "Exec"| perl -p -e "s|^.*-+([a-z])|\1|")
	for n_set in "${setup_option[@]}"; do
		m_set=$(printf "$n_set"|cut -d';' -f1)
		c_set=$(printf "$n_set"|cut -d';' -f2)
		o_set=$(printf "$n_set"|cut -d';' -f3)
		setup_list+=("false")
		setup_list+=("$st")
		setup_list+=("$m_set")
		if [[ $o_set == $c_set_opt ]]; then c_set_cnf=$c_set; fi
		((st++))
	done
	w_text=$(cat <<-MSG
		${j}${bf}Notifications config${end}${end}

		${vB}Notification is currently set to:
		> ${j}$c_set_cnf${end}${end}
	MSG
	)
	menu_notif=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--column "set" --column "2" --column "action" --hide-column=2 \
	"${setup_list[@]}")
	if [ $? = 1 ]; then menu_modif; fi
	case $menu_notif in
		"1") _set='-n'; _notif="driver check only" ;;
		"2") _set='-z'; _notif="driver and zenvidia check" ;;
		*) menu_modif ;;
	esac
	setup_validation
}
### SUB MENU ###
menu_install(){
	unset install_list ins_cmd ins_list
	if [ $hlp_txt = 1 ]; then
		hlp_tip="\n$hlp_01b"
		hlp_tip=$( cat <<-HLP

		${vB}Select the install type${end}
		   - ${vB}From a local package${end}:
		   Install a new driver from a user directory local package
		   or a listed already downloaded with zenvidia.
		   - ${vB}From Nvidia server${end}:
		   Will display the full drivers list from the Nvidia server.
		   Install and download will be executed in the next step.
		HLP
		)
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=300'
		else
			w_height='--height=400'
		fi
	else
		hlp_tip="\n${vB}Select here the install type${end}"
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=200'
		else
			w_height='--height=300'
		fi
	fi
	install_list=("From a local package" "From NVIDIA server")
	n=1
	for ins_cmd in "${install_list[@]}"; do
		ins_list+=("false")
		ins_list+=("$n")
		ins_list+=("$ins_cmd")
		n=$[ $n+1 ]
	done 
	menu_inst=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Install new drivers${end}\n${end}${v}$hlp_tip${end}" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	"${ins_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	ui_mod=1
	case $menu_inst in
		"1") menu_msg="${vB}NVIDIA package update from local dir. ${end}"; from_directory ;;
# 		"2") menu_msg="${vB}NVIDIA package from NVIDIA server.${end}"; check_update ;;
		"2") menu_msg="${vB}NVIDIA package from NVIDIA server.${end}"; net_version_selector ;;
		*) base_menu ;;
	esac
}
menu_update(){
	check_version
	if [ $hlp_txt = 1 ]; then
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=450'
		else
			w_height='--height=550'
		fi
		hlp_tip=$(cat <<-HLP

		<b>Select here the element to update or install</b>
		- <b>Driver upgrade</b>
		   Check for new driver update.
		   You can select during the process to download only or install directly.
		   If <i>download only</i> is chosen, for installation afterward
		   go back to : » ${j}main${end} menu » ${j}Install Drivers${end}
		   <u>Note</u> : All download are stored.
		- <b>Update driver only (dkms)</b>
		   Install nvidia dkms modules for a new running kernel.
		- <b>Update driver only (force)</b>
		   Optional command to force install from driver sources in case of
		   DKMS failure.
		- <b>Update driver for an other kernel (dkms)</b>
		   Optional command to update nvidia modules for an other kernel.
		HLP
		)
	else
		hlp_tip=''
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=300'
		else
			w_height='--height=400'
		fi
	fi
	nu=1
	if [ $hlp_txt = 0 ]; then hlp_tip="\n${vB}\Select here the element to update or install${end}"; fi
		if [ $use_dkms = 1 ]; then
			up_cmd_list=("Driver upgrade" "Update driver only (dkms)" "Update driver only (force)" "Update driver for an other kernel (dkms)")
		else
			up_cmd_list=("Driver upgrade" "Update driver only" "Update driver for an other kernel")
		fi
	unset up_list
	for up_cmd in "${up_cmd_list[@]}"; do
		up_list+=("false")
		up_list+=("$nu")
		up_list+=("$up_cmd")
		nu=$[ $nu+1 ]
	done 
	menu_upd=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Update Drivers or kernel modules${end}${end}${v}$hlp_tip${end}" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	"${up_list[@]}" )
	if [ $? = 1 ]; then base_menu; fi
	git_tmp=$(mktemp --tmpdir nv_git.XXXX)
	home=/home/$(def_user)
	if [ $use_dkms = 1 ]; then
		case $menu_upd in
			"1")	menu_msg="${v}Check driver updates list${end}"; legacy_drv=0; check_for_newer; check_update ;;
			"2")	menu_msg="${v}Build module for current kernel (dkms)${end}"
					upgrade_other=0; force='--force'
					upgrade_kernel; base_menu ;;
			"3")	menu_msg="${v}Build module for current kernel (force)${end}"
					upgrade_other=0; use_dkms=0;
					upgrade_kernel; base_menu ;;
			"4")	menu_msg="${v}Build module for the selected kernel (dkms)${end}"
					upgrade_other=1;
					upgrade_new_kernel; base_menu ;;
			*) base_menu ;;
		esac
	fi
}
menu_modif(){
	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(cat <<-HLP

		<b>Select here the element to modify or edit</b>:
		- <b>Edit Xorg config file</b>:
			Edit the current xorg configuration file in /etc/X11.
		- <b>Edit script config</b>:
			Edit Zenvidia basic user conf script to set or unset mostly everything.
		- <b>Edit GUI $d_zen font colors</b>:
			Change default Zenity font colors.
			<u>Note</u> : graphic UI is available with Yad installed.
		- <b>Nvidia settings</b>:
			Start Nvidia-setting graphic UI tool.
		- <b>Edit distro config</b>:
			Modify the distribution configation file.
			<u>Warning</u> : This very sensitive, bad config file breaks Zenvidia.
		- <b>Manage drivers packages</b>:
			This tool is to backup, restore and remove old or current driver install.
			It also manage dowloaded nvidia's .run pack.
			<u>Note</u> : if old installation is found during driver update,
			it is automatically backup prior to new version installation.
		- <b>Notication settings</b>:
			Configuration tool for Zen_notify daily update checker.
		- <b>Open driver switch tool</b> (optional):
			When available, this tool allow to switch between
			open and proprietary source drivers.
		HLP
		)
		w_height='--height=660'
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=660'
		else
			w_height='--height=700'
		fi
	else
		hlp_tip="\n${vB}Select here the element to modify or edit${end}"
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=330'
		else
			w_height='--height=400'
		fi
	fi
	nd=1
	mod_menu_list=("Edit xorg config file" "Edit Zenvidia config" "Edit GUI Colors" "Nvidia-settings" "Edit Distro config" "Manage drivers packages"  "Zenvidia notification config")
	unset mod_list
	if [ $open_drv -gt 0 ]; then
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("Open driver switch tool")
		nd=$[ $nd+1 ]
	fi
	for mod_cmd in "${mod_menu_list[@]}" ; do
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("$mod_cmd")
		nd=$[ $nd+1 ]
	done
	menu_mod=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Configuration and Tools${end}${end}${v}$hlp_tip${end}" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	"${mod_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	if [ $open_drv -gt 0 ]; then
		case $menu_mod in
			"1") if [ $UID = 0 ]; then win_open_switch; else  is_SU; menu_modif; fi;;
			"2") from_install=0; if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; menu_modif; fi;;
			"3") edit_script_conf ;;
			"4") edit_color_conf ;;
			"5") nv_config ;;
			"6") if [ $UID = 0 ]; then edit_distro_conf; else is_SU; menu_modif; fi;;
			"7") if [ $UID = 0 ]; then manage_pcks; else is_SU; menu_modif; fi;;
			"8") zen_notif_setup ;;
			*) base_menu ;;
		esac
	else
		case $menu_mod in
			"1") from_install=0; if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; menu_modif; fi;;
			"2") edit_script_conf ;;
			"3") edit_color_conf ;;
			"4") nv_config ;;
			"5") if [ $UID = 0 ]; then edit_distro_conf; else is_SU; menu_modif; fi;;
			"6") if [ $UID = 0 ]; then manage_pcks; else is_SU; menu_modif; fi;;
			"7") zen_notif_setup ;;
			*) base_menu ;;
		esac
	fi
}
menu_manage(){
# 	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(
		cat <<-TIP

			${v}README and Help file from Nvidia $(version) and other.${end}

			- ${vB}Documanetation${end}:\tRead the current Nvidia help file.
			- ${vB}Change Logs${end}:\tRead the current Nvidia changelog file.
			- ${vB}Zenvidia Logs${end}:\tRead the Zenvidia changelog file.
			- ${vB}Zenvidia Help${end}:\tRead Zenvidia doc file.
			- ${vB}About Zenvidia${end}:\tRead current Zenvidia README file.
		TIP
		)
		w_height='--height=300'
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=450'
		else
			w_height='--height=550'
		fi
	else
		hlp_tip="\n${v}README and Help file from Nvidia $(version) and other.${end}"
		w_height='--height=300'
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=300'
		else
			w_height='--height=400'
		fi
	fi
	nm=1
	unset mng_list
	for mng_cmd in "Documention manual ($(version))" "Change Logs ($(version))" "Zenvidia Logs" "Zenvidia Help" "About Zenvidia (README)"; do
		mng_list+=("false")
		mng_list+=("$nm")
		mng_list+=("$mng_cmd")
		nm=$[ $nm+1 ]
	done
	menu_mng=$($d_zen --width=400 $w_height $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Help and Documentation${end}${end}${v}$hlp_tip${end}" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	"${mng_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	case $menu_mng in
		"1") unset chapter_index chapters_list; read_nv_help ;;
		"2") read_changelog ;;
		"3") read_zen_changelog ;;
		"4") read_help ;;
		"5") read_about ;;
		*) base_menu ;;
	esac
}
### RESCUE COMMAND LINE ###
dm_serv_restore(){
	if [ $no_mod=0 ]; then
		if [ "$dkms_ins" == "$cmd_ver" ]; then
			for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
				if [ $(grep -owc "$drv" /etc/modprobe.d/nvidia-blacklist.conf) -eq 0 ]; then
				drv_list+=("$drv")
				fi
			done
			test $echec = 0 && ( echo -e "${nc}# ${yel}DM and $dkms_ins drivers re-init :${nc}" )
			echo -e "${nc}# ${yel}Unload $dkms_ins drivers if any${nc}."; sleep 2
			modprobe -r -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Load $cmd_ver drivers${nc}."; sleep 2
			command -v restorecon &>/dev/null || modprobe -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Exec $KERNEL modules reload."; sleep 2
			exec_mod_load
			echo -e "${nc}# ${yel}Exec $KERNEL modules init."; sleep 2
			progress_msg(){ echo -en "\r${nc}#${blu} ($m sec.) Exec $KERNEL modules initramfs."; }; m=1; do_slp=1
			exec_initramfs
			echo -e "\n${nc}# ${yel}Done.${nc}"
			echo -e "# ${yel}License is $license ${nc}."
			## catch console pid here
			if [ "$(dm_serv)" != "" ]; then
				test $($d_sys status $(dm_serv) | grep -c "disabled") -gt 0 && (
				echo -e "${nc}# ${yel}Restore $(dm_serv) service to 'enable'${nc}."; sleep 2; )
				$d_sys enable $(dm_serv).service
				echo -e "${nc}# ${yel}Start $(dm_serv) service${nc}."; sleep 2
				echo -e "${blu}(Press ENTER to start, CTRL-C to cancel)${nc}"; read
				$d_sys start $(dm_serv).service
			else
				echo -e "${nc}# ${yel}You can 'enable' and 'start' your Display Manager now.${nc}."
			fi
			## trying to kill console root's tty.
			if [ $(w | grep -c "root.*tty") -gt 0 ]; then
				sleep 40
				pkill -9 -t $(w | grep "root.*tty" | awk '{print $2}')
			fi
		else
			echo -e "${nc}# ${red} WARNING${yel}: $cmd_ver differ from installed driver ($dkms_ins); <rebuild> first.\nAbort.${nc}."
		fi
	else
		echo -e "${nc}# ${red} WARNING${yel}: No modules found for $KERNEL, install $cmd_ver first with <rebuild> option.\nAbort.${nc}."
	fi
}
restore_cmdline(){
	echec=0
	echo -e "# ${yel}Restoring $cmd_ver driver for $KERNEL${nc} :\n"
	sleep 2
	## clean old librairies
	if [ "$dkms_ins" != "" ]; then
		if [[ $cmd_ver != $dkms_ins ]]; then
			echo -e "# ${blu}Cleaning $dkms_ins old installation${nc} ..."
			sleep 2
			rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$dkms_ins
			rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$dkms_ins
			rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$dkms_ins
			test -d /var/lib/dkms/nvidia/$dkms_ins && $p_dkms remove nvidia/$dkms_ins --all
			test -d /var/lib/dkms/open-nvidia/$dkms_ins && $p_dkms remove open-nvidia/$dkms_ins --all
			rm -Rf /usr/src/nvidia-$dkms_ins
			test -d /usr/src/open-nvidia-$dkms_ins && rm -Rf /usr/src/open-nvidia-$dkms_ins
			sleep 2
		fi
	fi
	echo -e "# ${yel}Uncompressing $cmd_ver archive for $KERNEL${nc} :\n"
	tar -zvxf $nvbackup/nvidia.$cmd_ver.tar.gz -C /
	echo -e "\n# ${blu}- Registering $cmd_ver librairies (ldconfig)${nc} ..."
	ldconfig
	echo -e "# ${blu}- Depmod $cmd_ver modules ..."
	progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
	m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
	## check modules
	echo -e "\n${nc}# ${blu}- Testing $cmd_ver modules availbility${nc} ..."
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	test $vermagic && echo -e "# ${yel}Initramfs update${nc}." || \
	( echo -e "# ${red}Test failed${nc}."; echec=1; rebuild_cmdline )
	sleep 2
	if [ $echec = 0 ]; then
		echo -e "\n${nc}# ${yel}Done.${nc}"
		echo -e "# ${yel}License is $license ${nc}.\n"
		dm_serv_restore
	fi
}
rebuild_cmdline(){
	if [ $echec = 1 ]; then
		echo -e "# ${red}WARNING ${yel}: No $cmd_ver modules set in the backup${nc}.\n"; sleep 2
	fi
	clear
	echo -e "# ${yel}Build & Install $cmd_ver DKMS $KERNEL modules ($license) :${blu}"; sleep 2
	if [ $($p_dkms status -m $module/$cmd_ver -k $KERNEL| grep -cv "added") -gt 0 ]; then
		$p_dkms remove -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms add -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	else
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	fi
	## recheck modules
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [[ $vermagic ]]; then
		echo -e "\n${nc}# ${yel}Initramfs update aand other routines.${blu}"; sleep 2
		dm_serv_restore
	else
		echo -e "\n# ${red}Failed${nc}."
	fi
}
rescue_cmdline(){
	## modinfo will display error if modules is not found, just add comments.
	clear
	echo -e "# ${yel}Compling $module $cmd_ver sources${nc} :\n" ; sleep 2
	kernel_module_src=/usr/src/$module-$cmd_ver
	cd $kernel_module_src; make -j12
	## check again
	vermagic=$($d_modinfo -F vermagic $kernel_module_src/nvidia.*[ko\|ko.xz]| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [ $vermagic ]; then
		if [[ $vermagic == $KERNEL ]]; then
			cp -f *.ko $libmod/
			## compress modules.
			clear
			echo -e "# ${blu}- Compressing modules if needed${nc}."; sleep 2
			is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
			[ $is_RT = 0 ]|| xz -T12 $libmod/*.ko
			echo -e "# ${blu}- Depmod $cmd_ver modules ..."
			progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
			m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
			## rebuild initramfs in case of trouble booting.
			clear
			dm_serv_restore
		fi
	else
		echo -e "${nc}#${red} *** Something went wrong ! ***\n${nc}#${yel} Restoration script can't proceed, exit${nc}."
	fi
}
## root warning
is_SU(){
	w_text=$(cat <<-WRN
	${y}${bf}Your are not root${end}${end}
	This command can't be executed with ${j}<b>Zenvidia (user)</b>${end} unprivilegded desktop entry.
	See ${j}<b>Zenvidia</b>${end} <i>(admin)</i> desktop entry instead.
	WRN
	)
	icone='swiss_knife'
	w_label='Got it!'
	win_warning
}
### MAIN MENUS ###
base_menu(){
	devices(){
	e=0
	until [ $e -eq ${#dev_n[*]} ]; do
		printf "${vB}Card $((${dev_n[$e]}+1)) :${end}${ge} - - - - - - - - - ${end}${j}${dev[$e]} ($(printf "${vnd[$e]}"|awk '{print $1}'))${end}\n"
		((e++))
	done
	}
	open_check(){
	if [ $open_drv ]&&[ $open_drv = 1 ]; then
		if [ $use_open ]; then
			if [ $use_open = 1 ]; then open_used=" and in use"; else open_used=", but unused"; fi
		else
			open_used=", closed source used"
		fi
		echo -e "${vB}Open Source modules :${end}${ge}     ${end}${j}installed$open_used${end}"
		echo -e "${vB}Loaded module license :${end}${ge}  ${end}${j}$($d_modinfo -F license nvidia)\n${end}"
	fi
	}
	right_check(){
		if [ $UID = 0 ]; then
			echo "You have root priviledge"
		else
			echo "You are not root\n(download, install, restore unavailable)$scan_alert"
		fi
	}
	# remove deplist list in case of relaunching first because an update asking to
	unset deplist
	hlp_tip_txt=$( cat <<-HLP
		Help tips text is currently set. You can unset it at any
		moment in: ${j}Configuration and Tools${end} menu » ${j}Edit script config${end}.\n\n"
	HLP
	)
	if [ "$(version)" == "0" ]; then
		drv_installed='not installed'
	else
		drv_installed=$(version)
	fi
# 	[ $hlp_txt = 0 ]|| { hlp_wrn="$hlp_tip_txt"; w_height=$(($w_height+50)); }
	[ $hlp_txt = 0 ]|| { hlp_wrn="$hlp_tip_txt"; }
	window_text=$( cat <<-MSG
		                            ${rBB}ZENVIDIA${end}
		                         ${y}${nf}Close and Open Source
		                         Nvidia drivers manager${end}${end}
		${vB}\nSystem :${end}${ge}  - - - - - - - - ${end}${j}$DISTRO${end}
		${vB}Processor type :${end}${ge} - - ${end}${j}$ARCH${end}
		$(devices)

		${vB}Driver version installed :${end} ${j}$drv_installed${end}$restore_msg
		${vB}Kernel version :${end}${ge}  - - - - - - -  ${end}${j}$KERNEL${end}
		${vB}GCC version :${end}${ge}  - - - - - - - - -  ${end}${j}$GCC${end}
		${vB}NVIDIA binary version :${end}${ge}    ${end}${j}$NV_bin_ver${end}$restore_msg
		$(open_check)
		${v}Network connection :${end} ${j}$cnx_msg${end}
		${v}Rights :${end} ${j}$(right_check)${end}

		${v}$hlp_wrn$ansWN${end}
	MSG
	)
	menu_cmd=$($d_zen --title="$_zen_title" --height=600 --width=300 --list $win_icon \
	--radiolist --hide-header --column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	--text="$window_text" \
	false 1 "Install drivers" false 2 "Update drivers or modules" false 3 "Configuration and Tools" false 4 "Help and Documentation" )
	if [ $? = 1 ]; then exit 0; fi
	case $menu_cmd in
		"1") if_update=0; if [ $UID = 0 ]; then initramfs_warn; menu_install; else is_SU; base_menu; fi;;
		"2") if_update=1; if [ $UID = 0 ]; then initramfs_warn; menu_update; else is_SU; base_menu; fi;;
		"3") if_update=1; menu_modif ;;
		"4") if_update=1; menu_manage ;;
		*) exit 0 ;;
	esac
}
install_controls(){
	# check nvidia dir presence
	if [ -d $install_dir/zenvidia ] ; then
		dir_msg="${j} OK${end}"
	else		
		dir_msg="${j}ERROR\n${y}Zenvidia repository is missing${end}${end}"
		$d_zen --width=400 $win_icon --error --no-wrap --title="$_zen_title" \
		--text="$dir_msg"
	fi
	# check/change run packages permission
	nvdl_last=$(ls -1 $nvdl/|sed -n '$p')
	if [[ -s $nvdl/$nvdl_last ]] ; then
		for changes in $(ls -1 $nvdl ); do
			if [[ $(stat -c "%a" $nvdl/$changes) != 755 ]]; then
				chmod 755 $nvdl/$changes
			fi
		done
	fi
}
start_cmd(){
## this for function testing only in "$1"
# 	if [[ $cmd_opt != '' ]]; then
# 		$($cmd_opt)
# 	fi
	## check if X server is off before lauching cmd line tools.
# 	xprop -root &>/dev/null
# 	if [ $? -gt 0 ]; then
	if [ $x_alive -gt 0 ]; then
		help_text(){
			cat <<-HT
				Command line option : $(basename $0 ) [option] [driver version]
				Options :
				   restore	-> restore driver backup.
				   rebuild	-> rebuild driver.
				   rescue	-> force driver build from sources.
				   reinit	-> Rebuild initramfs and start DM.
			HT
			if [ $(ls -1 $nvbackup | grep -c .) -gt 0 ]; then
				echo -e "Driver version backups :"
				ls -1 $nvbackup | sed -En "s/^nvidia.([0-9]*.*).tar.gz/ - \1/p"
			fi
			file -E $libmod/nvidia.*[ko\|ko.xz] &>/dev/null
			if [ $? -eq 0 ]; then
				echo -e "Installed driver version : $dkms_ins"
				no_mod=0
			else
				echo -e "Found dkms driver version : $module » $dkms_ver"
				no_mod=1
			fi
			echo -e "Display Manager : $(dm_serv)"
		}
		libmod='/lib/modules/'$KERNEL'/'$(module_dest_location)
		echo -e "** ${red}X server not runing${nc} **"
		echo -e "${yel}"
		if [ -f /etc/modprobe.d/open-NVIDIA.conf ]; then
			module='open-nvidia'
			license='Dual MIT/GPL'
		else
			module='nvidia'
			license='NVIDIA'
		fi
		## check realtime kernel.
		is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
		if [ $is_RT = 1 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		fi
		## check dkms mods list.
		dkms_mod=$($p_dkms status -m $module | grep -v "added"| cut -d, -f1)
		dkms_ver=$(echo -e "$dkms_mod"| cut -d"/" -f2)
		dkms_ins=$($d_modinfo -F version $libmod/nvidia.*[ko\|ko.xz])
		echec=0
		if [[ $cmd_ver != '' ]]; then
			case $cmd_opt in
				restore) restore_cmdline ;;
				rebuild) rebuild_cmdline ;;
				rescue) rescue_cmdline ;;
				reinit) dm_serv_restore;;
				*) help_text ;;
			esac
		else
			 help_text
		fi
		echo -e "${nc}"
		exit 0
	else
		#dep_control
		test -x "$d_zen" || exit 0
		install_controls
		connection_control
		# define gcc options if defined.
		gcc_options
		base_menu
	fi
}
## BASICS CHECK ###
## set default or null value before conf files reading.
use_dkms=1
use_uvm=0
use_drm=1
use_open=0
open_drv=0
no_warn=0
open_wrn=1
first_open=1
from_install=0
no_opti_warn=0
opti_preset=0
ARCH=$HOSTTYPE

## ### SCRIPT INTRO ###

# check distro elf type
libclass
# check distro and load specific config.
distro
## check dependies executables
p_xterm=$(command -v xterm) || $PKG_INSTALLER $pkg_opts$pkg_cmd xterm
dep_exec_check

# cmdline tool doesn't need to read config, so skip the step if in console only.
if [[ $(def_user) != "root" ]]; then
	test -d $(user_CF_DIR) || mkdir -p $(user_CF_DIR)
	test -d $(user_CF_DIR)/compats/series || mkdir -p $(user_CF_DIR)/{compats/series,updates,release}
# check if default user has conf file to load, or create it from shipped.
	for conf in {basic,color}; do
		if [ -f $(user_CF_DIR)/$conf.conf ]; then
			eval ${conf}_conf=$(user_CF_DIR)/$conf.conf
		else
			cp -f $nvdir/$conf.conf $(user_CF_DIR)/
			chown $(def_user):$(def_user) $(user_CF_DIR)/$conf.conf
			eval ${conf}_conf=$(user_CF_DIR)/$conf.conf
		fi
	done
## define compats dirs.
nvcompat="$(user_CF_DIR)/compats"
upcompat="$(user_CF_DIR)/updates"
nvdl="$(user_CF_DIR)/release"
test -d $nvdl || mkdir -p $nvdl
## old version check and move.
if [ $(ls -1 $nvdir/release | grep -c .) -gt 0 ]; then
	mv -f $nvdir/release/* $(user_CF_DIR)/release/
fi
# drv_list_file=$(rem_drv_list)
## zen notify desktop entry option (define zenvidia changelog reading behaviour)
notif_desk_file=/home/$(def_user)/.config/autostart/zen_notify.desktop
notif_desk_opt=$(cat $notif_desk_file| sed -En "s/^Exec=.*-(.*)/\1/p")
# if [[ "$notif_desk_opt" =~ 'z' ]]; then log_from_local=1; else log_from_local=0; fi
## then read script conf.
. $basic_conf
. $color_conf
fi
# load $d_zen span font colors.
zen_colors
# pick all necessary env Definition
compil_vars
PCI_ID
## check/install dependies
dep_control
## zenity version above 3.92 is using gtk 4 gnome shell like theme.
## display is wierd and need to be adapted. Fall back to yad is probably the best to do.
zenity_ver=$($d_zen --version| sed -n "s/\.//g;p")
if [ $zenity_ver -le 3420 ]; then
	_zen_title='Zenvidia'
	win_icon='--window-icon='$img_zen_desktop
	icon_name='--icon-name'
else
	_zen_title=''
	win_icon=''
	icon_name='--icon'
fi
## configuration file check
if [ ! -s $script_conf ]; then $d_zen $win_icon --width=250 --error $icon_name=xkill --text="Script's config file missing."; exit 0; fi


## INITIALS checks

## pick cmd line options if any (X server off only).
cmd_opt=$1; cmd_ver=$2
## ### LET'S START ###
start_cmd
