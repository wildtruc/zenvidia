#! /bin/bash

#  Zenvidia
#  Sat Feb  6 16:58:20 2010
#  Copyright  2010-2016  PirateProd
#  <wildtruc@noneltd.net>
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with main.c;if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301,  USA

# set -E

### ZENVIDIA VARS
install_dir=/usr/local							# default tools & system install directory
nvdir=$install_dir/zenvidia					# default Zenvidia directory
conf_dir=$nvdir
script_conf=$nvdir/script.conf				# Zenvidia conf file
nv_root=/opt											# Nvidia main driver directory
nvtmp="$nvdir/temp"								# extract temp directory
buildtmp="$nvdir/build"							# build temp directory
nvlog="$nvdir/log"								# logs directory
nvdl="$nvdir/release"							# downlaod driver backups directory
nvbackup="$nvdir/backups"
nvcompat="$nvdir/compats"
### NVIDIA-INSTALLER VARS ###					# nvidia-installer option: install temp dir
nvi_docs="$install_dir/share/doc/NVIDIA_GLX-1.0"
zen_docs="$install_dir/share/doc/zenvidia"
docs="--documentation-prefix=$install_dir"
profile_path="$install_dir/share/nvidia"
profile="--application-profile-path=$profile_path"
icon_stock=$install_dir/share/pixmaps
img_zen_desktop=$icon_stock/swiss_knife.png
img_zen_bar=swiss_knife
# user_DL_DIR=$(su "$(who | awk '{print $1}')" xdg-user-dir DOWNLOAD)
xt_hold=0
xt_delay=4



E="Download"
PM="Back to previous menu"
MM="Back to main menu"
I="Quit"
CC="Confirm"
R="Back to main"
GO="Go on"
## Classic answer
ansOK="OK"
ansNF="NOT PRESENT"
ansNA="NONE"
ansCF="Confirm your choice."
ansWN="What do you want to do ?"

## terminal fonts colors.
red='\e[1;31m'
yel='\e[0;33m'
grn='\e[0;32m'
blu='\e[0;34m'
cya='\e[0;36m'
pur='\e[0;35m'
nc='\e[0m'

## PROLOGUE ###

## check if X server is alive
ps -A | grep -i xorg &>/dev/null
eval x_alive=$?
## save sys IFS variable for restoration purpose.
## ex: IFS=$' \t\n'
ifs=$IFS
## read script mandatory vars config first.
. $script_conf

dep_exec_check(){
	## clean depencies list if any.
	unset deplist
	#p_xterm=$(command -v xterm) || deplist+=("xterm")
	## multi distro system bianries compatibilities.
	d_lspci=$(command -v lspci)
	d_modinfo=$(command -v modinfo)
	d_sys=$(command -v systemctl)
	p_git=$(command -v git) || deplist+=("git")
	p_wget=$(command -v wget) || deplist+=("wget")
	p_gcc=$(command -v gcc) || deplist+=("gcc")
	p_dkms=$(command -v dkms) || deplist+=("dkms")
	d_yad=$(command -v yad) || deplist+=("yad")
	d_zen=$(command -v zenity) || deplist+=("zenity")
	d_xdpy=$(command -v xdpyinfo) || deplist+=("xdpyinfo")
	d_ssl=$(command -v openssl) || deplist+=("openssl")
	d_randr=$(command -v xrandr) || deplist+=("xrandr")
	pk_exec=$(command -v pkexec) || deplist+=("polkit")
	d_nv_installer=$(command -v nvidia-installer)
	d_nv_settings=$(command -v nvidia-settings)
	d_nv_probe=$(command -v nvidia-modprobe)
	d_probe=$(command -v modprobe)
	i_sys=$(command -v dracut)
	i_init=$(command -v update-initramfs)
	i_cpio=$(command -v mkinitcpio)

	# grub could be, grub-[command] or grub2-[command]. Let 'find' catch it for us.
	d_grub=$(find /usr/{sbin,local/sbin} -regextype sed -regex ".*grub[0-9]\?-.*"| sed -n "s/-.*$//;1p")
}
## find first default values for distro and desktop user
## define who is facing the screen.
def_user(){
	user=$(who | grep "(:[0-9])" | awk '{print $1}')
	test "$user" && echo $user || echo $USER
	return
}
su_cmd(){
	case $plug_version in
# 		arch|sles|mageia|mandriva) su_cmd='su -l';;
		rhel|fedora|ubuntu|mint|debian) echo "$(command -v sudo) -u" && return;;
		*) echo "$(command -v su)" && return;;
	esac
}
user_DL_DIR(){
	if [ $x_alive -eq 0 ]; then
		if [[ $(whoami) == "root" ]]; then
			echo $( $(su_cmd) $(def_user) xdg-user-dir DOWNLOAD )
		else
			echo "xdg-user-dir DOWNLOAD"
		fi
		return
	fi
}
user_CF_DIR(){
	if [ $x_alive -eq 0 ]; then
		if [[ $(whoami) == "root" ]]; then
			echo $( $(su_cmd) $(def_user) xdg-user-dir )'/.zenvidia'
		else
			echo "/home/$USER/.zenvidia"
		fi
		return
	fi
}
rem_drv_list(){
	if ! [ -f $(user_CF_DIR)/notify/drvlist ]; then
		$su_cmd "$(def_user)" $(command -v zen_notify) -n &>/dev/null
	fi
	echo "$(user_CF_DIR)/notify/drvlist" && return
}
distro_version(){ # var
	## taken from DKMS script for conformity with dkms queries.
	if [[ -r /etc/os-release ]]; then
		. /etc/os-release
		if [[ "$ID" = "ubuntu" ]]; then
			# ID_LIKE=debian in ubuntu
			echo $ID
		elif [[ ${#ID_LIKE[@]} != 0 ]]; then
			echo ${ID_LIKE[0]}
		else
			echo $ID
		fi
		return
	fi
	local DISTRIB_ID
	# Try the LSB-provided strings first
	if [ -r /etc/lsb-release ]; then
		. /etc/lsb-release
	elif type lsb_release &>/dev/null; then
		DISTRIB_ID=$(lsb_release -i -s)
	fi
	## fix case sensitive
	case ${DISTRIB_ID} in
		Fedora) echo fedora ;;
		RedHatEnterprise*|CentOS|ScientificSL) echo rhel ;;
		SUSE*) echo sles ;;
		Arch) echo arch ;;
		*) if [[ ${DISTRIB_ID} ]]; then
				echo "${DISTRIB_ID}"
			else
				echo unknown
			fi
		;;
	esac
}
win_warning(){
	if [ $zenity_ver -le 3420 ]; then
		win_icon='--window-icon='$img_zen_desktop
		icon_name='--icon-name'
	else
		win_icon=''
		icon_name='--icon'
	fi
	$d_zen --width=450 --title="$_zen_title" $win_icon --warning --no-wrap \
	--text="$w_text" $icon_name=$icone --ok-label="$w_label"
}
set_su(){
	w_text=$(cat <<-WRN
	<b><big>Zenvida didn't find any Distro config file for $plug_version</big></b>

	Next window will ask for distribution <b>name</b> and/or <b>sudo</b> command line
	options for default user admin priviledge.
	<i>( ex: sudo -l, sudo -u, etc )</i>
	WRN
	)
	icone='important'
	w_label='Got it!'
	win_warning

	if [ "$plug_version" == "unknown" ]; then
		w_text=$( cat <<-MSG
			Enter name and <b>sudo</b> type command line arguments.
		MSG
		)
		zen_entry='--add-entry=Distribution'
	else
		w_text=$( cat <<-MSG
			Enter <b>sudo</b> type command line and option
		MSG
		)
	fi
	set_args=$($d_zen --height=200 --width=100 --title="$_zen_title" $win_icon --forms \
	--text="$w_text" --separator=';' $zen_entry --add-entry="sudo command")
	if [ $? = 0 ]; then
		[ "$set_args" != '' ] || exit 0
		if [[ "$set_args" =~ ';' ]]; then
			plug_version=$(echo "$set_args"|cut -d';' -f1)
			plug_conf=$plug_version.conf
			su_cmd=$(echo "$set_args"|cut -d';' -f2)
		else
			su_cmd="$set_args"
		fi
		if [ $(grep -c "su_cmd=" $script_conf ) -eq 0 ]; then echo -e 'su_cmd="'$su_cmd'"' >> $script_conf; fi
	else
		exit 0
	fi
}
distro(){
	plug_version=$(distro_version)
	plug_conf=$plug_version.conf
	if [ "$(def_user)" != "root" ]; then
		if [[ ! -e $conf_dir/distro/$plug_conf ]]; then
			if [[ $(ls -1 $conf_dir/distro | grep -ic "$plug_conf" ) -gt 0 ]]; then
			## conf file exist but in a different upper/lower case.
				dest_conf=$(ls -1 $conf_dir/distro | grep -i "$plug_conf")
			else
			## conf doesn't exist and need to be created
				## check first if name is unknown and ask default su commabnd for user admin priv.
				set_su
				cat <<-CONF > $(user_CF_DIR)/$plug_conf
					## examples between [...] have to be remove by real texts, vars, commands.
					## You can reset detected or set name to friendly one to display in Zenvidia.
					DISTRO="$plug_version"
					kernel=\$( uname -r | cut -d '-' -f 1 )
					## optional kernel devel package extension sometime needed (see ex. below in p_kernel)
					d_version=[ex: \$( uname -r | cut -d '-' -f 1,2 )]
					## define X server executable.
					X="[X]"
					## define package installer and options.
					PKG_INSTALLER="[ex: dnf]"
					pkg_cmd='[ex: install]'
					## auto "yes" option, final space is here needed.
					pkg_opts='[ex: -y ]'
					## default distro 32/64 libs directories.
					if [[ \$ELF_TYPE == 64 ]]; then
						ELF_32="[ex: /i386-linux-gnu or nothing]"
						ELF_64="[ex: /x86_64-linux-gnu or 64]"
						master=lib
					else
						## usualy 32 bit distro doesn't need any special libs definitions.
						ELF_32=""
						ELF_64=""
						master=lib
					fi
					## grub/grub2 directory if different than usual.
					grub_dir=[def: /boot/grub2]
					## define specific dir extension for kernel header and drivers source directory if any.
					alt=[ex: /kernels for /usr/src/kernels/ instead of /usr/src/]
					## default distro kernel sources.
					kernel_src=[ex: /usr/src\$alt/\$(uname -r)]
					## default initramfs updater commend (ex: dracut -f, update-initramfs, etc)
					INITRAM='[ex: dracut -f]'
					if [ \$resolve_dep = 0 ]; then
					## distro specific depencies
					## You can had there any packages matching specific distro needs.
					## ex: deplist+=("package1"), deplist+=("package2"), etc
						deplist+=("[ex: kernel-devel, kernel-headers-\$(uname -r), gksu]")
						deplist+=("")
					fi
				CONF
				## warn about no config file
				w_text=$(cat <<-WRN
				<b>Main $plug_version distro variables are now setted</b>

				You need to create a <u>new configuration</u> based on your distro environment variables.

				<i>Note : Even in case you are not sure of what you are doing, new configuratin file will be saved anyway.
				You will just have to go back to it in <u>$(user_CF_DIR)/$plug_conf</u> afterward.</i>
				WRN
				)
				icone='xkill'
				w_label="Let's go"
				win_warning
				## edit new config file.
				edit_plug_conf=$( $d_zen --width=640 --height=400 --title="Zenvidia $plug_version edition" \
				$win_icon --text-info --editable \
				--filename="$(user_CF_DIR)/$plug_conf" --checkbox="Confirm to write" --cancel-label="Abort (panic button)" \
				--ok-label="Create config file")
				if [ $? = 0 ]; then
					echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf
				else
					## display error message and close all processes.
					w_text=$(cat <<-WRN
					<b>Zenvida can't work without Distro config file for $plug_version</b>

					<u>Don't ask the dev, if didn't create one, it's probably he doesn't know how to.</u>

					You can try having a look at your distro's community forum and ask for help
					or see Zenvidia's git discussion feed.
					Then going back to the saved config file in $(user_CF_DIR)
					WRN
					)
					$d_zen --width=450 --title="$_zen_title" --error --no-wrap \
					--text="$w_text" $icon_name=xkill --ok-label="Snif!"
						exit 0
					fi
			fi
		else
			dest_conf=$(ls -1 $conf_dir/distro | grep -i "$plug_conf")
		fi
		test -f $(user_CF_DIR)/$plug_conf || cp -f $conf_dir/distro/$dest_conf $(user_CF_DIR)/$plug_conf
		. $(user_CF_DIR)/$plug_conf
	else
		## this is here add to get compatibility in terminal only mode and isn't used in graphic mode.
		plug_conf=$(ls -1 $conf_dir/distro |grep -i "$plug_version")
		if test -f $conf_dir/distro/$plug_conf; then
		    . $conf_dir/distro/$plug_conf
		else
		    echo -e "${red} # No distribution conf file found. Abort.${nc}"
		    exit 0
		fi
	fi
	# CHECK that /usr/local/ for lib is in LD path
	for LD in "$ELF_32" "$ELF_64"; do
		if [ $(ldconfig -p |grep -c "$install_dir/$master$LD") -eq 0 ]; then
			printf "$install_dir/$master$LD" > /etc/ld.so.conf.d/local-lib$LD.conf
		fi
	done
}
module_dest_location(){
	case "$(distro_version)" in
		fedora* | rhel* | ovm*) echo "extra" && return ;;
		sles* | suse* | opensuse*) echo "updates" && return ;;
		debian* | ubuntu*) echo "updates/dkms" && return ;;
		arch*) echo "updates/dkms" && return ;;
		*) echo "extra" && return ;;
	esac
}
dm_serv(){
	for dm in {gdm,kdm,xdm,lightdm,lxdm,slim,sddm}; do
		if test -f /usr/lib/systemd/system/$dm.service; then echo "$dm" ; break; else dm=0; fi
	done
	if [ $dm = 0 ]; then
		## if DM is not found, try to dig in display manager service status.
		## wont work if DM service already disable, but will in case of x server crash.
# 		echo "$($d_sys show display-manager.service | sed -En "s/^Docu.*=[\"]?.*:(.*)\(.*\)[\"]?/\1/p")"
		echo "$($d_sys show display-manager.service | sed -En "s/^Id=(.*)\..*$/\1/p")"
	fi
	return
}
zen_colors(){
	# pango colors
	end='</span>'
	v='<span color="'$main'" weight="normal" font="'$size0'" font_family="'$font0'">'	#green
	j='<span color="'$sub'">'			#orange/yellow
	y='<span color="'$log_msg'">'		#cyan/blue
	r='<span color="'$title'">'
	# big red orange title
	rBB='<span color="'$title'" weight="bold" font="20" font_family="'$font1'">'	#red
	# Big
	bf='<span font="'$size1'">'
	nf='<span font="'$size0'">'
	mf='<span font="'$(($size0+2))'">'
	sf='<span font="'$(($size0-2))'">'
	# Bold
	vB='<span color="'$main'" weight="bold" font="'$size0'" font_family="'$font0'">'
	yB='<span color="'$log_msg'" weight="bold" font_family="'$font0'">'
	jB='<span color="'$log_warn'" weight="bold" font_family="'$font0'">'
	gB='<span color="'$log_grn'" weight="bold" font_family="'$font0'">'
	rB='<span color="'$log_err'" weight="bold" font_family="'$font0'">'
	# grey dash
	# 	ge='<span color="#68686F" weight="bold">' #68686F
	ge='<span color="#68686F">'
	nr='<span color="#000000">'
	## xterm colors
	xt_colors='-fg '$fg_xterm' -bg '$bg_xterm
	xN='\e[0m'
	xB='\e[1m'
}
### SYSTEM FUNCTIONS
PCI_ID(){
	## graphic cards id
	unset dev_n dev slot slot_id vnd vnd_id
	i=0
	optimus=0
	test $UID = 0 && tee /sys/bus/pci/rescan <<<1 &>/dev/null
	sleep 1
	## rescan in case of device power switch off (nvidia-xrun, bbswitch, etc).
	pci_list=( "$(lspci -mnn | grep "VGA")" )
	IFS=$(echo -en "\n\b")
	for dev_slot in ${pci_list[@]}; do
		dev_n+=("$i")
		vnd+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^(.*) \[.*\]$/\1/p")")
		vnd_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
		if [[ "${vnd_id[$i]}" =~ "10de" ]]; then
			dev+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}'| sed -En "s/^.*\[(.*)\] \[.*\].*$/\1/p")")
			dev_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
			dev_name=${dev[0]}
		else
			[ "${vnd_id[$i]}" = "8086" ] && dev+=("Intel Graphic") # dev+=("Intel Graphic",modesettings)
			[ "${vnd_id[$i]}" = "1002" ] && dev+=("AMD Radeon") # dev+=("AMD Graphic",flglx)
			[ "${vnd_id[$i]}" = "1022" ] && dev+=("AMD Embed") # dev+=("AMD Graphic",radeon)
			((optimus++))
		fi
		slot+=("$(printf "$dev_slot"| awk '{print $1}')")
		slot_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.*\[.*\] \[(.*)\].*$/\1/p")")
		((i++))
	done
	IFS=$ifs
# 	dev_nb=${#dev_n[*]} # test control
	pci_dev_nb=${dev_n[*]}
	if [ $i -gt 1 ]; then
		if ! [[ "${vnd_id[*]}" =~ "10de" ]]; then
			scan_alert="\n\nNvidia device was not scanned.\nRun again with root priviledge and rescan pci bus."
		fi
	fi
}
# elf types
libclass(){
	# define distro base ELF type
	if [[ $HOSTTYPE =~ "64" ]]; then
# 	if [ $(uname - |grep -c "64") -gt 0 ] ; then
		ELF_TYPE="64"
	else
		ELF_TYPE=""
	fi
}
## dependencies control
dep_control(){
	unset dep_text
# 	deplist=( yad zenity wget ) # test
	if [ "${#deplist[*]}" -gt 0 ] ; then
		for d in ${deplist[@]}; do
			dep_text+=("$d, ")
		done
		dep_text=$(echo "${dep_text[*]}" | sed -n "s/, $//p")' are missing.'
		if [ $UID = 0 ]; then
			context='--question'
			label='Install'
			info='Will you install them now ?'
			EXEC=$(
				cat <<-DEP
					read -p "$info (Y/N) :" confirm
					if [[ "\$confirm" =~ [yY] ]]; then
						$PKG_INSTALLER $pkg_opts$pkg_cmd ${deplist[*]}
						sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
					else
						echo -e "\n${red}Those dependencies are mandatory for Zenvidia.${nc}\n"
						echo -e "If you don't want Zenvidia to install them automatically,"
						echo -e "you need to use your packages manager instead"
						echo -e "BYE !"
					fi
					echo -e "$x_esc_message"
					$x_sleep
				DEP
			)
		else
			context='--warning'
			label='Got it'
			info="You need to restart with ${j}Zenvidia (admin)${end}\n\or use your packages manager to install them"
			EXEC=$(
				cat <<-DEP
					echo -e "Zenvidia is start without admin priviledges."
					echo -e "You need to restart with ${red}Zenvidia (admin)${nc} to install them."
					echo -e "$x_esc_message"
					$x_sleep
				DEP
			)
		fi
		w_text=$(
		cat <<-DEP
			#set -x
			echo -e "${red}Script Dependencies Check${nc}\n"

			echo -e "Required dependencies are not met.\n"
			echo -e "${dep_text[*]}\n"
			$EXEC
		DEP
		)
# 			if [ $? = 0 ]&&[ $UID = 0 ]; then
# 			if [ $UID = 0 ]; then
# 				if [ $d_yad ]; then # test
			if ! [ $d_yad ]; then
				$p_xterm $xt_options -e "$w_text"
			else
				w_text=$(
				cat <<-DEP
					${j}<b>Script Dependencies Check</b>${end}

					Some required dependencies are not met.
					${dep_text[*]}

					$info
				DEP
				)
				if [ $zenity_ver -le 3420 ]; then
					win_icon='--window-icon='$img_zen_desktop
				else
					win_icon=''
				fi
				$d_zen $context --width=400 --text="${v}$w_text${end}" \
				$win_icon --ok-label="$label"
				if [ $? = 0 ]; then
					if [[ "$context" =~ "warning" ]]; then exit 0; fi
					(	$PKG_INSTALLER $pkg_opts$pkg_cmd ${deplist[*]} 2>&1 | \
						while read line; do echo "# ${ge}${sf}${line}${end}${end}"; done
						echo -e "# "
						$esc_message
						$x_sleep ) | \
					$d_yad --width=600 --height=300 --title "Zenvidia" $win_icon \
					--progress --center --hide-text --enable-log='' --log-expanded --log-height=300 \
					--text="${v}Installing missing dependencies${end}" $x_hold
					sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
				else
					exit 0
				fi
			fi
			dep_exec_check
# 			else
# 				exit 0
# 			fi
	fi
}
connection_control(){
	cnx=$(ping -c2 www.nvidia.com)
	cnx=$?
	( if [ $cnx -eq 1 ]; then
		w_text=$( cat <<-MSG
			No internet connection detected.
			A valid network connection is required for any download.
		MSG
		)
		$d_zen --width=300 $win_icon --error --text="${v}$w_text${end}"
	fi ) | $d_zen --width=450 --title="$_zen_title" $win_icon --progress --pulsate --auto-close \
	--text="${v}Connection control...${end}"
	if [ $cnx = 0 ]; then cnx_msg="OK"; else cnx_msg="NONE"; fi
}
## gcc and other compatibility control
compil_vars(){
	if [[ -s $d_nv_installer ]]; then
		NV_bin_ver=$($d_nv_installer -v | grep "nvidia-installer"|awk '{print $3}')
	else
		NV_bin_ver='none'
	fi
	if [[ $(gcc --version | grep "gcc") ]]; then
		GCC=$(gcc --version | grep "gcc" | sed -n "s/^.*) //p"| awk '{print $1}')
	else
		GCC='none'
	fi
	KERNEL=$(uname -r)
	OLD_KERNEL=$(ls -1 /lib/modules | sed -n '/'$KERNEL'/{g;1!p};h')
	# xterm/yad  vars and messages.
	x_pixel=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.* ([0-9]{3,5})x([0-9]{3,5}) .*$/\1;\2/1p")
	x_milli=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.*\(([0-9]{3,4})x([0-9]{3,4}).*\).*$/\1;\2/1p")
	term_x_dsp=$(printf "$x_pixel"| cut -d';' -f1)
	[ $xt_hold = 0 ]|| xx_hold=' -hold'
	if [ $xt_hold = 1 ]; then
		x_esc_message="\n${nc}*****  Close window to escape *****"
# 		esc_message="# ${nr}*****  Close window to escape *****${end}"
# 		x_hold=''
		x_sleep=''
	else
		x_esc_message="\n${nc}*****  Window will auto-close in $xt_delay seconds *****"
# 		esc_message="# ${nr}*****  Window will auto-close in $xt_delay seconds  *****${end}"
# 		x_hold='--auto-close'
		x_sleep="sleep $xt_delay"
	fi
	xt_options=$xt_colors''$xx_hold' -fn 8x13 -geometry 80x24+'$[ ( ($(printf "$x_pixel"| cut -d';' -f1)-660)/2) ]'+0'
	grub_cfg=$(find /boot -wholename "*/grub.cfg"  )
	grub_def=/etc/default/grub
}
## If version 'undifined', control if driver is initialy installed.
check_version(){
	if ! [[ $(version) =~ [0-9]* || $(new_version) =~ [0-9]* ]]; then
		w_text=$( cat <<-ERR
			${j}${bf}Version text file not found.${end}${end}

			Look like driver isn't installed initialy.
			Go to ${y}<b>» Main menu » Install drivers</b>${end} first.
		ERR
		)
		$d_zen --width=300 $win_icon --error --text="${v}$w_text${end}"
		base_menu
	fi
}

# ### INSTALL & COMPIL SECTION ###
## TOOLS ###
## system pre config.
nv_open_modules_set(){
	# nvidia_installer give the possibility to use open driver version, but not the possibility to choose
	# between open or proprietary version by installing both, or just test open only.
	# let's do it.
	if [ $open_wrn = 1 ]; then
		if [ $extract_open = 1 ]; then
			if [ $use_open -ne 1 ]; then
				_title="$_zen_title"
				_text=$(cat <<-MSG
					${jB}Nvidia Open Source Modules${end}
					${vB}Since 515 driver series, it is possible to use nvidia open source drivers
					By default, Zenvidia will build them alongside the main ones.

					AT THIS POINT, OPEN SOURCE DRIVERS WILL BE ONLY BUILD.
					You will be able to switch between version at any time with the ${j}Switch Tool${end}
					in ${j}Configuration and Tools${end} menu (restart Zenvidia is mandatory).

					${j}WARNING ${end}:${v}<i> Open drivers are in still in early state, many features are not
					accessible at this point.
					Check progress in Nvidia Changelog update regulary</i>.${end}

					Do you want to build open source drivers ?${end}
				MSG
				)
# 				$d_zen --question $win_icon --title="$_title" $icon_name=dialog-warning --text="$_text" \
# 				--no-wrap --cancel-label="No" --ok-label="Yes"
				warn_log=$_text
				qst=1; ok_lbl='Yes, please!gtk-ok' ; cancel_lbl='No thanks!gtk-no' ; kill_yad=0
				win_yad_warns
				if [ $y_output = 0 ]; then
					open_drv=1; use_open=0
				else
					open_drv=0; use_open=0
				fi
				sed -Ei "s/^(use_open)=[0-9]$/\1=$use_open/" $basic_conf
				sed -Ei "s/^(open_drv)=[0-9]$/\1=$open_drv/" $basic_conf
				if [ $first_open = 1 ]; then
					_text=$(cat <<-MSG
						${jB}Nvidia Open Source Modules${end}

						${j}WARNING ${end}:${vB}By default, Zenvidia send alert about open driver building,
						If you select ${j}<i>NO</i>${end} here, the previous window won't be displayed again.

						${v}<i>(Choice will be saved in configuration file and could be change)</i>${end}

						Do you want to be warn at each drivers upgrade ?${end}
					MSG
					)
# 					$d_zen --question $win_icon --title="$_title" $icon_name=dialog-warning --text="$_text" \
# 					--no-wrap --cancel-label="No" --ok-label="Yes"
					warn_log=$_text
					qst=1; ok_lbl='Yes, please!gtk-ok' ; cancel_lbl='No thanks!gtk-no' ; kill_yad=0
					win_yad_warns
					if [ $y_output = 0 ]; then
						first_open=0; open_wrn=1
					else
						first_open=0; open_wrn=0
					fi
					sed -Ei "s/^(open_wrn)=[0-9]$/\1=$open_wrn/" $basic_conf
					sed -Ei "s/^(first_open)=[0-9]$/\1=$first_open/" $basic_conf
				fi
			fi
		fi
	fi
	## check for open drivers source dir in tree
	if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
		cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open /usr/src/open-nvidia-$(new_version)
	fi
}
nv_modules_set(){ # ALERT TO  REMOVE TODO
	_insert_type=1
	_help_tip=$(cat <<-HLP
		${v}- Unified Memory Module (${j} nvidia-uvm ${end})
		  is required for CUDA driver and application.
		- Prime Sync DRM Module (${j} nvidia-drm ${end})
		  is required for Optimus PRIME modesetting environment.${end}
		If you do not have or intend to use CUDA service and/or Optimus PRIME,
		it is safe to not use them."
	HLP
	)

	## Optimus alert and basic config.
	if [ ${#dev_n[*]} -gt 1 ]; then
		if [ $optimus -gt 0 ]; then
			if [ $no_opti_warn = 0 ]; then
				modules_msg=$(cat <<-TXT
					${v}<b>Optimus Prime detection alert</b>
					More than one different devices detected in the system.

					In this particular case all driver type are mandatory and Zenvidia
					will auto setup drivers for Optimus. Xorg will be prepared for Optimus specific needs.
					<b>Warning</b> : ${j}From there, Optimus/Prime manager tool is mandatory${end}.

					<u>Note</u> : <i>settings will be saved in zenvidia local config and alert wont be shown again.
					Edit Zenvidia local config file to change this behaviour or only Optimus set.</i>

					Do you want to preset Optimus ?${end}
				TXT
				)
# 				$d_zen --question $win_icon --title="$_zen_title" $icon_name=dialog-warning \
# 				--text="$modules_msg" --no-wrap --cancel-label=", I'll figure it out later" --ok-label=""
				warn_log=$modules_msg
				qst=1; ok_lbl='Yes, please!gtk-ok' ; cancel_lbl='No thanks!gtk-no' ; kill_yad=0
				win_yad_warns
				if [ $? = 0 ]; then
					opti_preset=1
					use_uvm=1
					use_drm=1
				else
					opti_preset=0
				fi
				no_opti_warn=1
				sed -Ei "s/^(no_opti_warn)=[0-9]$/\1=$no_opti_warn/g" $basic_conf
				sed -Ei "s/^(opti_preset)=[0-9]$/\1=$opti_preset/g" $basic_conf
			fi
		fi
	fi
	## get values from previoully optimus sets or config file.
	if [ $hlp_txt = 1 ]; then _tip=$_help_tip; else _tip=''; fi
	if [ $use_uvm -gt 0 ]; then UVM='TRUE'; else UVM='FALSE'; fi
	if [ $use_drm -gt 0 ]; then DRM='TRUE'; else DRM='FALSE'; fi
# 	if [ $use_peer -gt 0 ]; then PEER='TRUE'; else PEER='FALSE'; fi

	## warn about first use.
	modules_msg=$(cat <<-TXT
		${vB}This is the first time you launch this options sets.

		With the next window you can select the nvidia's drivers type you want/need
		to use and will set the basic configuration file for future builds.
		$_help_tip${end}
	TXT
	)
	if [ $no_warn = 0 ]; then
		$d_zen --question $win_icon --title="$_zen_title" $icon_name=dialog-warning \
		--text="$modules_msg" --no-wrap --cancel-label="I got it, don't show me this message again" --ok-label="I got it"
		no_warn=$?
		sed -Ei "s/^(no_warn)=[0-9]$/\1=$no_warn/g" $basic_conf
	fi
	_title="$_zen_title"
	_text=$(cat <<-TXT
		${yB}${bf}Nvidia Optional Modules${end}${end}
		${vB}By default Zenvidia will only use the main Nvidia driver.
		You can select here the optional driver as you need.
		$_tip
		Check the appropriate boxes in list below to use optional drivers.${end}
		${v}Note :<i> nvidia-drm is use by default since 515 serie and will be set to 1</i>.

		<i>(Choice will be saved in configuration file and could be change)</i>${end}
	TXT
	)
	## set modprobe.d files
	black_file=/etc/modprobe.d/nvidia-blacklist.conf
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=220'
	else
		w_height='--height=380'
	fi
	## evaluate previous config sets.
	old_drm_modset=$use_drm
	old_drm_set=$use_drm
	old_uvm_set=$use_uvm
	unset driver_var black_conf # modprobe_conf
	driver_var=$($d_zen --width=500 $w_height $win_icon --list --title="$_title" --text="$_text" \
	--column="check" --column="2" --column="driver" --checklist --multiple --print-column=2 --hide-column=2 \
	--separator=' ' --hide-header \
	$UVM "use_uvm" "Unified Memory Module (nvidia-uvm)" $DRM "use_drm" "Optimus Prime Sync DRM Module (nvidia-drm)")
	if [ $? = 1 ]; then base_menu; fi
	## sortie : use_uvm use_drm
	## ATTENTION la valeur TRUE implique l'usage et n'est pas blacklistée.
	## La valeur FALSE implique le non usage et est blacklistée.
	for mod in {use_uvm,use_drm}; do
		## if optimus system is detect, set all vars to 1, else, manage as usual.
		if [ $opti_preset = 0 ]; then
			if [[ "$driver_var" =~ "$mod" ]]; then
			# don't blacklist or remove from blacklist.
				class=$(printf "$mod"|cut -c4-)
				black_conf+=("$mod;1;nvidia$class")
# 				modprobe_conf+=("$mod;1;nvidia$class")
			else
			# blacklist or add to blacklist.
				VAL=0
				## SINCE 515.48 DRM ARE USE BY DEFAULT set is 1.
# 				if [ $(chk_version) -ge 515 ]&&[ $(chk_version) -lt 535 ]; then
				if [ $(chk_version) -ge 515 ]; then
					if [[ "$mod" == "use_drm" ]]; then
						[ $(grep -c "nvidia$class" $black_file) -gt 0 ]&& VAL=1
					fi
				fi
				class=$(printf "$mod"|cut -c4-)
				black_conf+=("$mod;$VAL;blacklist nvidia$class")
			fi
		else
			class=$(printf "$mod"|cut -c4-)
			black_conf+=("$mod;1;nvidia$class")
# 			modprobe_conf+=("$mod;1;nvidia$class")
			eval $mod=1
		fi
	done
}
gcc_options(){
	# test driver code compilator version __GNUC__, __GNUC_MINOR__
	test $(grep -E -c "gcc_mismatch" $basic_conf) -gt 0 && (
		if [ $gcc_mismatch = 1 ]; then ignore_mismatch="IGNORE_CC_MISMATCH=1"; else ignore_mismatch=''; fi
		export IGNORE_CC_MISMATCH=$gcc_mismatch
	)
	proc=$(grep -E -c "processor.*[0-9]{,2}" /proc/cpuinfo)
}
## PAY ATTENTION : With RT kernel, drivers could install properly but they could also not init at Xorg start.
## Do not ever overwrite current used kernel by RT one.
rt_options(){
# test if kernel is realtime.
	is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
	if [ $is_RT = 1 ]; then
		## user warning
		_title="$_zen_title"
		_text=$( cat <<-TXT
			${rBB}REALTIME Kernel Detected${end}
			${vB}ATTENTION :${v} You are about to install driver on a realtime kernel.

			Don't forget Nvidia kernel is not normaly made for realtime.
			Troubles init at boot time could happen.
			Think about making a root partition backup if you have no fallback.

			${j}"<b> dd if=/dev/sdxx of=root.img bs=1024k status=progress </b>"${end}
			(from a live usb)

			Do you really want to use compilation over realtime kernel ?${end}${end}
			TXT
		)
		$d_zen --question $win_icon $icon_name=dialog-warning --no-wrap \
		--cancel-label="Abort" --ok-label="Proceed" --title="$_title" --text="$_text"
		# yes 0, no 1
		if [ $? = 0 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		else
			base_menu
		fi
	fi
}
nv_drv_list(){
	unset _drv_list
	for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
		if [ $(grep -owc "$drv" /etc/modprobe.d/nvidia-blacklist.conf) -eq 0 ]; then _drv_list+=("$drv"); fi
	done
	echo "${_drv_list[*]}"
}
## nvidia driver vars [in functions)
## some sets have to be place as function to be re-used at multi levels.
version(){
	#test -f $(user_CF_DIR)/version.txt && cat $(user_CF_DIR)/version.txt || echo "0"
	test -f $nvdir/version.txt && cat $nvdir/version.txt || echo "0"
	return
}
new_version(){
	if [ $from_install = 1 ]; then
			if [ "$LAST_PACK" ]; then
				echo "$LAST_PACK"
			else
				echo "$run_pkg" | sed -En "s/^.*-(.*)/\1/; s/.run//g;p"
			fi
	else
# 		test $LAST_BETA && echo $LAST_BETA || echo "$(version)"
		echo "$(version)"
	fi
	return
}
old_version(){
	if [ $from_install = 1 ]; then
		$d_modinfo -F version nvidia -k $KERNEL &>/dev/null
		if [ $? -eq 0 ]; then
			if test -f $tmp_old; then
				cat $tmp_old
			else
				$d_modinfo -F version nvidia -k $KERNEL
			fi
		else
			echo "0"
		fi
	else
		## in case of archive restoration, the old version is current version in te kernel.
		if [ "$present_version" ]; then
			test -f $present_version && cat $present_version || echo "0"
		else
			echo "0"
		fi
	fi
	return
}
nv_old(){
	echo "$(old_version)"| sed -n "s/\.//g;p"
	return
}
nv_new(){
	if [ "$(new_version)" ]&&[ "$(new_version)" != "0" ]; then
		echo "$(new_version)"| sed -n "s/\.//g;p"
	else
		echo "$(version)"| sed -n "s/\.//g;p"
	fi
	return
}
mod_installed(){ # used by nv_build_dkms only
 	test -d $kernel_path && find $kernel_path -name "nvidia.*[ko\|ko.xz]" -print0 | xargs -0 modinfo -F version
 	return
}
chk_version(){ echo "$(new_version)"| cut -d'.' -f1; }
## define installed driver version, if any
drv_installed(){ ## FIXME retirer la ligne de migration version.txt aux prochaines mises à jour.
	test -f $(user_CF_DIR)/version.txt || cat $nvdir/version.txt > $(user_CF_DIR)/version.txt
	[ "$(cat $(user_CF_DIR)/version.txt)" != "$(version)" ] && echo "$(version)" > $(user_CF_DIR)/version.txt
	if [ "$(version)" == "0" ]; then
		echo 'not installed'
	else
		echo $(version)
fi
}
## initramfs tools detect and config.
initramfs_tools(){
	## try to find 'dracut' first, then fallbback to 'update-initramfs' if not found.
	## look the possibility to add /usr/bin/mkinitcpio -p linux. how-to ?
	## if none are found, disable ramfs rebuild and warn.
	if test $i_sys; then
		echo "$i_sys -f --kver"
	elif test $i_init; then
		echo "update-initramfs -u -k"
	elif test $i_cpio; then
		echo "mkinitcpio -p linux --kernel"
	else
		echo 0
	fi
}
test_ramfs_tool(){
## detect if ramfs tool exist then send to initramfs_warn if none.
	test "$(initramfs_tools)" = 0 && echo 0 || echo 1
}
initramfs_warn(){
	if [ $(test_ramfs_tool) = 0 ]; then
		## send alert
		## and ask to proceed with modprobe reload if initramfs tool is no detected.
		_text=$( cat <<-WRN
			${j}<b>No tool were found to rebuild initramfs</b>${end}
			Modprobe reload could work for the used kernel,
			but probably not for an extra kernel.
			Updated Modules wont probably load at reboot.

			You have been warn !
		WRN
		)
# 		zenity --question $icon_name=dialog-warning --no-wrap \
# 		--cancel-label="Abort" --ok-label="Proceed" --title="$_title" --text="${v}$_text${end}"
		warn_log=$_text
		warn_image='gtk-warning'
		qst=1; ok_lbl='Proceed!gtk-ok' ; cancel_lbl='Abort!gtk-no' ; kill_yad=0
		win_yad_warns
		if [ $y_output = 1 ]; then
			exec_mod_tool=0
			base_menu
		else
			exec_mod_tool=1
		fi
	fi
}
## commands ###
exec_depmod(){
	 if [[ -f /boot/System.map-$1 ]]; then
        /usr/sbin/depmod -a "$1" -F "/boot/System.map-$1"
    else
        /usr/sbin/depmod -a "$1"
    fi
    return $?
}
exec_mod_load(){
	## from DKMS script (partly)
	# ATTENTION modprobe on device only ?
	#nv_pci=$(grep "10de" <<< ${pci_n[*]}|cut -d, -f2 )
# 	nv_pci=${slot[0]}
	#find /sys/devices -regextype sed -regex ".*$nv_pci.*modalias" -print0 | xargs -0 cat | xargs modprobe -b
# 	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.gz"
	# or modprobe on all mandatory ?
	find /sys/devices -name modalias -print0 | xargs -0 cat | xargs modprobe -a -b -q
# 	command -v restorecon &>/dev/null && restorecon -iF "/boot/symvers-$KERNEL.*"
	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.*"
	if [ -f /lib/systemd/system/systemd-modules-load.service ]; then
		$d_sys restart systemd-modules-load.service
	fi
	return $?
}
exec_initramfs(){ # ALERT TMP_C
## rebuild initramfs if modules reload service found is uselees in the case.
	## progress message is place before fuction exec and formated like this :
	## progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; } for zenity.
	## progress_msg(){ echo -en "\r# ($m%) - Rebuilding INITRAMFS"; } for terminal.
	## last 'echo' is for zenity progress bar only. ex:
	# 	echo "# Updating $KERNEL initramfs."; sleep 2
	# 	progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; }
	# 	m=1 ;
# 	progress "$INITRAM --kver $KERNEL"; . $tmp_c ; rm -f $tmp_c
# 	progress "dracut --add-drivers $(nv_drv_list) --kver $KERNEL"; . $tmp_c ; rm -f $tmp_c
	progress "$(initramfs_tools) $KERNEL"; . $tmp_c #; rm -f $tmp_c # ALERT
# 	command -v restorecon &>/dev/null && restorecon -iF /boot/symvers-$KERNEL.*
	return $?
}

## configuration ###
win_log_options(){
	if [ $xt_hold = 1 ]; then
		esc_message="# ${nr}*****  Close window to escape *****${end}"
		x_hold=''
	else
		esc_message=''
		x_hold='--auto-close'
	fi
}
nv_open_switch(){ # ALERT TMP_C
	probe_open=/etc/modprobe.d/open-NVIDIA.conf
	kernel_path=/lib/modules/$KERNEL/$(module_dest_location)
	reverse_conf(){
		[ $open_drv -ne $old_open_drv ]&& sed -Ei "s/^(open_drv)=.*$/\1=$old_open_drv/" $basic_conf
		[ $use_open -ne $old_use_open ]&& sed -Ei "s/^(use_open)=.*$/\1=$old_use_open/" $basic_conf
		[ $_opt -gt 0 ] && exit 0 || menu_modif
	}
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -ne $old_use_open ]; then
			if [ $use_open -eq 1 ]; then
				drv_on='open-nvidia'
				drv_off='nvidia'
			else
				drv_on='nvidia'
				drv_off='open-nvidia'
			fi
				confirm_msg=$( cat <<-MSG
					${j}${bf}$drv_on switch${end}${end}
					${v}You are going to switch from ${j}$drv_off${end} to ${j}$drv_on${end}
					Are you sure ?${end}
				MSG
				)
				val_title="Zenvidia" #TEXT
				val_confirm="Yes, switch to $drv_on" #TEXT
				val_back="No, reverse to $drv_off" #TEXT
				val_cancel="reverse_conf" #TEXT
				val_exit="reverse_conf" #EXIT CMD
				win_confirm
# 				switch_txt="DRIVER SWITCH from DKMS $drv_on build"
			## Switch exec start here
			y_text="DRIVER SWITCH from DKMS ${j}$drv_off${end} to ${j}$drv_on${end} build"
			pulse=1; log=1; hold=1 ; hide_txt=1; [ $hold = 1 ] && win_log_options
			{	timeout=30
			{	echo -e "# ${v}Switching from ${y}$drv_off${end} to ${y}$drv_on.${end}${end}"
				## 6 ops for progress.
				if [ -d /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module ]; then
					cp -f /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
					echo -e "# ${v}Depmod ${j}$KERNEL${end} modules ...${end}"
					sleep 2
					progress_msg(){ echo -e "# ${ge}${sf} * Depmod $KERNEL modules ($m sec.)${end}${end}"; }
					m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c # ALERT
				else
					## in case of a fresh kernel update, only the predifined type is compile and install by dkms
					## and thus, var/lib/dkms module dir doesn't exist.
					## It is there need to recompile the all stuff
					tmp_b=$(mktemp --tmpdir zn_vars.XXX)
					rem_tmp+=("rm -f $tmp_b")
					trap "${rem_tmp[*]}" EXIT
					nv_build_dkms
					echo -e "# ${v}Re-create ${j}$KERNEL${end} initramfs ...${end}"
					sleep 2
# 					progress_msg(){ echo "# ${ge}${sf} * Exec $KERNEL modules iniramfs ($m sec.)${end}${end}"; echo "$m"; } ; m=1; do_slp=1
# 					exec_initramfs
				fi
				if [[ $drv_on == "nvidia" ]]; then
					license="NVIDIA"
				else
					license="Dual MIT/GPL"
				fi
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "$license" ]]; then
					echo -e "# ${v}License is $license${end}"
				else
					echo -e "# ${r}ERROR!${end}${y}: License is steal $license, reversing all.${end}"
					reverse_conf
				fi
				sleep 2
				## add or remove open-driver kernel options.
# 				if [[ "$drv_on" =~ "open" ]]; then
				if [ $use_open -eq 1 ]; then
					echo -e "# ${v}Set ${y}$drv_on${end} kernel options.${end}"
					cat <<-CONF > $probe_open
						options nvidia NVreg_OpenRmEnableUnsupportedGpus=1
					CONF
				else
					echo -e "# ${v}Unset ${y}$drv_off${end} kernel options.${end}"
					[ -f $probe_open ]&& rm -f $probe_open
				fi
				echo -e "# ${v}Re-create ${j}$KERNEL${end} initramfs ...${end}"
				sleep 2
				progress_msg(){ echo "# ${ge}${sf} * Exec $KERNEL modules iniramfs ($m sec.)${end}${end}"; echo "$m"; } ; m=1; do_slp=1
				# rebuild initramfs
				exec_initramfs
				echo -e "# ${v}Restore ${j}$KERNEL${end} modules selinux connection ...${end}"
				sleep 2
				## systemctl restart systemd-modules-load.service
				progress_msg(){ echo "# ${ge}${sf} * Exec $KERNEL modules reload ($m sec.)${end}${end}"; echo "$m"; } ; m=1; do_slp=1
				exec_mod_load
				sleep 2
				## add no-autoinstall blank file
				touch /etc/dkms/no-autoinstall
				## set DKMS AUTOINSTALL values for each driver type.
				echo -e "# ${v}Set ${y}$drv_on${end} DKMS AUTOINSTALL option to \"yes\".${end}"
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/$drv_on-$(version)/dkms.conf
# 				sed -Ei "s/AUTOINSTALL=\".*\"//" /usr/src/$drv_off-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
# 				sed -n "s/AUTOINSTALL.*$/*/i;{/^.*\*$/d;s/^\ //i;p}" /usr/src/$drv_off-$(version)/dkms.conf
				sed -ni "s/AUTOINSTALL.*$/*/;{/^.*\*$/d;s/^\ //g;p}" /usr/src/$drv_off-$(version)/dkms.conf
				## set diplayed license by driver type.
				sleep 2
				echo -e "# "
				echo -e "# ${v}Reboot for ${y}$drv_on${end} to take effect.${end}"
				sleep 2
				echo -e $esc_message
				sed -Ei "s/^(use_open)=.*$/\1=$use_open/" $basic_conf
			} & eval lpid=$!; y_pulse; } | win_yad_progress
# 			} | $d_zen --width=450 $win_icon --title="$_zen_title" --progress --pulsate \
# 			--text="${v}$switch_txt${end}"
		fi
	else
		if [ $open_drv -ne $old_open_drv ]; then
			confirm_msg=$( cat <<-MSG
			${j}${bf}Open Driver removal${end}${end}
			${v}You are going to remove open source driver from driver tree.
			Are you sure ?${end}
			MSG
			)
# 			val_title="$_zen_title" #TEXT
			val_title="Zenvidia" #TEXT
			val_confirm="Yes, remove" #TEXT
			val_back="No, preserve" #TEXT
			val_cancel="reverse_conf" #TEXT
			val_exit="reverse_conf" #EXIT CMD
			win_confirm
			## remove dkms driver tree.
			y_text="Open Source Drivers deletion"
			pulse=1; log=1; hold=1 ; hide_txt=1; [ $hold = 1 ] && win_log_options
			{	timeout=30
			{	sleep 2
				## 7 ops progress.
				echo -e "# ${v}Remove ${j}open source${end} drivers from DKMS tree${end}"
				/usr/sbin/dkms remove -m "open-nvidia"/$(version) -all
				sleep 2
				echo -e "# ${v}Restoring ${y}default${end} Nvidia drivers.${end}"
				cp -f /var/lib/dkms/nvidia/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
				sleep 2
				echo -e "# ${v}Depmod ${j}$KERNEL${end} modules ...${end}"
# 				depmod -a -kver $KERNEL
				progress_msg(){ echo -e "# ${ge}${sf} * Depmod $KERNEL modules ($m sec.)${end}${end}"; }
				m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c # ALERT
				sleep 2
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "NVIDIA" ]]; then
					echo -e "# ${v}License is back to NVIDIA${end}"
				else
					echo -e "# ${r}ERROR!${end}${y}: License is still Dual MIT/GPL, abort.${end}"
					reverse_conf
					exit 1
				fi
				echo -e "# ${v}Restore ${j}$KERNEL${end} modules connection ...${end}"
				sleep 2
				## systemctl restart systemd-modules-load.service
				progress_msg(){ echo "# ${ge}${sf} * Exec $KERNEL modules reload ($m sec.)${end}${end}"; echo "$m"; } ; m=1; do_slp=1
				exec_mod_load
				## remove no-autoinstall blank file
				test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
				echo -e "# ${v}Set Nvidia DKMS AUTOINSTALL option to \"yes\".${end}"
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/nvidia-$(version)/dkms.conf
# 				sed -Ei "s/AUTOINSTALL=\".*\"//" /usr/src/open-nvidia-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
				sed -n "s/AUTOINSTALL.*$/*/i;{/^.*\*$/d;s/^\ //i;p}" /usr/src/open-nvidia-$(version)/dkms.conf
				sleep 2
				echo -e "# ${v}Unset ${y}$drv_off${end} kernel options (if any).${end}"
				[ -f $probe_open ]&& rm -f $probe_open
				sleep 2
				echo -e "# ${v}Set back Configuration file to NVIDIA only.${end}"
				sed -Ei "s/^(open_drv)=.*$/\1=0/" $basic_conf
				sed -Ei "s/^(use_open)=.*$/\1=0/" $basic_conf
				sleep 2
				echo -e ""
				echo -e "# ${v}Reboot for change to take effect.${end}"
				sleep 2
				echo -e $esc_message
			} & eval lpid=$! ; y_pulse; } | win_yad_progress
# 			} | $d_zen --width=450 $win_icon --title="$_zen_title" --progress --pulsate \
# 			--text="${v}Open Source Drivers deletion${end}"
		fi
	fi
}
blacklist_and_grub_set(){ # Perform blacklist and grub config.
	## font display differently if install process in on.
# 	old_drm_modset=$use_drm
# 	old_drm_set=$use_drm
# 	old_uvm_set=$use_uvm
	if [ $from_install = 1 ]; then
		fonts="${j}($n%)${end}${ge}${sf}"
		sub_fonts="${ge}($n%)${sf}"
	else
		fonts="${ge}${nf}"
		sub_fonts="${ge}${sf}"
	fi
	blacklist='nouveau.modeset=0 rd.driver.blacklist=nouveau'
	test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='.* '
	## Older driver version wasn't supporting frame buffer distro splash screen, and need
	grub_drmset=' nvidia-drm.modeset'
	## modset var is used by nvidia-drm and nvidia-prime config sets.
	## It's also used by plymouth splash screen to render boot animation.
	## It could also prevent from Tearing (no concumitant infos about this).
	if [ $use_drm = 1 ]; then
		## drm_modset value overide all default configuration.
		if [ $drm_modset = 1 ]; then
			modset=$grub_drmset'=1'
		else
			## if automation take place, set default to 0 (not use).
			## from 535 serie (maybe 530) nvidia-drm.modeset=1 in set by default and we config it in modprobe.conf.
			if [ $from_install = 1 ]&&[ $(chk_version) -ge 535 ]; then
				## nvidia-drm.modesset to 0 in grub conf (lightdm issue only ?) to start without xorg loop.
				modset=''
			else
				modset=$grub_drmset'=0'
			fi
		fi
	else
		## This case, value is set only in modprobe.conf
		modset=''
	fi
	if [ $(grep -c "GRUB_CMD.*nouveau" $grub_def) -gt 0 ]; then
		if [ $(cat $grub_def| grep -E -c "^GRUB_CMD.*$blacklist$modset.*$") -eq 0 ]; then
			echo "# ${fonts} * GRUB conf updated (nouveau driver blacklisting and options).${end}${end}"; sleep 2
			## then, replace default env grub with new vars and update grub.cfg.
			sed -Ei "s/^(GRUB_CMD.*)=\"(.*) ($grub_orig.*)\"$/\1=\"$blacklist$modset \3\"/" $grub_def
			$d_grub-mkconfig -o $grub_cfg 2>&1 | \
			while read -r line; do echo "# ${sub_fonts} * ${line}${end}${end}"; ((n++)); echo $n; done
		fi
	else
		echo "# ${fonts} * Create GRUB conf for nouveau driver blacklisting.${end}${end}"; sleep 2
		sed -En "s/^GRUB_CMD.*=\"(.*)\"$/grub_orig='\1'/p" $grub_def > $(user_CF_DIR)/grub-orig
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$blacklist$modset \2\"/" $grub_def
		$d_grub-mkconfig -o $grub_cfg 2>&1 | \
		while read -r line; do echo "# ${sub_fonts} * ${line}${end}${end}"; ((n++)); echo $n; done
	fi
	## add nouveau blacklist to modeprobe.d configs list.
	if [ ! -f /etc/modprobe.d/blacklist-nouveau.conf ]; then
		echo "# ${fonts} * Update modprobe blacklist for nouveau driver.${end}${end}"; sleep 2
		echo "blacklist nouveau" > /etc/modprobe.d/blacklist-nouveau.conf
	fi
	## take care of modeset 1 for 515 serie too.
	if [ $use_drm = 1 ]||[ $opti_preset = 1 ]; then
		## optimus section.
		if [ $opti_preset = 1 ]; then
			drm_modset=1; drm_msg='Optimus'
		else
			drm_msg=$(chk_version)' serie'
		fi
		if [ "$old_drm_modset" != '' ]&&[ $drm_modset -ne $old_drm_modset ]; then
			sed -Ei "s/^(drm_modset)=.*$/\1=$drm_modset/" $basic_conf
		fi
		if [ $(chk_version) -ge 535 ]; then
			if [ "$timeout" != '' ];then
				echo "# Update modprobe nvidia-drm option for $drm_msg."; sleep 2
			else
				echo "# ${fonts} * Update modprobe nvidia-drm option for $drm_msg.${end}${end}"; sleep 2
			fi
			echo "options nvidia_drm modeset=$drm_modset" > /etc/modprobe.d/nvidia-drm.conf
		fi
	fi
}
nv_blacklist_modules_conf(){ ## set blacklist only and eval drm_modeset.
		## set modprobe.d files
		black_file=/etc/modprobe.d/nvidia-blacklist.conf
		## move to post_install
		if [ ${#black_conf[*]} -gt 0 ]; then
			IFS=$(echo -en "\n\b")
			for mod_sets in ${black_conf[@]}; do
				mod=$(echo "$mod_sets"| cut -d';' -f1)
				used_val=$(echo "$mod_sets"| cut -d';' -f2)
				black_text=$(echo "$mod_sets"| cut -d';' -f3)
				eval $mod=$used_val
				# update or modifiy nvidia-blacklist.conf
				if [ -f $black_file ]; then
					if [ $(grep -c "$black_text" $black_file) -gt 0 ]; then
						if [ $used_val -eq 0 ]; then replace="$black_text"; else replace=''; fi
						sed -Ei "s/^$black_text$/$replace/g" $black_file
					fi
				else
					if [ $used_val -eq 0 ]; then
						cat <<-CONF >> $black_file
							$black_text
						CONF
					fi
				fi
				## eval new state of non blacklisted modules, if any.
				if [ "$mod" == "use_drm" ]; then
					drm_modset=$used_val
				fi
				eval $mod=$used_val
				# update basic conf.
				if [ $(grep -c "$mod" $basic_conf) -gt 0 ]; then
					sed -Ei "s/^($mod)=[0-9]$/\1=$used_val/g" $basic_conf
				fi
			done
			IFS=$ifs
			## removed blanck lines from file if any.
			sed -i "/^[[:space:]]*$/d;s/^\ //g" $black_file
		fi
}
## TODO ADD OPTI_SETUP here.
# let xorg_conf configure the xorg config file, then ask for prime or optimus
# if optimus like laptop is detected.
prime_setup_window(){ ## TODO UNUSED YET
	echo
}
prime_setup(){ ## TODO UNUSED YET
	## check for DM here.
	## xorg defs are config in xorg_conf section.
	if [ $opti_preset = 1 ]; then
		xrandr_conf=$(
			cat <<-CONF
				xrandr --setprovideroutputdevice modesetting NVIDIA-0
				xrandr --auto
			CONF
		)
		if [ "$dm_serv" == "lightdm" ]; then
			## add conf
			echo -e "#! /bin/bash\n\n$xrandr_conf\n" > /etc/lightdm/prime_ini
			chmod 755 /etc/lightdm/prime_ini
			## change Seat /etc/lightdm/lightdm.conf
			cp -f /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak
			sed -Ei "s/^.*(display-setup-script)=.*/\1=\/etc\/lightdm\/prime_ini/" /etc/lightdm/lightdm.conf
		elif [ "$dm_serv" == "sddm" ]; then
			## modify conf /usr/share/sddm/scripts/Xsetup
			cp -f /usr/share/sddm/scripts/Xsetup /usr/share/sddm/scripts/Xsetup.bak
			echo -e "$xrandr_conf" > /usr/share/sddm/scripts/Xsetup
		elif [ "$dm_serv" == "gdm" ]; then
			# /usr/share/gdm/greeter/autostart/optimus.desktop
			# /etc/xdg/autostart/optimus.desktop
			desktop_conf=$(cat <<-CONF
				[Desktop Entry]
				Type=Application
				Name=Optimus
				Exec=sh -c "xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto"
				NoDisplay=true
				X-GNOME-Autostart-Phase=DisplayServer
			CONF
			)
			echo "$desktop_conf" > /usr/share/gdm/greeter/autostart/optimus.desktop
			echo "$desktop_conf" > /etc/xdg/autostart/optimus.desktop

	# 	elif [ "$dm_serv" == "" ]; then
		fi
		## TODO, in progress.
	# 		if [ $opti_preset = 1 ]; then
	# 			cat <<-CONF >> $dm_conf
	# 				xrandr --setprovideroutputdevice modesetting NVIDIA-0
	# 				xrandr --auto
	# 			CONF
	# 				#xrandr --output LVDS-1-1 --primary
	# 				#xrandr --output VGA-0 --off
	# 		fi
	fi
}
# optimus_setup(){
# 	echo
# }
xorg_conf(){
## prime setup start here.
# Is opti_preset set ?
# If opti_preset is set, ask if user wants to config prime and warn about modesetting TearFree option is not available
# until version 21.2 of Xorg. 20.14 here.

## creation order :
## 	sec_files		x 1
## 	sec_layout		x X
## 	sec_device		x X
## 	sec_option_df	x X/1
## 	sec_screen		x X/1
	sec_files(){
		if [ $ELF_TYPE -eq 64 ]; then
			ELF=$ELF_64
		else
			ELF=''
		fi
		conf_date=$(date +%D-%T)
		cat <<-XF > $x_conf_dir/xorg.conf.nvidia
			## xorg conf originaly created by $(new_version) nvidia installer.
			## Edited automaticaly by Zenvidia > $conf_date

		XF
		if [ $(chk_version) -lt 430 ]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "Files"
			   ModulePath "$nv_root/nvidia/xorg/modules"
			   ModulePath "/usr/$master$ELF/xorg/modules"
			EndSection

			XF
		fi
	}
	sec_layout(){
		layout_screen(){
			for e in $pci_dev_nb; do
				if [ $opti_preset = 0 ]; then
					cat <<-XF
						   Screen ${dev_n[$e]}   "Screen${dev_n[$e]}" 0 0
					XF
				else
					if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
						cat <<-XF
						   Screen ${dev_n[$e]}   "Screen${dev_n[$e]}" 0 0
						XF
					else
						cat <<-XF
						#   Screen ${dev_n[$e]}   "Screen${dev_n[$e]}" 0 0
						   Inactive   "Device${dev_n[$e]}"
						XF
					fi
				fi
			done
		}
		## layout section may differ with second card (optimus).
		## main screen become nvidia's.
		if [ $opti_preset = 0 ]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"Xinerama" "0"
				EndSection

			XF
		else
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"Xinerama" "0"
				   Option	"AllowNVIDIAGPUScreens"
				EndSection

			XF
		fi
		cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "ServerFlags"
				# allows the server to start up even if the mouse does not work
			   AllowMouseOpenFail
			EndSection

		XF
	}
	sec_device(){
			pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				Section "Device"
				   Identifier	"Device${dev_n[$e]}"
				   Driver	"nvidia"
				   VendorName	"${vnd[$e]}"
				   BusID	"PCI:$pci_slot"
			XF
			else
				if [ $opti_preset = 1 ]; then
					pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
					cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
						Section "Device"
						   Identifier	"Device${dev_n[$e]}"
						   Driver	"modesetting"
						   VendorName	"${vnd[$e]}"
						   BusID	"PCI:$pci_slot"
						   Option	"TearFree" "true"
					XF
				fi
			fi
	}
	sec_option_df(){
	## compute X screen DPI ex : (1080x25.4)/286. From Nvidia Doc formula.
		if [ $d_xdpy ]; then
			w_pix=$(printf "$x_pixel"| cut -d';' -f1)
			h_pix=$(printf "$x_pixel"| cut -d';' -f2)
			w_mil=$(printf "$x_milli"| cut -d';' -f1)
			h_mil=$(printf "$x_milli"| cut -d';' -f2)
			## formule
			dpi_w=$(echo "($w_pix*25.4+$w_mil-1)/$w_mil"| bc -l| sed -n "s/\..*$//p")
			dpi_h=$(echo "($h_pix*25.4+$h_mil-1)/$h_mil"| bc -l| sed -n "s/\..*$//p")
			## inclusion
			x_dpi=$dpi_w" x "$dpi_h
		else
			## fallback value.
			x_dpi="96 x 96"
		fi
		## get display current def and freq
		x_plore=$(xrandr --current | grep -m1 "*")
		def=$(printf "$x_plore"| awk '{print $1}')
		freq=$(printf "$x_plore"| sed -En "s/.* ([0-9]{2,3}\.[0-9]{2})\*.*$/\1/g;p")
		freq_prim=$(printf "$freq"| cut -d. -f1)
		freq_scnd=$(printf "$freq"| cut -c 4)
		if [ $freq_scnd -gt 5 ]; then freq=$(($freq_prim+1)); else freq=$freq_prim; fi
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			if [ $opti_preset = 1 ]; then
				cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
					   Option	"PrimaryGPU" "yes"
					   Option	"AllowEmptyInitialConfiguration"
				XF
			fi
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				   Option	"NoLogo" "true"
				#   Option	"DPMS"
				   Option	"UseEDID" "true"
				   Option	"ProbeAllGpus" "false"
				#   Option	"UseDisplayDevice" "none"
				#   Option	"ConnectedMonitor" "DFP"
				#   Option	"DynamicTwinView" "false"
				#   Option	"AddARGBGLXVisuals"
				   Option	"SLI" "Off"
				#   Option	"MultiGPU" "Off"
				   Option	"BaseMosaic" "off"
				#   Option	"UseEdidDpi" "false"
				   Option	"Coolbits" "8"
				#   Option	"AllowGLXWithComposite" "true"
				#   Option	"TripleBuffer" "true"
				   Option	"Stereo" "0"
				   Option	"RenderAccel" "true"
				   Option	"DPI" "$x_dpi"
				   Option	"nvidiaXineramaInfoOrder" "DFP-0"
				   Option	"metamodes" "${def}_${freq} +0+0"
				EndSection

			XF
		else
		## here second card option merge to Device section.
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				EndSection

			XF
		fi
	}
	sec_screen(){
		cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "Screen"
				Identifier	"Screen${dev_n[$e]}"
				Device	"Device${dev_n[$e]}"
				Monitor	"Monitor${dev_n[$e]}"
				DefaultDepth	24
			EndSection

		XF
	}
	x_conf_dir=/etc/X11
	mv -f $x_conf_dir/xorg.conf.nvidia $x_conf_dir/xorg.conf.nvidia.bak

	sec_files
	sec_layout
	for e in $pci_dev_nb; do
		 sec_device
		 sec_option_df
		 sec_screen
	done
	## xorg conf is secondary in optimus case because iGPU is the main device.
	[ $optimus -gt 0 ] || ln -sfr $x_conf_dir/xorg.conf.nvidia $x_conf_dir/xorg.conf
}
## ### AFTER INSTALL ###
clean_old_version(){ # post install part.
	y_text="Cleaning old ${j}$(old_version)${end} source and DKMS tree"
	pulse=1; log=0; hold=0 ; hide_txt=0; [ $hold = 1 ] && win_log_options
	# syntax: { timeout=xx ;{ [script] }& eval lpid=$!; y_pulse; } | win_yad_progress
	{	timeout=30
	{	unset drv_srctimeout=30
		dkms_clean(){
			$p_dkms remove -m nvidia/$(old_version) --all
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
				rm -rf /var/lib/dkms/$rep_clean/$(old_version)
			fi
		}
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
		fi
		for rep_clean in ${drv_src[*]}; do
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
# 				progress_msg(){ echo "# ${v}($m sec.) Cleaning ${y}$rep_clean${end} ${j}$(old_version)${end} DKMS tree${end}"; echo "$m"; }; m=1
# 				do_slp=1; progress "$(dkms_clean)"
# 				echo "# ${v}Cleaning ${y}$rep_clean${end} ${j}$(old_version)${end} DKMS tree${end}"; sleep 2
				echo "# Cleaning $rep_clean $(old_version) DKMS tree"; sleep 2
				dkms_clean
			fi
			if [ -d /usr/src/$rep_clean-$(old_version) ]; then
# 				echo "# ${v}Cleaning ${y}$rep_clean${end} ${j}$(old_version)${end} source tree${end}"; sleep 2 # zenity
				echo "# Cleaning $rep_clean $(old_version) source tree"; sleep 2
				rm -rf /usr/src/$rep_clean-$(old_version)
			fi
		done
		}& eval lpid=$! ; y_pulse ;} | win_yad_progress
# 	) | $d_zen --width=450 $win_icon --title="$_zen_title" --progress  \
# 		--text="${v}Cleaning old ${j}$(old_version)${end} source and DKMS tree${end}" --auto-close
# 	} | win_yad_progress
}
post_install(){ # PROGRESS : TODO optimus section.
	echo "# "
	echo "# ${v}${j}($n%)${end} - ${mf}Post install routines${end}${end}"; sleep 2
	echo "# ${v}${j}($n%)${end} - Create XORG config file for Nvidia device${end}"; sleep 2
	xorg_conf # 8
	n=$[ $n+2 ]; echo "$n" # 8
	echo "# ${v}${j}($n%)${end} - Librairies sub routines${end}"; sleep 2
	echo "# ${j}($n%)${end}${ge}${sf} * Linking $nv_root libs to system${end}${end}"; sleep 2
	n=$[ $n+2 ]; echo "$n" # 9
	if [ ! -s /etc/ld.so.conf.d/nvidia-$master$ELF_TYPE ]; then
		unset elf_lib_list
		elf_lib_list=("$ELF_64" "$ELF_32")
		for nv_lib in "${elf_lib_list[@]}"; do
			ld_conf=$nv_root/nvidia/$master$nv_lib
			[[ $nv_lib == 64 ]]|| nv_lib=32
			nv_lib_file='/etc/ld.so.conf.d/nvidia-'$master$nv_lib'.conf'
			printf "$ld_conf" > $nv_lib_file
		done
		report_log+=("${vB}Post install:\t\t${end}${gB} ldconfig\t\t${end}> ${y}Nvidia librairies linked to system${end}.\n")
	fi
	# libnvidia-wfb.so is broken with old version, need to be replace with xorg server libwfb.so. If exist in nvidia's dirs.
	if [ $(chk_version) -le 418 ]; then
		## 418 and above don't need nvidia libwfb.so to be replace anymore
		if [ -e $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so ]; then
			mv -f $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so.orig
			ln -sf /usr/$master$ELF_64/xorg/modules/libwfb.so $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so
			report_log+=("\t\t\t${gB} libwfb\t\t${end}> ${y}link to system${end}.\n")
		fi
	fi
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/install-$new_version.log; fi
	echo "# ${j}($n%)${end}${ge}${sf} * Fixing broken libs and links if needed${end}${end}"; sleep 2
	elf_lib=( "$master$ELF_64" "$master$ELF_32" )
	## Remove previous version libs if needed.
	[ $wayland_link = 1 ] && wayland=',wayland-client'
	unset lib_x fixed_lib_log
	for lib_X in "${elf_lib[@]}"; do
		for old_lib in {allocator,fbc,cfg,gtk2,gtk3,pkcs11,pkcs11-openssl3,vulkan-producer$wayland}; do
			if [ -s $install_dir/$lib_X/libnvidia-$old_lib.so.$(old_version) ]; then
				rm_lib=libnvidia-$old_lib.so.$(old_version)
				rm -f $install_dir/$lib_X/$rm_lib
				if [ -h $install_dir/$lib_X/libnvidia-$old_lib.so ]||[ -h $install_dir/$lib_X/libnvidia-$old_lib.so.1 ]; then
					rm -f $install_dir/$lib_X/libnvidia-$old_lib.so*
				fi
				fixed_lib+=("$old_lib")
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ "$lib_X" =~ "64" ]]; then lib_x="x86_64"; else lib_x="i386"; fi
			fixed_lib_log+=(" cleaned ($lib_x)\n")
		fi
	done
		## send report from previous list before.
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			for line in ${fixed_lib_log[*]}; do
				report_log+=("\t\t\t${gB} lib fix\t\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
			done
		fi
		## fix lib64 prefix libs links if needed
		unset fixed_lib_log
		r_dir=$install_dir/$master$ELF_64
		## wayland on vulkan libs do not install by default, this not critical.
		## then we inquire for any broken link in install dir.
		## and add any missing libs if needed.
		## wayland libs can broke some software display, thus this is optional.
# 		[ $wayland_link = 1 ] && wayland=',wayland-client'
		for links in {allocator,fbc,cfg,gtk2,gtk3,pkcs11,pkcs11-openssl3,vulkan-producer$wayland}; do
			if [ ! -e $r_dir/libnvidia-$links.so.$(new_version) ]; then
				cp -f $nvtmp/$extracted_release/libnvidia-$links.so.$(new_version) $r_dir/
			fi
			if [ ! -h $r_dir/libnvidia-$links.so.1 ]; then
				if [ -f $r_dir/libnvidia-$links.so.$(new_version) ]; then
					ln -sfr $r_dir/libnvidia-$links.so.1 $r_dir/libnvidia-$links.so
					ln -sfr $r_dir/libnvidia-$links.so.$(new_version) $r_dir/libnvidia-$links.so.1
					fixed_lib_log+=("$links,")
				fi
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ $ELF_64 =~ "64" ]]; then elf_x='(x86_64)'; else elf_x='(i386)'; fi
			fixed_lib_log+=(" links updated $elf_x")
			report_log+=("\t\t\t${gB} link fix\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
		fi
	## symlink libvdpau_nvidia to system
	if [ $(chk_version) -lt 430 ]; then
		for lib_V in "${elf_lib[@]}"; do
			link_v=$(file -p /usr/$lib_V/vdpau/libvdpau_nvidia.so.1| grep -c "nvidia.$(new_version)")
			if [ $link_v -eq 0 ]; then
				[ -d /usr/$lib_V/vdpau ]|| mkdir -p /usr/$lib_V/vdpau
				ln -sfr /usr/$lib_V/vdpau/libvdpau_nvidia.so /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
				ln -sf $nv_root/nvidia.$(new_version)/$lib_V/vdpau/libvdpau_nvidia.so.$(new_version) /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
			fi
		done
	fi
	n=$[ $n+2 ]; echo "$n" # 10
	## link now all new libraries and nvidia-application-profiles-key-documentation to system.
	if [ -d /usr/share/nvidia ]; then
		cp -rf /usr/share/nvidia/* $profile_path
		rm -rf /usr/share/nvidia
		ln -sf -T $profile_path /usr/share/nvidia
	fi
	echo "# ${j}($n%)${end}${ge}${sf} * Validating new librairies (ldconfig)${end}${end}"; sleep 2
	ldconfig
	## old driver version (here optimus laptop case) doesn't create nvidia devs. ATTENTION IN PROGRESS
	if [ $(chk_version) -le 430 ]; then
		## partly inspired by Alexandre Freire dos Santos work in Batocera.PLUS
		## https://github.com/AlexxandreFS/Batocera.PLUS/blob/master/script/nvidia-driver-udev-rules.sh
		## thanks to him.
		unset nv_mod_opts
		test $use_drm -eq 1 && nv_mod_opts+=('-m')
		test $use_uvm -eq 1 && nv_mod_opts+=('-u')
		for dev in ${dev_id[@]}; do
			#SUPPORTED_GPUS_JSON=$nvi_docs'/supported-gpus/supported-gpus.json'
			UDEV_RULES='/etc/udev/rules.d/01-nvidia-driver.rules'
			test -f ${UDEV_RULES} || touch ${UDEV_RULES}
			cat <<-UDEV >> ${UDEV_RULES}
			ACTION=="add", DEVPATH=="/bus/pci/drivers/nvidia", RUN+="$d_nv_probe -c 0 ${nv_mod_opts[*]}"
			UDEV
		done
	fi
	## here systemctl power management.
	if [ $opti_preset = 1 ]&&[ $enable_powerd = 1 ]; then
		cp -f $install_dir/share/doc/NVIDIA_GLX-1.0/nvidia-dbus.conf to /etc/dbus-1/system.d
		ln -sf $install_dir/bin/nvidia-powerd /usr/bin/nvidia-powerd
		systemctl enable nvidia-powerd.service
	fi
	## if driver version greater than 430.xx, backup xorg modules content to default libs dirs. Just in case.
	if [ $(chk_version) -ge 430 ]; then
		if [ -s $xorg_def/modules/extensions/libglxserver_nvidia.so ]; then
			mkdir -p $nv_root/nvidia.$(new_version)/xorg/modules/{extensions,drivers}
			cp -rf $xorg_def/modules/extensions/libglxserver_* $nv_root/nvidia.$(new_version)/xorg/modules/extensions/
			cp -f $xorg_def/modules/drivers/nvidia_drv.so $nv_root/nvidia.$(new_version)/xorg/modules/drivers/
		fi
	fi

	n=$[ $n+2 ]; echo "$n" # 11
	echo "# ${v}${j}($n%)${end} - Blacklisting and other routines${end}"; sleep 2
	echo "# ${j}($n%)${end}${ge}${sf} * Blacklist conf update if needed${end}${end}"; sleep 2
	#nv_blacklist_modules_conf
	n=$[ $n+2 ]; echo "$n" # 13
	echo "# ${j}($n%)${end}${ge}${sf} * GRUB conf update if needed${end}${end}"; sleep 2
	blacklist_and_grub_set
	n=$[ $n+2 ]; echo "$n" # 12

	## NVIDIA_GLX-1.0 changelog file is replace even if the file is older than the installed one.
	## To prevent overwwrite in case of downgrade, file copied in zenvidia doc dir, then update
	## if changelog file is newer than the previous.
	if [ -f $zen_docs/NVIDIA_Changelog ]; then
		if [ $zen_docs/NVIDIA_Changelog -ot $nvi_docs/NVIDIA_Changelog ]; then
			cp -f $nvi_docs/NVIDIA_Changelog $zen_docs/
		fi
	else
		cp -f $nvi_docs/NVIDIA_Changelog $zen_docs/
	fi
	## clean old install dir
	if [ -d $nv_root/nvidia.$(new_version) ]; then
		if [ -d $nv_root/nvidia.$(old_version) ]; then
			echo "# ${v}${j}($n%)${end} - Cleaning old $(old_version) source and DKMS tree if needed.${end}"; sleep 2
			rm -rf $nv_root/nvidia.$(old_version)
			report_log+=("\t\t\t${gB} old version\t\t${end}> ${y}$(old_version) directory cleaned${end}.\n")
			clean_old_version
			report_log+=("\t\t\t${gB} old source\t\t${end}> ${y}All $(old_version) version cleaned${end}.\n")
			n=$[ $n+2 ]; echo "$n" # 14
		fi
	fi
}

## COMPIL & COMPIL CONF TOOLS ###
## check for patch in new version.
nv_build_options(){
	## nvidia build evolve in time, there need to set different options
	## along side versions.
	# define driver file locations
	nv_xorg_dir=$nv_root/nvidia.$(new_version)/xorg
	xorg_def=/usr/$master$ELF_64/xorg
	kernel_path=/lib/modules/$KERNEL/$(module_dest_location)
	no_check='--no-check-for-alternate-installs'
	no_net='-N'
	[ $use_indirect = 0 ]|| force_glvnd='--force-libglx-indirect'
	[ $use_glvnd = 0 ]|| add_glvnd='--install-libglvnd'
	## since 515 series, open drivers are available. Default is none.
	extract_open=0
	ask_open_build=0
	if [ $(chk_version) -ge 390 ]; then
		compat32='--compat32-libdir='$master$ELF_32
		compat64='--opengl-libdir='$master$ELF_64
		gl_headers='--opengl-headers'
		no_net=''
	fi
	if [ $(chk_version) -ge 410 ]; then
		gl_headers=''
	fi
	if [ $(chk_version) -ge 430 ]; then
		nv_xorg_dir=$xorg_def
	fi
	if [ $(chk_version) -ge 430 ]; then
		wine_special='--wine-prefix='$nv_root'/nvidia.'$(new_version)
	fi
	if [ $(chk_version) -ge 515 ]; then
		extract_open=1; ask_open_build=1
		enable_powerd=1
	fi
}
nv_cmd_dkms_conf(){
	## check if source dir exit
	chk_dirs(){ [ -d /usr/src/$_src-$(new_version) ]||mkdir -p /usr/src/$_src-$(new_version); }
	## special IGNORE_PREEMPT_RT_PRESENCE script install.
	## add a pre install script for further kernel update through dkms.
	chk_RT(){
		if [ $is_RT -eq 1 ]; then
			if [ ! -e /usr/src/$_src-$(new_version)/nvidia.sh ]; then
				cat <<-SCP > /usr/src/$_src-$(new_version)/nvidia.sh
				#! /bin/bash

				if [ \$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$(uname -r)) -gt 0 ]; then
					export IGNORE_PREEMPT_RT_PRESENCE=1
				fi
				SCP
				chown root:root /usr/src/$_src-$(new_version)/nvidia.sh
				chmod 744 /usr/src/$_src-$(new_version)/nvidia.sh
			fi
		fi
	}
	# Create DKMS conf
	echo "# ${v}${j}($n%)${end} - Create DKMS conf file...${end}"; sleep 1
	## loop between open and private.
	if [ $(chk_version) -le 355 ]; then
		_src='nvidia'
		chk_dirs
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' KERNEL_UNAME=\${kernelver} modules"
		CLEAN="'make' clean"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"
		EOT
		if [ $use_uvm = 1 ]; then
			cat <<-EOT >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[1]="\${PACKAGE_NAME}-uvm"
			BUILT_MODULE_LOCATION[1]="uvm/"
			DEST_MODULE_LOCATION[1]="/$(module_dest_location)"
			EOT
		fi
	fi
	if [ $(chk_version) -lt 515 ]; then
		_src='nvidia'
		chk_dirs
		## dkms config part.
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' IGNORE_CC_MISMATCH='$gcc_mismatch' KERNEL_UNAME=\${kernelver} modules"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

		EOT
		o=1
		mods_list+=( "uvm" )
		mods_list+=( "modeset" )
		mods_list+=( "drm" )
		for mods in ${mods_list[@]}; do
			cat <<-EOT >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
			DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"
			EOT
			((o++))
		done
	fi
	## test if version support open driver version.
	if [ $(chk_version) -ge 515 ]; then
		unset drv_src
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
			AUTOINSTALL='AUTOINSTALL="yes"'
		fi
		for _src in ${drv_src[@]}; do
			chk_dirs
			chk_RT
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL=''; else AUTOINSTALL='AUTOINSTALL="yes"'; fi
				else
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL='AUTOINSTALL="yes"'; else AUTOINSTALL=''; fi
				fi
			fi
			unset mods_list
			if [ $is_RT -eq 1 ]; then
				PRE_BUILD='PRE_BUILD="nvidia.sh"'
			fi
			cat <<-EOT > /usr/src/$_src-$(new_version)/dkms.conf
			PACKAGE_NAME="nvidia"
			PACKAGE_VERSION="$(new_version)"
			$PRE_BUILD
			$AUTOINSTALL
			MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' \\
			IGNORE_CC_MISMATCH='$gcc_mismatch' \\
			KERNEL_UNAME=\${kernelver} modules $POST_BUILD"

			BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
			DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

			EOT
			o=1
			mods_list+=( "uvm" )
			mods_list+=( "modeset" )
			mods_list+=( "drm" )
			for mods in ${mods_list[@]}; do
				cat <<-EOT >> /usr/src/$_src-$(new_version)/dkms.conf
				BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
				DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"

				EOT
				((o++))
			done
		done
	fi
}
nv_dkms_mok_key(){ # TODO Use distro key
	## something can go wrong during module signing, need to figure out.
	# 	/lib/modules/6.1.10-100.fc36.x86_64/build/scripts/sign-file sha512 /var/lib/dkms/mok.key /var/lib/dkms/mok.pub /var/lib/dkms/nvidia/390.157/build/nvidia.ko
	# 	strip -g /var/lib/dkms/nvidia/390.157/build/nvidia.ko

	## for an unknown reason (at least not found) it happens that DKMS MOK keys are not generated.
	## and prevent DKMS compilation to succeed. Then, if not found we're create new self-signed ones.
	mok_signing_key="/var/lib/dkms/mok.key"
	mok_certificate="/var/lib/dkms/mok.pub"
	## this part is more or less taken from dkms script. Thankfully.
	if [ ! "$mok_signing_key" ] || [ ! "${mok_certificate}" ]; then
		echo "# ${v}${j}($n%)${end} - DKMS MOK key/certificate are missing, generating new one for modules signin process.${end}"
		$d_ssl req -new -x509 -nodes -days 36500 -subj "/CN=DKMS module signing key" \
		-newkey rsa:2048 -keyout "$mok_signing_key" \
		-outform DER -out "$mok_certificate" &>/dev/null
		if [ ! -f "$mok_signing_key" ]; then
			echo "# ${r}${j}($n%)${end} - MOK $mok_signing_key key not found and/or can't be generated, modules won't be signed${end}"
			## send ERROR and abort.
			w_text=$( cat <<-ERROR
				${r}MODULES SIGNATURE ERROR${end}.
				$(new_version) compilation can't be done successfully.

				$mok_signing_key and $mok_certificate can't be found
				and attempt to create new ones failed.

				Very sorry about that.
			ERROR
			)
			$d_zen --width=450 --title="$_zen_title" $win_icon $icon_name=xkill --error --no-wrap \
			--ok-lable="OK" --text="${v}$w_text${end}"
			if [ $zen_pid -gt 0 ]; then kill $zen_pid; else kill $yad_pid; fi
		fi
		$d_sys restart dkms.service
	fi
}
build_dkms(){ # ALERT TMP_C
	## test and fix mok keys if needed.
 	nv_dkms_mok_key
	unset drv_src
	## all script here is inserted in xterm for better display of process.
	## known bug : it appears on unknown reason that DKMS script do not install modules.
	## exploring some solutions, but not sure of them.
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	show_dkms=' (dkms)'
	[ -f $tmp_b ] && echo -e "show_dkms=' (dkms)'" >> $tmp_b
		mod_move(){
			## if modules detected in dkms version tree, move.
			if [ -f nvidia.*[ko\|ko.xz] ]; then
				echo -e "#${r} Error : No $_dkms ${j}$(new_version)${end} modules found in kernel path $kernel_path.${end}"
				sleep 2
				echo -e "#${v} Workaround : Copying ${y}$_dkms${end} modules in $kernel_path from DKMS repository.${end}"
				#echo -e "# moving"
				echo -e "# ${ge}* Compressing $_dkms modules if needed."
# 				test $is_RT -eq 0 ||
				xz -T12 *.ko | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				cp -vf nvidia.ko.xz $kernel_path/nvidia.ko.xz
				if [[ -s nvidia-uvm.ko.xz ]]; then cp -vf nvidia-uvm.ko.xz $kernel_path/nvidia-uvm.ko.xz; fi
				if [[ -s uvm/nvidia-uvm.ko.xz ]]; then cp -vf uvm/nvidia-uvm.ko.xz $kernel_path/nvidia-uvm.ko.xz; fi
				if [[ -s nvidia-modeset.ko.xz ]]; then cp -vf nvidia-modeset.ko.xz $kernel_path/nvidia-modeset.ko.xz; fi
				if [[ -s nvidia-drm.ko.xz ]]; then cp -vf nvidia-drm.ko.xz $kernel_path/nvidia-drm.ko.xz; fi

				if [[ -s $kernel_path/nvidia.*[ko\|ko.xz] ]]; then
					echo -e "# ${ge}* Exec $KERNEL modules depmod"
					sleep 2
					progress_msg(){ echo " * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
					progress /usr/sbin/depmod -an $KERNEL | \
					while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
					# rm -f $tmp_c # ALERT
					$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
					pass=$?
				else
					pass=1
				fi
				if [ $pass = 0 ]; then
					vermagic=$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\|ko.xz]| awk '{print $1}')
					echo -e "# ${y}* All Clear modules loaded ($(new_version) modules moved from dkms dir)${end}."
					echo -e "pass=$pass" >> $tmp_b
				else
					echo -e "#${r} --- ERROR ---  Driver not found in path --- ${end}"
					echo -e "pass=1" >> $tmp_b
					echo -e "# ${r}* You can try ${y}Update Driver${end} menu > ${y}Update from source${end} as workaround install${end}"
					with_error="${r} (ERROR, safe modules not copied)${end}"
				fi
			else
				echo -e "#${r} --- ERROR ---  Driver not found in path ---- ${end}"
				echo -e "pass=1" >> $tmp_b
				echo -e "# ${r}* You can try ${y}Update Driver${end} menu > ${y}Update from source${end} as workaround install${end}"
				with_error="${r} (ERROR, no safe modules found)${end}"
			fi
		}
		mod_check(){
		## when previous driver is higher than in install one's, dkms, even if build and install return succes, doesn't install
		## the drivers. Thus, we install those driver manually with cp.
			if [ -d /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module ]; then
				pushd /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module
				echo -e "# ${y}* Checking $(new_version) in DKMS $KERNEL path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				mod_move
				popd
			elif [ -d /var/lib/dkms/$_dkms/$(new_version)/build ]; then
				pushd /var/lib/dkms/$_dkms/$(new_version)/build
				echo -e "# ${y}* Checking $(new_version) in DKMS $KERNEL build path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				mod_move
				popd
			else
				echo -e "# ${r}* No modules found in DKMS build path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				echo -e "# ${r}* You can try ${y}Update Driver${end} menu > ${y}Update from source${end} as workaround install${end}"
				with_error="${r} (ERROR, no modules found)${end}"
			fi
		}
		remove_add(){
			# ATTENTION Remove driver tree only ? or remove all ?
			remove_seq(){
				#$headings
				echo -e "#${v} Removing previous ${j}$(old_version)${end} ${y}$_dkms${end} DKMS modules from DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				#echo -e "# remove $_dkms"
				if [ $(nv_old) -gt $(nv_new) ]; then
					#echo -e "# remove seq all"
					$p_dkms remove -m $_dkms/$(old_version) --all | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
				else
					#echo -e "# remove seq kernel"
					$p_dkms remove -m $_dkms/$(old_version) -k $KERNEL | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
				fi
				sleep 2
			}
			add_seq(){
				echo -e "#${v} Add ${j}$(new_version)${end} ${y}$_dkms${end} modules to DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				#echo -e "# add $_dkms"
				$p_dkms add -m $_dkms/$(new_version) -k $KERNEL | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
			}
			## remove previous known and unknown version if any before installing new one.
			## TODO add a more strict filter on already present modules.
			mod_installed=$(mod_installed)
			old_inst(){ # used by nv_build_dkms only
				test "$mod_installed" && sed -n "s/\.//g;p" <<< $mod_installed || echo "0"
			}
			## is a old modules installed ?
			if [ $(nv_old) -gt 0 ] && ( [ $(nv_old) = $(old_inst) ] && [ $(nv_old) -ne $(nv_new) ] ); then
					#echo -e "# remove seq 1"
					remove_seq
			else
			## if not :
			## is the modules version present in dkms tree ?
				if [ "$(old_inst)" ] && [ $(old_inst) -gt 0 ]; then
					## check its status.
					if [ $($p_dkms status -m $_dkms/$mod_installed -k $KERNEL| grep -E -c "built|installed") -gt 0 ]; then
						# if build or installed, and not same as new one, check status ans 'remove' it.
						if [[ $(old_inst) -ne $(nv_new) ]]; then
							#echo -e "# remove seq 2"
							remove_seq
						fi
					else
						## if not in the dkms tree, just remove them, and make a depmod to clear things.
						if [ $(old_inst) -ne $(nv_new) ]; then
							echo -e "#${ge}* Removing out of DKMS tree $mod_installed $_dkms from kernel modules path.${end}"
							echo $(($n+$o)); o=$(($n+$o)) #3
							sleep 2
							#echo -e "# ** rm mods"
							rm -f $kernel_path/*
							echo -e "# ${ge}* Executing clean depmod before next step.${end}"
							sleep 2
							#echo -e "# ** exec depmod"
							progress_msg(){ echo " * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
							progress /usr/sbin/depmod -an $KERNEL | \
							while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
							# rm -f $tmp_c # ALERT
							#/usr/sbin/depmod -a $KERNEL
							echo -e "# ${ge}* Done.${end}"
							sleep 2
						fi
					fi
				else
					echo -e "# ${ge}* No previous driver found. Installing $(new_version) $_dkms.${end}"
					echo $(($n+$o)); o=$(($n+$o)) #3
					sleep 2
				fi
			fi
			if [ $($p_dkms status -m $_dkms/$(new_version) -k $KERNEL| grep -E -c "added|built|installed") -eq 0 ]; then
				add_seq
			fi
		}
		build_seq(){
			build_seq_1(){
				echo -e "#${v} Building ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				#echo -e "# build $_dkms"
				if [ -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module/nvidia.*[ko\|ko.xz] ]; then
					echo -e "# ${y}* All Clear for $(new_version) $_dkms already build.${end}"
				else
					$p_dkms build -m $_dkms/$(new_version) -k $KERNEL $force 2>&1 | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
					echo -e "# ${y}* All Clear for $(new_version) $_dkms is build.${end}"
				fi
				echo -e "# ${y} ---  $_dkms script ended  --- ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #6
				sleep 2
			}
			build_seq_2(){
				echo -e "#${v} Build and Install ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				#echo -e "# install classic $_dkms"
				$p_dkms install -m $_dkms/$(new_version) -k $KERNEL $force 2>&1 | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
				$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
				pass=$?
				echo -e "pass=$pass" >> $tmp_b
				echo -e "#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} modules in $kernel_path ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #6
				if [ $pass = 0 ]; then
					echo -e "# ${ge}* Check validated (pass=$pass)${end}"
				else
					echo -e "# ${ge}* Check unvalidated (pass=$pass)${end}"
				fi
				sleep 2
				if [ $pass = 1 ]; then
					mod_check
				else
					vermagic=$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\|ko.xz]| awk '{print $1}')
					echo -e "# ${y}* All Clear for $(new_version) $_dkms in $KERNEL kernel.${end}"
					echo $(($n+$o)); o=$(($n+$o)) #7
					sleep 2
				fi
				echo -e "# ${y} ---  $_dkms script ended  --- ${end}"
			}
			if [[ $_dkms =~ ^open ]]; then
				if [ $use_open = 0 ]; then
					build_seq_1
				else
					build_seq_2
				fi
			elif [[ $_dkms =~ ^nvidia ]]; then
				if [ $open_drv = 1 ]; then
					if [ $use_open = 0 ]; then
						build_seq_2
					else
						build_seq_1
					fi
				else
					build_seq_2
				fi
			fi
		}
		post_treatment(){
			echo -e "#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} build log presence${end}"
			echo $(($n+$o)); o=$(($n+$o))
			if [ -s /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log ]; then
				test -d $nvlog/dkms/$_dkms/ || mkdir -p $nvlog/dkms/$_dkms/
				cp -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log $nvlog/dkms/$_dkms/
				#echo -e "# copy log"
				make_log_file=$nvlog/dkms/$_dkms/make.log
				echo -e "make_log_file=$make_log_file" >> $tmp_b
				echo -e "# ${ge}* $_dkms $(new_version) log found.${end}"
				echo -e "# ${ge}* $_dkms make log copied to $make_log_file.${end}"
			else
				echo -e "# ${ge}* No $(new_version) $_dkms build log found.${end}"
			fi
			if [[ $_dkms =~ ^open ]]; then sleep 4; else sleep 2; fi
		}
		n=15
		o=0
		test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ]
		#set -x
		for _dkms in ${drv_src[@]} ; do
			echo -e "#${v}${mf} Compiling ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules ${end}${end}"
			echo $(($n+$o)); o=$(($n+$o)) #1
			echo -e "#${y} ---  $_dkms script start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) #2
			sleep 2
			remove_add
			build_seq
			post_treatment
			echo -e "# "
		done
		echo -e "#${v} Done$with_error${end}"
		echo -e "# "
		echo -e $esc_message
		$x_sleep
		echo 100
}
nv_build_dkms(){
 	if [ $log = 1 ];then
		echo -e "# ${v}${j}($n%)${end} - Build and install DKMS modules...${end}"; sleep 1
	else
		echo -e "# Build and install DKMS modules."; sleep 1
	fi
# 	win_log_options
# 	build_dkms | \
# 	$d_yad --width=600 --height=300 --title "Zenvidia" --window-icon=$img_zen_desktop --progress --center --hide-text \
#  	--enable-log='' --log-expanded --log-height=300 $x_hold \
#  	--text="${v}Installing ${j}$(new_version)${end} driver over ${y}$KERNEL${end} kernel with DKMS${end}"
 	pulse=0; log=1; hold=1 ; hide_txt=1 ;[ $hold = 1 ] && win_log_options #; colors=1
 	y_text="Installing ${j}$(new_version)${end} driver over ${y}$KERNEL${end} kernel with DKMS"
#  	build_dkms | win_yad_log
 	{ build_dkms; } | win_yad_progress
}
build_source(){ # ALERT TMP_C
	unset drv_src
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	[ -f $tmp_b ]&& echo -e "show_dkms=' (from source)'" > $tmp_b
	## prepare modules signing (with dmsk mok files)
	nv_dkms_mok_key
	module_signing(){
		if [ -f "$(find -L $kernel_src -name "sign-file")" ]; then
			## list modules.
			for mod in $(ls -1 *.ko); do
				echo -e "# ${ge}* Signing $mod ...${end}";
				sleep 1
				## find the sign-file script in kernel source
				$(find -L $kernel_src -name "sign-file") sha512 $mok_signing_key $mok_certificate $mod
				## strip on uncompressed modules only
				strip -g $mod
			done
		fi
	}
	copy_mods(){
		echo -e "#${v} $seq_type ${j}$(new_version)${end} ${y}$module${end} in $install_path:${end}"; echo $(($n+$o)); o=$(($n+$o)) # 5
		sleep 2
		test -d $install_path || mkdir -p $install_path
		echo -e "# ${ge}* Compressing $module modules${end}" # 7
# 			pushd $install_path
# 			test $is_RT -eq 0 ||
		xz -T12 *.ko | \
		while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
		echo -e "# ${ge}* Copying $module modules in $install_path${end}"; echo $(($n+$o)); o=$(($n+$o)) # 6
# 		echo -e "# ${ge}* Making $module module copy.${end}" # 7
			cp -f nvidia.ko.xz $install_path/nvidia.ko.xz
			if [[ -s nvidia-uvm.ko.xz ]]; then cp -f nvidia-uvm.ko.xz $install_path/nvidia-uvm.ko.xz; fi
			if [[ -s uvm/nvidia-uvm.ko.xz ]]; then cp -f uvm/nvidia-uvm.ko.xz $install_path/nvidia-uvm.ko.xz; fi
			if [[ -s nvidia-modeset.ko.xz ]]; then cp -f nvidia-modeset.ko.xz $install_path/nvidia-modeset.ko.xz; fi
			if [[ -s nvidia-drm.ko.xz ]]; then cp -f nvidia-drm.ko.xz $install_path/nvidia-drm.ko.xz; fi
			## compress modules.
# 			popd
			if [ $dep_check = 1 ]; then
				echo -e "# ${ge}* Executing $module $KERNEL depmod${end}"
				#/usr/sbin/depmod $KERNEL -a
# 				$( exec_depmod "$KERNEL" )
				progress_msg(){ echo " * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
				progress /usr/sbin/depmod -an $KERNEL | \
				while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
				# rm -f $tmp_c # ALERT
			fi
	}
	mod_check(){
		if [ -e /usr/src/$module-$(new_version)/nvidia.ko ]; then
			echo -e "#${y} ---  $module Compilation done  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 4
			sleep 2
			echo -e "#${v} Signing ${j}$(new_version)${end} ${y}$module${end} modules.${end}"
			module_signing; echo $(($n+$o)); o=$(($n+$o))
			if [ $use_open -eq 1 ]; then
				if [[ $module =~ ^open ]]; then
					install_path=$kernel_path
					dep_check=1
					seq_type='Installing'
					copy_mods
				else
					echo -e "#${v} Reserving: Not installing, ${j}$(new_version)${end} ${y}$module${end} is not used.${end}"; echo $(($n*2+$o)); o=$(($n*2+$o)) # 5
					install_path=/usr/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
					dep_check=0
					seq_type='Backup'
					copy_mods
				fi
			else
				if [[ $module =~ ^nvidia ]]; then
					install_path=$kernel_path
					dep_check=1
					seq_type='Installing'
					copy_mods
				else
					echo -e "#${v} Reserving: Not installing, ${j}$(new_version)${end} ${y}$module${end} is not used.${end}"; echo $(($n*2+$o)); o=$(($n*2+$o)) # 5
					install_path=/usr/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
					dep_check=0
					seq_type='Backup'
					copy_mods
				fi
			fi
		else
			echo -e "#${r} ---  ERROR  ---  No modules found in source path  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 4
			with_error=" ${r}with ERRORs${end}"
		fi
	}
	post_treatment(){
		echo -e "#${v} Checking ${j}$(new_version)${end} ${y}$module${end} build log presence.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 8
		if [ -s /usr/src/$module-$(new_version)/make.log ]; then
			[ -d $nvlog/source/$module ]|| mkdir -p $nvlog/source/$module
			cp -f /usr/src/$module-$(new_version)/make.log $nvlog/source/$module
			make_log_file=$nvlog/source/$module/make.log
			[ -f $tmp_b ]&& echo -e "make_log_file=$make_log_file" >> $tmp_b
			echo -e "#${ge} * $module $(new_version) log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
			echo -e "#${ge} * $module make log copied to $make_log_file.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 10
		else
			echo -e "#${ge} * No $(new_version) $module build log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
		fi
		if [ $dep_check = 1 ]; then
			$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
			pass=$?
		else
			pass=0
		fi
		if [ $pass = 0 ]; then
			echo -e "#${ge} * $module control passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
		else
			echo -e "#${ge} * $module control not passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
			echo -e "#${r} ---  ERROR  ---  No modules found in destination path  --- ${end}";
			with_error=" ${r}with ERRORs${end}"
		fi
		[ -f $tmp_b ]&& echo -e "pass=$pass" >> $tmp_b
		if [[ $module =~ ^open ]]; then sleep 4; else sleep 2; fi
	}

	if [ $upgrade_other = 1 ]; then
		make_env='env KERNEL_UNAME='$KERNEL' KERNEL_SOURCES='$kernel_src
	fi
	if [ $(chk_version) -lt 355 ]; then
		opts_355="cd uvm/; make -j$proc; cd ../"
	fi
	n=10
	o=0
	test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ]
	for module in ${drv_src[@]} ; do
		pushd /usr/src/$module-$(new_version)
		sleep 1
		echo -e "# ${v}${mf} Compiling ${j}$(new_version)${end} from ${y}$module${end} modules source:${end}${end}"; echo $(($n+$o)); o=$(($n+$o)) # 1 10
# 		echo -e "# "
		sleep 2
		if [ -d /usr/src/$module-$(new_version) ]; then
			echo -e "#${y} ---  $module compilation start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 2 20
			sleep 2
			echo -e "#${ge} Compilation $make_env.${end}" # 3 30
			$make_env make -j$proc | fmt -w 120 | \
			while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; echo "${line}" &>> make.log; done
			$opts_355
			sleep 2
			mod_check
			sleep 2
			post_treatment
		else
			echo -e "# ${v}Source ${j}$(new_version)${end} ${y}$module${end} unaviable.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 2
			echo -e "# ${v}Check your kernel source three.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 3
			[ -f $tmp_b ]&& echo -e "pass=1" >> $tmp_b
			with_error=" ${r}with ERRORs${end}"
		fi
		make clean
		echo -e "# "
		popd
	done
	echo -e "#${v} Done$with_error.${end}"
	sleep 2
	echo -e "# "
	echo -e $esc_message
	$x_sleep
	echo 100
	. $tmp_b
}
nv_cmd_make_src(){
	echo -e "# Build & install modules from source..."; sleep 1
# 	win_log_options
# 	build_source | \
# 	$d_yad --width=600 --height=300 --title "Zenvidia" $win_icon --progress --center --hide-text \
#  	--enable-log='' --log-expanded --log-height=300 $x_hold \
#  	--text="${v}Installing ${y}$KERNEL${end} kernel modules from ${j}$(new_version)${end} source directory${end}"
 	pulse=0; log=1; hold=1 ; hide_txt=1 ;[ $hold = 1 ] && win_log_options
 	y_text="Installing ${y}$KERNEL${end} kernel modules from ${j}$(new_version)${end} source directory"
#  	build_source | win_yad_log
	{ build_source; } | win_yad_progress
}
nv_cmd_install_driver(){
		## prevent installer to doing think for 'upgrade an other kernel'.
		upgrade_other=0
		if [[ $($d_modinfo -F version nvidia) != $(new_version) ]]; then
			[ -d /usr/src/nvidia-$(new_version) ] ||mkdir -p /usr/src/nvidia-$(new_version)
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel/* /usr/src/nvidia-$(new_version)
			if [ $extract_open = 1 ]; then
				test $ask_open_build -eq 1 && nv_open_modules_set
			fi
			if [ $use_dkms = 1 ]; then
				if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel ]; then
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo "# ${r}${j}($n%)${end} DKMS compilation ERROR !!${end}"; sleep 2
					fi
				fi
			fi
			if [ $use_dkms = 0 ]; then
				echo "# ${v}${j}($n%)${end} - Nvidia MODULES compilation from source...${end}"; sleep 1
				nv_cmd_make_src
			fi
		else
			[ -f $tmp_b ] && echo -e "pass=1" >> $tmp_b
		fi
}
nv_cmd_update(){
	driver_logfile=$nvlog/$(new_version)-$KERNEL.log
	tmp_b=$(mktemp --tmpdir zn_vars.XXX)
	rem_tmp+=("rm -f $tmp_b")
	trap "${rem_tmp[*]}" EXIT
	## check for for patch in new version.
	rt_options
	nv_build_options
	if [ $extract_open = 1 ]; then
		if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open/* /usr/src/open-nvidia-$(new_version)
		fi
	fi
	## check for open modules presence.
	test $ask_open_build -eq 1 && nv_open_modules_set
	if [ $use_dkms = 1 ]; then
		[ $from_install = 1 ] && nv_cmd_dkms_conf
		nv_build_dkms
		. $tmp_b
		make_log=$make_log_file
		if [ $pass -eq 1 ]; then
			echo -e "# DKMS compilation ERROR !!"; sleep 2
		fi
	else
		if [ $use_dkms = 0 ]; then
			echo -e "# Nvidia MODULES compilation from source..."; sleep 1
			nv_cmd_make_src
			. $tmp_b
			make_log=$make_log_file
		fi
	fi
	if [ $pass -eq 0 ]; then
		## rebuild initramfs in case of trouble booting.
		echo -e "# Updating $KERNEL modules."; sleep 1
		$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
		if [ $? = 0 ] ; then
			if [ $exec_mod_tool = 1 ]; then
				echo -e "# Exec $KERNEL modules reload "; sleep 2
				exec_mod_load
			else
# 				if [ $upgrade_other = 1 ]; then
					progress_msg(){ echo -e "# Rebuilding $KERNEL INITRAMFS ($m sec.)"; echo "$m"; }; m=1; do_slp=1
					exec_initramfs
# 				else
# 					echo "# - Exec $KERNEL modules reload "; sleep 2
# 					exec_mod_load
# 				fi
			fi
		else
			echo -e "# ERROR ! $KERNEL modules do not match $(new_version). Abort."; sleep 3; exit 0
		fi
 	fi
 	install_log_messages
 	blacklist_and_grub_set
}
nv_cmd_install_libs(){ # TODO CHECK REGULARY AT DRIVER UPGRADE  ## TODO replace by win_yad_progress
## INFOS ABOUT NVIDIA-INSTALLER OPTIONS :
#  --opengl-prefix=OPENGL-PREFIX
#      The prefix under which the OpenGL components of the NVIDIA driver will be installed; the default is:
#      '/usr'.  Only under rare circumstances should this option be used.  The Linux OpenGL ABI
#      (http://oss.sgi.com/projects/ogl-sample/ABI/) mandates this default value.
# --opengl-libdir=OPENGL-LIBDIR
#      The path relative to the OpenGL library installation prefix under which the NVIDIA OpenGL components will
#      be installed.  The default is 'lib' on 32bit systems, and 'lib64' or 'lib' on 64bit systems, depending on
#      the installed Linux distribution.  Only under very rare circumstances should this option be used.
#  --wine-prefix=WINE-PREFIX
#      The prefix under which Wine components of the NVIDIA driver will be installed.  The default is '/usr'.
#  --wine-libdir=WINE-LIBDIR
#      The path relative to the Wine installation prefix under which Wine components of the NVIDIA driver will be
#      installed.  The default is '<opengl-libdir>/nvidia/wine', where <opengl-libdir> is the path determined for
#      --opengl-libdir above.
#	-b --no-sigwinch-workaround --no-distro-scripts $no_check \	
#	--x-prefix=$xorg_dir --x-module-path=$xorg_dir/modules --opengl-prefix=$croot_all \
#	sh $run_pkg -a $quiet -z -Z --no-x-check --ui=none $unified \
#	--kernel-source-path=$kernel_src --kernel-install-path=$kernel_path  --no-abi-note \
#	sh $run_pkg -s -z -N --no-x-check \
## EXTRA INFOS
#	$nocheck --no-kernel-module --no-opengl-files --skip-module-unload \
#	--no-recursion --opengl-headers --install-libglvnd --glvnd-glx-client --force-libglx-indirect  --opengl-libdir=$master$ELF_64 \
#	--utility-prefix=$install_dir --utility-libdir=$install_dir/$master$ELF_64 \
# 	temp="--tmpdir=$buildtmp"

	y_text="Installing ${j}$(new_version)${end} librairies to $nv_root/nvidia.$(new_version)"
	pushd $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)
	(
	timeout=120
	echo -e "# ${j}<b>Librairies installation in background<§b>${end}"
	echo -e "# ${y}Please wait...${end}"
	$install_bin -s -z $no_net --no-x-check --no-distro-scripts \
	$nocheck --no-kernel-module --skip-module-unload --no-recursion $gl_headers \
	$add_glvnd $force_glvnd --install-compat32-libs \
	--compat32-prefix=$nv_root/nvidia.$(new_version) $compat32 $compat64 \
	--x-prefix=/usr --x-library-path=$nv_root/nvidia.$(new_version) --x-module-path=$nv_xorg_dir/modules \
	--opengl-prefix=$nv_root/nvidia.$(new_version) $wine_special --utility-prefix=$install_dir \
	$docs $profile --tmpdir=$buildtmp --log-file-name=$lib_logfile 2>&1 | fmt -w 100 | \
	while read -r line; do echo -e "# ${y}${sf}${line}${end}${end}"; done & eval lpid=$! ; y_pulse
	echo -e "# "
	echo -e $esc_message
	echo "100"
	) | win_yad_log
	popd
	## link to sys.
	ln -sfr -T $nv_root/nvidia.$(new_version) $nv_root/nvidia
}

## ### INSTALL MODULE AND LIBRARIES PROCESS ###
## ### MAIN SECTION ###
## LOGS ###
install_log_messages(){
	## install log messages
	if [ $pass -eq 0 ]; then
		if [ "$timeout" != '' ];then
			echo "# Modules build done."; sleep 2
		else
			echo "# ${v}${j}($n%)${end} - Modules build done.${end}"; sleep 2
		fi
		report_log+=("${vB}Driver build$show_dkms:\t${end}${gB} success\t\t${end}> ${y}Installation complete with no error${end}\n")
	else
		if [ "$timeout" != '' ];then
			echo "# Modules build ERROR."; sleep 2
		else
			echo "# ${r}${j}($n%)${end} - Modules build ERROR.${end}"; sleep 2
		fi
		report_log+=("${vB}Driver build:\t\t${end}${rB} failure\t\t${end}> ${y}ERROR, 'make' exit with 'failed' state${end}\n")
		warn_log=$( cat <<-ERROR
			${r}MODULES BUILD RETURN ERRORS.${end}.
			$(new_version) compilation failed.
			Source make.log has been saved in <i>$make_log_file</i>.

			Do you want to read $make_log_file ?
		ERROR
		)
# 		$d_zen --width=450 --title="$_zen_title" $win_icon $icon_name=xkill --question --no-wrap \
# 		--ok-label="Yes" --cancel-label="No thanks, shits happens" \
# 		--text="${v}$w_text${end}"
		warn_image='dialog-question'
		qst=1; ok_lbl="Yes!gtk-apply"; cancel_lbl="No thanks, shits happens!gtk-no"; kill_yad=1
		win_yad_warns
# 		fatal_error=$?
		if [ $y_output = 0 ]; then
			$d_zen --width=800 --height=400 --title="$_zen_title" --text-info \
			--ok-label="Close" --cancel-label='' --filename="$make_log_file"
		fi
	fi
	## realtime report messages.
	if [ $is_RT -eq 1 ]; then
		report_log+=("\t\t\t${gB} kernel option\t${end}>${y} Kernel $KERNEL is REALTIME${end}.\n")
	fi
	## open driver install report messages.
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -eq 1 ]; then append="open driver loaded"; else append="close source loaded"; fi
		report_log+=("${vB}Open Driver:\t\t${end}$gB compiled\t\t${end}>${y} $append${end}\n")
	fi
}
install_report_log(){
	## display final message depends of exit status.
# 	$d_zen --title="Zenvidia" --question --no-wrap $win_icon --width=500 \
# 	--text="${j}${bf}$(new_version) Install Report${end}${end}${v}:\n $(cat <<< ${report_log[*]})${end}\n$rep_msg" \
# 	--ok-label="edit now" --cancel-label="edit later"
	$d_yad --title="Zenvidia" --window-icon=$img_zen_desktop --width=500 --borders=20 --splash \
	--text="${j}${bf}Install Report${end}${end}${v}:\n $(cat <<< ${report_log[*]})${end}\n$rep_msg" \
	--button='edit later'!edit-redo-rtl:1 --button='edit now'!dialog-warning:0
	if [ $? = 0 ]; then edit_xorg_conf; fi
}
## ### INITIAL OR UPGRADE INSTALL PROCESS ### ###
install_drv(){ # ALERT TMP_C
	## tell script that all post_install process came from global install.
	from_install=1
# 	## vars for auto confirmation window sets below 'win_confirm'
# 	confirm_msg="$menu_msg\n${v}Installing driver${end} ${j}$(new_version)${end} ${v}for hardware :${end} ${j}$dev_name${end}."
# 	val_confirm="Install"
# 	val_back="Back to Install menu"
# 	val_exit="menu_install"
# 	val_cancel="base_menu" #TEXT
# # 	val_title="$_zen_title"
# 	val_title="Zenvidia"
	## check for for patch in new version.
	nv_build_options
	rt_options
	## define modules to build at compil/dkms time.
	#nv_modules_set
	use_uvm=1
	use_drm=1
# 	win_confirm
	# win_yad_warns
	warn_log=$( cat <<-WRN
		$menu_msg
		${v}Installing driver ${j}$(new_version)${end} for hardware : ${j}$dev_name${end}${end}."
	WRN
	)
	qst=1; ok_lbl='Install!gtk-ok' ; cancel_lbl='Back to main menu!gtk-no' ; kill_yad=0
	win_yad_warns
	if [ $y_output = 1 ]; then base_menu; fi
	# child process doesn't send back install check result, it need to be
	# set in a temp file.
	tmp_b=$(mktemp --tmpdir zn_vars.XXXX)
	# set a second temp file for old-version backup when new modules installed
	tmp_old=$(mktemp --tmpdir zn_vars.XXXX)
	rem_tmp+=("rm -f $tmp_b")
	rem_tmp+=("rm -f $tmp_old")
	trap "${rem_tmp[*]}" EXIT
	# then push version var in second temp to be used as old-version var during installation.
	echo "$($d_modinfo -F version nvidia -k $KERNEL)" > $tmp_old
	if [[ -s $run_pkg ]] ; then
	y_text="Installing ${j}$(new_version)${end} driver version for ${y}$dev_name${end}."
	pulse=0; log=1; hold=1 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{	## set start count
# 		zen_pid=$(pgrep zenity)
# 		yad_pid=$(pgrep yad)
		YAD_PID=$(pgrep -n yad)
		n=1
		## check compatiblity files before executng anything. (4)
		# zen
# 		echo "# ($n%) - Checking compatibility data files"; sleep 2
		# yad
		echo "# ${v}${j}($n%)${end} - ${mf}Compat check and package extraction${end}${end}"; sleep 2
		n=$[ $n+1 ] ; echo "$n"
		echo "# ${v}${j}($n%)${end} - Checking compatibility data files${end}"; sleep 1
		DRV=$(new_version)
		for e in ${pci_dev_nb[@]}; do
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
				$(hardware_compat)
				. $tmp_b
			fi
		done
		echo "$install_msg" ; n=$[ $n+5 ]; echo "$n"; sleep 2 # 1
		#
		## extract .run package for install processes (22)
		extract_build
		test $tmp_c && . $tmp_c
		echo "$n"
		## at install only, nvidia-installer is located in temp rep.
		install_bin="./nvidia-installer"
		echo "# ${v}${j}($n%)${end} - Backing up old driver version, if any${end}"; sleep 2
		#
		# backup driver repository (shits happens!)
		unset report_log
		if [ -d $nv_root/nvidia.$(old_version) ]; then
			bak_version=$(old_version)
			if [[ -s $nvbackup/nvidia.$bak_version.tar.gz ]]; then
				echo "# ${y}${j}($n%)${end} - Driver already backed up. Skipped.${end}"; sleep 1
				report_log+=("${vB}Previous version:\t${end}${gB} passed\t\t${end}> ${y}previously backed up${end}\n")
			else
				backup_old_version
				report_log+=("${vB}Previous version:\t${end}${gB} success\t\t${end}> ${y}$bak_version normal backup process${end}\n")
			fi
		else
			report_log+=("${vB}Previous version:\t${end}${jB} warning\t\t${end}> ${y}no directory to archive.${end}\n")
		fi

		n=$[ $n+5 ] ; echo "$n" # 2 ### ?
		## temp value to n
		p=$n
		echo "# "
		echo "# ${v}${j}($n%)${end} - ${mf}Starting install${end}${end}"; sleep 1
		#
		cd $nv_root
		# nv_cmd processes (install without X crash )
		echo "# ${v}${j}($n%)${end} - Package compil and install${end}"; sleep 1
		#
		# install driver first, then control if everything ok (14 Initramfs)
		nv_cmd_install_driver
		. $tmp_b
		n=$[ $n+5 ]; echo "$n" # 3
		install_log_messages
		if [ $pass -eq 0 ]; then
		## rebuild initramfs or modprobe reload.
		## exec_mod_reload works with update driver tools, but not when fresh install.
		## until a proper method found, initramfs is kept and other syntax only uncommented.
# 			if [ $exec_mod_tool = 1 ]; then
# 				echo "# - Exec $KERNEL modules reload "; sleep 2
# 				exec_mod_load
# 			else
		## progress count depends of CPU calculation power. If CPU is too slow, the cound is too high
		## and goes beyond zenity 100 max count. So, global evaluation is made here.
# 		progress_msg(){ echo "# ($m%) - Exec $KERNEL modules init/reload"; echo "$m"; }; m=$n; do_slp=1
# 		exec_initramfs
# 		. $tmp_c
		progress_msg(){ echo "# ${ge}${sf} * ($m%) Exec $KERNEL modules init/reload${end}${end}"; echo "$m"; }; m=0; do_slp=1
		#
		exec_initramfs
		n=$[ $n+20]
# 			fi
		fi
		echo "$n"
		inst_mod_version=$($d_modinfo -F version nvidia -k $KERNEL)
		## create base libs install directories
		for d in {$nv_root/$predifined_dir,$nv_root/nvidia.$(new_version)/$master$ELF_32,$nv_root/nvidia.$(new_version)/$master$ELF_64,$nv_xorg_dir}; do
			[ -d $d ] || mkdir -p $d
		done
		# nvidia-installer librairies log file
		lib_logfile=$nvlog/libinstall-$(new_version).log
		## install default libs with nvidia-installer
		echo "# "
		echo "# ${v}${j}($n%)${end} - ${mf}Install Nvidia default librairies${end}${end}"; sleep 1
		#
		nv_cmd_install_libs
		## report nvidia installer log message
		if [ $(cat $lib_logfile| grep -c "WARNING") -gt 0 ]; then
			if [ $(cat $lib_logfile| grep "WARNING"| grep -c "libGL.so") -gt 0 ]; then
				report_log+=("${vB}Nvidia-installer:\t${end}${jB} no effect\t\t${end}> ${y}WARNING on missing /usr/lib(32/64)/LibGL.so link,\n\t\t\t\t\t\t    LibGL.so is already link in default nvidia's libraies directory${end}.\n")
			elif [ $(cat $lib_logfile| grep "WARNING"| grep -c "libglvnd") -gt 0 ]; then
				report_log+=("\t\t\t${jB} no effect\t\t${end}> ${y}WARNING missing libglvnd developpement files.${end}\n")
			fi
		fi
		## control if libraries are properly installed
		if [[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| grep -c ".*") -lt 40 ]]|| \
		[[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| grep -c ".*") -lt 40 ]]; then
# 			$d_zen --width=450 --title="$_zen_title" $win_icon --error --no-wrap \
# 			--text="${v}${r}LIBS INSTALL CONTROL RETURN ERRORS.${end}.\nCheck $lib_logfile for more details.${end}"
# 			kill $zen_pid
			warn_log="${v}${r}LIBS INSTALL CONTROL RETURN ERRORS.${end}.\nCheck $lib_logfile for more details.${end}"
			qst=0; kill_yad=1
			warn_image='dialog-warning'
			cancel_lbl="Abort install!gtk-no"
			ok_lbl=''
			win_yad_warns
			base_menu
# 			if [ $? = 0 ]; then base_menu; fi
		else
			report_log+=("${vB}Libraries install:\t${end}${gB} success\t\t${end}> ${y}normal install process${end}.\n")
		fi
		n=$[ $n+5 ]; echo "$n" # 4
		cd $nvtmp
		if [[ -s $nvtmp/$extracted_release/nvidia-installer ]]; then
			echo "# ${v}${j}($n%)${end} - Backup new Nvidia-Installer to $nvdir${end}"; sleep 2
			#
			cp -f NVIDIA-Linux-$ARCH-$(new_version)/nvidia-installer $nvdir
			n=$[ $n+1 ]; echo "$n" # 5
		fi
		echo "# ${v}${j}($n%)${end} - Update new driver version file${end}"; sleep 2
		#
		printf "$(new_version)" > $nvdir/version.txt
		printf "$(new_version)" > $(user_CF_DIR)/version.txt
		n=$[ $n+1 ]; echo "$n" # 6
		# Backup installed binary from release to release dir archive
		if [ ! -f $nvdl/nv-update-$(new_version) ] ; then
			cp -f $run_pkg $nvdl/nv-update-$(new_version)
			if [[ -f $nvdl/nv-update-$(new_version) ]] ; then
				echo "# ${v}${j}($n%)${end} - Driver $(new_version) release package backup success${end}"; sleep 2
			else
				echo "# ${v}${j}($n%)${end} - Driver ${j}$(new_version)${end} release backup mistake. Not fatal.${end}"; sleep 2
			fi
		else
			echo "# ${v}${j}($n%)${end} - nv-update-$(new_version) already present in path, skip${end}"; sleep 2
		fi
		n=$[ $n+2 ]; echo "$n" # 7
		post_install
		echo "99"; sleep 2
		echo "100"
		## Install report display.
		if [[ $inst_mod_version == $(new_version) ]]; then
			if [ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| grep -c ".*") -gt 40 ]|| \
			[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| grep -c ".*") -gt 40 ]; then
			rep_msg=$( cat <<-RPT
			${vB}${bf}<i>Congratulations !</i>${end}${end}
			${jB}$(new_version)${end} ${vB}driver is now succefully installed${end}.

			${v}You may now configure your ${j}xorg.conf${end} file to fit with your current default display before restarting
			your computer with the new installed drivers.
			You may also do it later if you like, but it's not really recommanded.

			What do you want to do ?${end}
			RPT
			)
			install_report_log
			fi
		else
			warn_image=xkill
			warn_log=$(
			cat <<-RPT
				${rB}${bf}Unexpected ERROR.${end}${end}
				${jB}$inst_mod_version isn't $(new_version)${end}.
				Really weird. ${jB}O_o${end} !
				Some unknown bug pops up during driver installation.
				Or developper fucked out something ?
				Can't tell.
			RPT
			)
			qst=0; kill_yad=1; warn_image='xkill'; cancel_lbl="Abort!gtk-no"; ok_lbl=''
			win_yad_warns
# 			$d_zen $win_icon --width=450 --title="$_zen_title" --error \
#  			--text="${v}$error_log${end}"
#  			if [ $yad_pid -gt 0 ]; then kill $yad_pid; fi
#  			$d_yad --width=420 --height=240 --title="Zenvidia" --window-icon=$img_zen_desktop \
# 			--image=xkill --splash --borders=20 --text="${v}$error_log${end}" --button='Back to main menu'
# 			if [ $yad_pid -gt 0 ]; then kill $yad_pid; fi

		fi
# 		} | $d_zen --width=450 $win_icon --title="$_zen_title" --progress --percentage=1 --auto-close
		## yad replace from zenity 3.92 buggy behaviour.
# 		} | $d_yad --width=600 --height=300 --title "Zenvidia" --window-icon=$img_zen_desktop --progress --center \
# 		--wrap --hscroll-policy=never --hide-text --enable-log='' --log-expanded --log-on-top --log-height=300 \
# 		--text="${v}Installing ${j}$(new_version)${end} driver version for ${y}$dev_name${end}.${end}" --auto-close
		## TODO replace by win_yad_progress !!
# 		} | win_yad_log
		# win_yad_progress
		} | win_yad_progress
# 		rm -f $tmp_b # ALERT
		#[ $_opt -gt 0 ] && exit 0
		base_menu
	else
		error_log=$(
			cat <<-RPT
				${rB}${bf}Ouch!${end}${end}
				${jB}No proper Nvidia package found.${end}

			RPT
			)
		HTML=$(
			cat <<-TXT
				<!DOCTYPE html>
				<html>
				<head>
				<style>
					html { border: 3px solid #F53000; border-radius: 5px; }
					body { background:#3F3E3E; color: ${main}; height=120px; }
					a { color: ${log_msg}; text-decoration: none; }
					a:hover { font-weight:bold;}
				</style>
				</head>
				<body>
				You need to download the right package manually for your ${dev_name}.<br>
				Got to the Nvidia <a href="http://www.nvidia.fr/Download/Find.aspx?lang=en">download center</a> site,
				or directly to the NVIDIA ftp repository <a href="https://download.nvidia.com/XFree86/">here</a>.<br>
				</body>
				</html>
			TXT
			)
		( echo $HTML ) | $d_yad --html --width=420 --height=240 --title="Zenvidia" --window-icon=$img_zen_desktop \
		--image=xkill --splash --borders=20 --text="${v}$error_log${end}" --button='Back to main menu'
		base_menu
	fi
}
extract_build(){
	[ -d $nvtmp ]|| mkdir -p $nvtmp
	[ -d $buildtmp ]|| mkdir -p $buildtmp
	pushd $nvtmp
	if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version) ]; then
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo "# ${v}${j}($n%)${end} - $(new_version) package already extracted${end}"; sleep 2
		n=$[ $n+30 ]
	else
		[ ! -d NVIDIA-Linux-$ARCH-* ]|| rm -Rf NVIDIA-Linux-$ARCH-*
		## save dir name for install and post install process.
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo "# ${v}${j}($n%)${end} - Primary package extraction${end}"; sleep 2
		progress_msg(){ echo "# ${j}($m%)${end}${ge}${sf} * ($m%) Extracting $extracted_release${end}${end}"; echo "$m"; }; m=$n; do_slp=1
		progress "$run_pkg -x" #; . $tmp_c; rm -f $tmp_c
		sleep 1
		if [ "$(new_version)" ]&&[ "$(new_version)" != "$(old_version)" ]; then
			cp -f $nvtmp/$extracted_release/nvidia-installer .
			echo -e "$(new_version)" > $nvdir/new_version.txt
		else
			$d_zen --width=450 --title="$_zen_title" --error \
			--text="${j}${bf}Nvidia repository not found${end}${end}.${v} Extraction failure.${end}"
			base_menu
		fi
	fi
	popd
}

## BACKUP & PROGRESS COUNT ###
## progress counters.
tar_count(){
	( eval "$1" &>/dev/null ) & \
	( count_msg )
	m=$(($m+1))
}
progress(){
	test $tmp_c || {
	tmp_c=$(mktemp --tmpdir zn_count.XXX)
	rem_tmp+=("rm -f $tmp_c")
	trap "${rem_tmp[*]}" EXIT; }
	local exitval=0
	local pid progresspid
	if [[ $1 ]]; then
		eval_pid(){
			on_exit(){
				kill $(jobs -p) 2>/dev/null
				wait $(jobs -p) 2>/dev/null
			}
			trap on_exit EXIT
			while [ -d /proc/$pid ]; do
				( progress_msg )
				sleep $do_slp &
				#test $do_slp = 1 && sleep 1 &
				wait $!
				((m++))
			done
			echo -e "n=$m" > $tmp_c
		}
		( eval "$1" &>/dev/null ) & \
		pid=$! eval_pid & \
		progresspid=$!
		wait $pid 2>/dev/null
		exitval=$?
		kill $progresspid 2>/dev/null

		wait $progresspid 2>/dev/null
   fi
   ## line to paste in global progress count
	#	. $tmp_c ; rm -f $tmp_c
	return $exitval
}
y_pulse(){
	while [ -d /proc/$lpid ]; do
		for ((i=1; i<=$timeout; i++)) {
			echo $i 2>/dev/null
			sleep 0.096
			}
		done
	return
}
## previous version backup command.
backup_old_version(){
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	if [ -d $nv_root/nvidia.$bak_version ]; then
		cd $nvbackup
		## make the archive.
		m=1
		if [ $yad_pid -gt 0 ]; then
		count_msg(){ echo "# ${ge}${sf} * ($m%) - Backup : $bak_version tar ball creation${end}${end}"; sleep 1; echo "$m"; }
		do_slp=1; progress_msg(){ echo "# ${ge}${sf} * ($m%) - Backup : $bak_version GZIP archive creation${end}${end}"; echo "$m"; }
		else
		count_msg(){ echo "# ($m%) - Backup : $bak_version tar ball creation"; sleep 1; echo "$m"; }
		do_slp=1; progress_msg(){ echo "# ($m%) - Backup : $bak_version GZIP archive creation"; echo "$m"; }
		fi
		tar_count "tar cf nvidia.$bak_version.tar /etc/OpenCL"
		tar_count "tar uf nvidia.$bak_version.tar /etc/ld.so.conf.d/nvidia-*"
		test -f /etc/udev/rules.d/01-nvidia-driver.rules && tar_count "tar uf nvidia.$bak_version.tar /etc/udev/rules.d/01-nvidia-driver.rules"
		## save modules conf if exist.
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/blacklist-nouveau.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/nvidia-blacklist.conf"
		test -f /etc/modprobe.d/nvidia-drm.conf && tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/nvidia-drm.conf"
		test -f /etc/modprobe.d/open-NVIDIA.conf && tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/open-NVIDIA.conf"
		## if backup is create with a use_open var to 1 and the present driver config is different,
		## open-NVIDIA.conf file is not enought to tell the right way of use. User's use_open var must be saved too.
		tar_count "tar uf nvidia.$bak_version.tar /home/$(def_user)/.zenvidia/basic.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf.nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-hibernate.service.wants"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-suspend.service.wants"
		## take care of dkms auto install behaviour upon open source driver installation.
		test -f /etc/dkms/no-autoinstall && tar_count "tar uf nvidia.$bak_version.tar /etc/dkms/no-autoinstall"
		tar_count "tar uf nvidia.$bak_version.tar /lib/modules/$KERNEL/$(module_dest_location)/nvidia*"
		tar_count "tar uf nvidia.$bak_version.tar /lib/firmware/nvidia/$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia.$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar /usr/lib/systemd/system/nvidia-*"
#  		test -d /usr/$master$ELF_32/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
#  		test -d /usr/$master$ELF_64/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
 		[ -d /usr/$master$ELF_32/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
 		[ -d /usr/$master$ELF_64/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*"
		make -C /usr/src/nvidia-$bak_version clean
		tar_count "tar uf nvidia.$bak_version.tar /usr/src/nvidia-$bak_version"
		if [ -d /usr/src/open-nvidia-$bak_version ]; then
			make -C /usr/src/open-nvidia-$bak_version clean
			tar_count "tar uf nvidia.$bak_version.tar /usr/src/open-nvidia-$bak_version"
		fi
		tar_count "tar uf nvidia.$bak_version.tar $install_dir/bin/nvidia-*"
		if [[ $(ls -1 /usr/local/$master$ELF_32/libnvidia-*| grep -c $bak_version) -le 3 ]]; then
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_32/libnvidia-{fbc{.so,.so.1},*.$bak_version}"
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}"
		else
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}"
 		fi
# 		tar_count "tar uf nvidia.$bak_version.tar $install_dir/share/nvidia/nvidia-application-profiles-$bak_version*"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/dkms/nvidia/$bak_version/{source,$KERNEL}"
		[ -d /var/lib/dkms/open-nvidia/$bak_version ] && \
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/dkms/open-nvidia/$bak_version/{source,$KERNEL}"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/nvidia/{dirs,log}"
		tar_count "tar uf nvidia.$bak_version.tar $nvdir/version.txt"
## compress in gz.
		progress "gzip -c nvidia.$bak_version.tar > nvidia.$bak_version.tar.gz"
		echo "" > $tmp_c
		if [ $zen_pid -gt 0 ]; then
		echo "# ${ge}${sf} * (100%) - Backup: ${j}$bak_version${end} GZIP archive created${end}${end}"; sleep 1
		else
		echo "# Backup: $bak_version GZIP archive created"; sleep 1
		fi
		rm -f nvidia.$bak_version.tar
	fi
}

## UPDATE DRIVER SECTION ###
upgrade_new_kernel(){
	unset kern_list
	up_version=$(version)
	ls_kern=$(ls -1 /boot| grep -v "rescue"| grep "vmlinuz"| sed -n 's/^[[:alpha:]]*-//p')
	for linuz in ${ls_kern}; do
		kern_list+=("false")
		kern_list+=("$linuz")
	done
	w_text=$( cat <<-MSG
		$menu_msg
		Driver install ${j}$up_version${end} for hardware ${j}${dev_name}${end}.
		Pick the up to date kernel
	MSG
	)
# 	NEW_KERNEL=$($d_zen --height=300 $win_icon --title="$_zen_title" --list --radiolist --hide-header \
# 	--text "$w_text" --column "set" --column "action" --separator=";" "${kern_list[@]}")
	# win_yad_list
	l_text=$w_text
	cancel_lbl='Back to main!undo-tlr'; ok_lbl='Select!gtk-ok'
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b"); NEW_KERNEL=$(win_yad_list "${kern_list[*]}")
	if [ $? = 1 ]; then IFS=$ifs; base_menu; fi
	IFS=$ifs
# 	if [ $(echo -e "$NEW_KERNEL"| grep -E -c "[0-9]+") -gt 0 ]; then
		upgrade_kernel
# 	fi
}
upgrade_kernel(){
	if [[ $NEW_KERNEL ]];then
		KERNEL=$NEW_KERNEL
	fi
	if [ $upgrade_other = 1 ]; then
		kernel_path="/lib/modules/$KERNEL/$(module_dest_location)/"
# 		kernel_src="/usr/src$alt/$KERNEL"
	fi
	kernel_src="/usr/src$alt/$KERNEL"
	drv_release=$(ls $nvdl/ | grep "$(new_version)")
# 	confirm_msg="${v}Kernel update ${j}$KERNEL${end} :$d${end}"
# 	val_title="$_zen_title"
# 	val_confirm="$CC"
# 	val_back="$MM"
# 	val_cancel="base_menu" #TEXT
# 	val_exit="base_menu"
# 	win_confirm
	# win_yad_warns
# 	warn_log="${v}Kernel update ${j}$KERNEL${end} :$d${end}"
	warn_log="${j}<b>Kernel driver update</b>${end}\n${y}$KERNEL${end} drivers will be update."
	qst=1; ok_lbl='Update!gtk-ok' ; cancel_lbl='Back to menu!undo-rtl' ; kill_yad=0
	win_yad_warns
	if [ $y_output = 1 ]; then menu_update; fi
	y_text="${v}Kernel ${j}$KERNEL${end} driver update${end}"
	pulse=1; log=0; hold=0 ; hide_txt=0
	## tell yad that basic pusle win is pulse
	{ timeout=30 ;{
	YAD_PID=$(pgrep -n yad)
	echo -e "# Kernel update $KERNEL ..."
	cd $nvdl/
	nv_cmd_update
	if [ $pass -gt 0 ]||[ ! -e $kernel_path/nvidia.*[ko\|ko.xz] ]; then
# 		$d_zen $win_icon --width=450 --title="$_zen_title" --error \
# 		--text="${j}INSTALL ABORT ABNORMALY, check $(echo "$logfile" | sed -n 's/^.*=//p')${end}."
		# win_yad_warns
		warn_log="${j}INSTALL ABORT ABNORMALY, check $(echo "$logfile" | sed -n 's/^.*=//p')${end}."
		qst=0; ok_lbl='' ; cancel_lbl='Back to main menu!edit_undo-rtl' ; kill_yad=1
		win_yad_warns
		if [ $y_output = 1 ]; then base_menu; fi
# 		exit 0
	fi
	new_version=$(version)
# 	) | $d_zen $win_icon --width=450 --title="$_zen_title" --progress --pulsate --auto-close
	# win_yad_progress
	}& eval lpid=$!; y_pulse; } | win_yad_progress
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/update-$KERNEL.log; fi
	base_menu
}

## FROM A REMOTE/USER DIRECTORY ###
net_version_selector(){
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$( cat <<-HLP

		<b>Select the driver version type to install</b>
		   - <b>Look up for latest</b>:
		   Look for the last available packges from Nvidia repos site.0
		   - <b>Look up for older version</b>:
		   Look for a previous packeges available in Nvidia repos site.
		HLP
		)
# 		if [ $zenity_ver -le 3420 ]; then
# 		w_height='--height=300'
# 		else
# 			w_height='--height=400'
# 		fi
	else
		hlp_tip="\n<b>Select the driver version type to install</b>"
# 		if [ $zenity_ver -le 3420 ]; then
# 		w_height='--height=200'
# 		else
# 			w_height='--height=300'
# 		fi
	fi
# 	menu_select=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}" \
# 	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	true 1 "Look for latest version" false 2 "Look for older version")

	unset list_array
	IFS=$(echo -en "\n\b")
	list_array=( true 1 "Look for latest version" false 2 "Look for older version" )
	l_text="${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}"
	cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	menu_select=$( win_yad_list "${list_array[*]}" )

	if [ $? = 1 ]; then IFS=$ifs ;base_menu; fi
	IFS=$ifs
	case $menu_select in
		"1") check_for_newer ;;
		"2") check_for_older ;;
		*) base_menu ;;
	esac
	check_update
}
check_for_older(){
# 	drv_list=( "$(tac $(user_CF_DIR)/notify/drvlist)" )
	unset rem_packages_list old_pack_list
	rem_packages_list=( $(tac $(rem_drv_list)) )
	for pack_list in "${rem_packages_list[@]}"; do
		old_pack_list+=("false")
		old_pack_list+=("$pack_list")
		n=$[ $n+1 ]
	done
# 	if [ $zenity_ver -le 3420 ]; then
# 		w_height='--height=300'
# 	else
# 		w_height='--height=400'
# 	fi
# 	older_pack=$($d_yad --width=400 --height=300 --list --radiolist --no-headers \
# 	--center --borders=15 --window-icon=$img_zen_desktop --title="Zenvidia" \
# 	--text "${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}" \
# 	--button='Back to main menu':1 --button='Select':0 \
# 	--separator='' --column "set" --column "action" "${old_pack_list[@]}")
# 	older_pack=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}" \
# 	--column "set" --column "action" \
# 	"${old_pack_list[@]}")

	IFS=$(echo -en "\n\b")
	l_text="${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}"
	cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	older_pack=$( win_yad_list "${old_pack_list[*]}" )

	if [ $? = 1 ]; then IFS=$ifs ;base_menu; fi
	IFS=$ifs
	LAST_DRV=$older_pack
	legacy_drv=1
}
check_for_newer(){
	y_text="NVIDIA Download center data check"
	pulse=1; log=0; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{	timeout=30
	{	$p_wget -q -O $upcompat/last_update https://$nvidia_ftp-$ARCH/latest.txt
	}& eval lpid=$! ; y_pulse ;} | win_yad_progress

	LAST_DRV=$(cat $upcompat/last_update | awk '{ print $1 }')
	legacy_drv=0
}
## UPDATED RELEASE CHECK ###
hardware_compat(){
	y_text="NVIDIA Download center compatibility check (${j}$DRV${end})..."
	pulse=1; log=0; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{	timeout=30
	{	$p_wget -q -O $upcompat/upt_compat https://$nvidia_ftp-$ARCH/$DRV/README/supportedchips.html
	}& eval lpid=$!; y_pulse; } | win_yad_progress

	cat $upcompat/upt_compat | sed -n "/<h3>/,/Below are the legacy/{;/<tr\|<td\|<\/tr>/p}"| \
	perl -n -pe "s|(<(/\|)t[r,d](>\| id=\"))||,s|(\">\|</td>)\n|,|p" > $nvcompat/compat.$DRV

	## build a genaral compatibility list for series drivers classes.
	upt_compat_list=$(user_CF_DIR)/updates/upt_compat_list
	upt_local_conf=$(rem_drv_list)

	cat $upcompat/upt_compat | sed -n "/<h3>/,/name=\"subsys/p"| \
	perl -n -pe "s|(<(/)?t[r,d,a,b](ble\|ody)?(>\| id=\")?)||;s|(\">\|</td>)\n|,|; \
	s|.*legacy_(.*.xx)\">.*|* \1|;s|.*<[/]?[dtpc].*$||p"| \
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p" > $upt_compat_list
	## add a separator at the end.
	echo -e "------" >> $upt_compat_list

	## here start the compatibility tool.
	unset COMPAT class_list sed_output
	[ -d $nvcompat ]|| mkdir -p $nvcompat/series
	IFS=$(echo -en "\n\b")
	## define the separation chapter series section.
# 	COMPAT+=("Current NVIDIA GPUs")
	COMPAT+=("<h3>")
	COMPAT+=("$(grep -E "\* *[0-9]{2,4}((.xx)|(\.*[0-9]{2,3}.xx))" $upt_compat_list)")
	if [ $(ls -1 $nvcompat/series/ | grep -E -c "^[0-9]*\.[0-9]*\.[0-9]*$") -gt 0 ]; then
		rm -f $nvcompat/series/* | grep -E "^[0-9]*\.[0-9]*\.[0-9]*$"
	fi
	for line in ${COMPAT[@]}; do
		if [[ $line =~ ".xx" ]]; then
			drv_class=$(echo -e "$line"| sed -En "s/\* (.*).xx$/\1/p")
			line=$(cut -d' ' -f2 <<< $line)
		else
			drv_class=$(echo "$DRV"| cut -d. -f1)
		fi
		drv_end=$(cat <<< ${COMPAT[*]}| grep -A1 "$line"| sed -En "s/^\* (.*).xx$/\1/g;\$p")
		test "$drv_end" = "$drv_class" && drv_end='-----'
		## send result in separate compat files.
		sed_output=( $( sed -En "/$line/,/$drv_end.xx/p" $upt_compat_list) )
		sed -En "/$line/,/$drv_end.xx/p" $upt_compat_list | grep -E "^devid" > $nvcompat/series/$drv_class
	done
	IFS=$ifs
	## build compat file list from created.
	class_list=("$(ls -1 $nvcompat/series/| sort -n)")
	## dig for device id and usual name.
	pci_class=${dev[$e]}
	pci_brand=${slot_id[$e]}
	## check compat.
	if [ $(grep -ic "devid$pci_brand" $nvcompat/series/$(echo "$DRV"| cut -d. -f1)) -gt 0 ]; then
		## send message for the install_drv section.
		if [ $from_install = 1 ]; then
# 			install_msg="# Compatiblity found in $(echo "$DRV"| cut -d. -f1) serie, proceed to install"
			# zen
# 			echo -e "install_msg=\"# Compatiblity found in $(echo "$DRV"| cut -d. -f1) serie, proceed to install\"" > $tmp_b
			# yad
# 			echo -e "install_msg=\"# ${v}${j}($n%)${end} - Compatiblity found in ${y}$(echo "$DRV"| cut -d. -f1)${end} serie, proceed to install${end}\"" > $tmp_b
			echo -e "install_msg='# ${v}${j}($n%)${end} - Compatiblity found in ${y}$(echo "$DRV"| cut -d. -f1)${end} serie, proceed to install${end}'" > $tmp_b
		else
			legacy=0
			echo -e "comp_result=+\"$DRV,$legacy\"" >> $upt_comp_tmp
		fi
	else
		for comp_file in ${class_list[@]}; do
			if [ $(grep -ic "devid$pci_brand" $nvcompat/series/$comp_file) -gt 0 ]; then
				## message for install_drv section.
				if [ $from_install = 1 ]; then
# 					install_msg="# Your $pci_brand is not compatible with $DRV, look in $comp_file serie instead."
# 					echo -e "# Your $pci_brand is not compatible with $DRV, look in $comp_file serie instead." > $tmp_b
					warn_log=$(cat <<-ERR
						${rB}${bf}<i>UNCOMPATIBLE DRIVER</i>${end}${end}
						${v}The ${j}$pci_class${end} is not compatible with ${j}$DRV${end} driver.
						Check in ${j}$comp_file${end} serie instead.
						Abort.${end}
					ERR
					)
# 					$d_zen --width=450 --title="$_zen_title" --error --no-wrap \
# 					--text="$error_log" \
# 					$icon_name=xkill --ok-label="Got it"
# 					if [ $zen_pid -gt 0 ]; then kill $zen_pid; else kill $yad_pid; fi
					qst=0; warn_image=xkill; cancel_lbl='Got it!gtk-ok'; kill_yad=1
					win_yad_warns
				fi
				## serie driver class for the update/install section.
				family=$comp_file
			fi
		done
		## define vazrs for the update/isntall section.
		if [ $family ]; then
			if [ $family -ne $(chk_version) ]; then
				family_last=$(cat "$upt_local_conf" | grep "$family" | sed -n '$p')
# 				legacy_found=1
				legacy=1
				((comp_display_legacy++))
			else
				legacy=0
			fi
			family_check=1
		else
			## send fatal in no driver support.
# 			install_msg="# Your $pci_brand is not supported by NVIDIA's drivers."
# 			echo -e "# Your $pci_brand is not supported by NVIDIA's drivers." > $tmp_b
			if [ $from_install = 1 ]; then
				warn_log=$(cat <<-ERR
					${rB}${bf}<i>UNCOMPATIBILITY ISSUE</i>${end}${end}
					${v}The ${j}$pci_class${end} is not supported by ${j}NIVDIA${end} driver.
					and there's no solution here except maybe reverse to ${j}Nouveau${end} driver.
					Abort.${end}
				ERR
				)
				qst=0; warn_image='xkill'; cancel_lbl='Got it!gtk-apply'; ok_lbl=''; kill_yad=1
				win_yad_warns
# 				$d_zen --width=450 --title="$_zen_title" --error --no-wrap \
# 				--text="$error_log" \
# 				$icon_name=xkill --ok-label="Got it"
# 				if [ $zen_pid -gt 0 ]; then kill $zen_pid; else kill $yad_pid; fi
# 				base_menu
			else
				legacy=0
			fi
			family_check=0
		fi
# 		echo "$DRV,$family_check,$legacy_found,$family,$family_last," >> $upt_comp_tmp
# 		echo -e "comp_result=+\"$DRV,$family_check,$legacy_found,$family,$family_last\"" >> $upt_comp_tmp
		echo -e "comp_result=+\"$DRV,$legacy\"" >> $upt_comp_tmp
		echo -e "family_last=$family_last" >> $upt_comp_tmp
		echo -e "family=$family" >> $upt_comp_tmp
# 		echo -e "legacy=$legacy_found" >> $upt_comp_tmp
		echo -e "legacy=$legacy" >> $upt_comp_tmp
		echo -e "comp_family=$family_check" >> $upt_comp_tmp
		echo -e "comp_display_legacy=$comp_display_legacy" >> $upt_comp_tmp
	fi
# 	comp_check+=("$DRV,$comp_check,$legacy_found")
# 	echo "$DRV,$comp_check,$legacy_found" >> $upt_comp_tmp
}
check_update(){
	unset DIFF_list
	LAST_IN=$(version)
	LAST_BETA=$(tac $(rem_drv_list) | sed -n 1p)
	upt_comp_tmp=$(mktemp --tmpdir zn_vars.XXXX )
	rem_tmp+=("rm -f $upt_comp_tmp")
	trap "${rem_tmp[*]}" EXIT
	## COMPATIBILTY SECTION
	# first chack if alpha = beta or not.
	if [[ $LAST_DRV == $LAST_BETA ]] ; then
			DIFF_list=$LAST_DRV
	else
			DIFF_list="$LAST_DRV $LAST_BETA"
	fi
	## reset old compatibilty sets.
	legacy_found=0
	family_check=0
	legacy=0
	comp_family=0
	comp_display_legacy=0

# 	w_height=355
# 	if [ $zenity_ver -le 3420 ]; then
# 		w_height='--height=355'
# 	else
# 		w_height='--height=455'
# 	fi
# 	unset dl_allow COMP_L COMP_I LOCAL_DRV comp_check comp_result
	## desktop could have more than one device managed. So check.
	for e in $pci_dev_nb; do
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			for DRV in $DIFF_list; do
				## test existence of the new driver version in remote tree and compatibilities.
				$(hardware_compat)
				. $upt_comp_tmp
				## and prepare optional messages to display.
				if [ $(cat $(rem_drv_list)| grep -c $DRV) -gt 0 ]; then
					dl_allow=1
				else
					dl_allow=0
				fi
				# mark driver stocked in local repos.
				in_pack=$(ls -1 $nvdl/ | grep -c "$DRV")
				test "$DRV" == "$LAST_IN" && _installed=1 || _installed=0
				if [ "$LAST_BETA" ]&&[ "$LAST_BETA" != "$LAST_DRV" ]; then
					if [ $legacy_drv = 1 ]; then
						test "$DRV" == "$LAST_BETA" && _is_beta=0 || _is_beta=1
					else
						test "$DRV" == "$LAST_BETA" && _is_beta=1 || _is_beta=0
					fi
					test $legacy_drv -gt 0 && _is_beta=0
				else
					_is_beta=0
				fi
				DEV_filter=$(cat $nvcompat/compat.$DRV| grep -E -i "devid${slot_id[$e]}")
				dev_compat=$(cat $nvcompat/compat.$DRV| grep -E -ic "devid${slot_id[$e]}")
				VDPAU_class=$(printf "$DEV_filter"|cut -d"," -f4) # J
				LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow")
			done
		fi
	done
	## write it in default script directory for further use.
	echo -e "${COMP_I[@]}" > $nvcompat/compat.update
	sed -i "/^[[:space:]]*$/d;s/^\ //g" $nvcompat/compat.update
	win_update
}
win_update(){
	## define window messages and display compatibilities.
	in_local_repos=0
	in_dl_repos=0
	in_installed=0
	in_compat_list=0
# 	end_msg="What do you want to do ?"
	unset DOWN_list main_msg more_msg
	## get driver list from check_update to define local presence and what to display.
	# LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow")
	# '364.12,0,0,0,"0",GeForce RTX 2060,,1'
	# '525.85.05,1,0,0,"1",GeForce RTX 2060,J,1'
	IFS=$(echo -en "\n\b")
	for local_drv in ${LOCAL_DRV[@]}; do
		_drive=$(echo "$local_drv"|cut -d',' -f1)
		_exist=$(echo "$local_drv"|cut -d',' -f2)
		_insta=$(echo "$local_drv"|cut -d',' -f3)
		_beta=$(echo "$local_drv"|cut -d',' -f4)
		_dev_comp=$(echo "$local_drv"|cut -d',' -f5)
		_name=$(echo "$local_drv"|cut -d',' -f6)
		_vclass=$(echo "$local_drv"|cut -d',' -f7)
		_dl_ok=$(echo "$local_drv"|cut -d',' -f8)
		## messageries
		end_msg="What do you want to do ?"

		case $_insta in
			0) set_in='' ;;
			1) set_in=" (installed)"; ((in_installed++)) ;;
		esac
		if [ "$_vclass" ]; then comp_v="(VDPAU class $_vclass)"; fi
		case $_dl_ok in
			0) dl_warn="\n${y}but is not downloadable yet (wont be list)${end}" ;;
			1) dl_warn='' ;;
		esac

		case $_dev_comp in
			0) comp_a="${vB}uncompatible${end}"
				comp_b="${y}$_drive${end} ${rB} driver doesn't manage your hardware${end}\n"
				((un_compat_list++))
			;;
			1) comp_a="compatible"
# 				comp_b="compatible. $comp_v"
				comp_b="${j}$_drive${end} ${v} driver fit your hardware${end} ${y}$(echo -e '\u2764')${end}\n" # or 2714
				((in_compat_list++))
			;;
		esac
		case $_beta in
			0)
			if [ $legacy_drv = 0 ]; then
				set_beta='official'; _drv_title='official'; tab=''
			else
				if [ "$_drive" == "$LAST_BETA" ]; then
					set_beta='official'; _drv_title="last release"; tab=''
				else
					set_beta='legacy' ; _drv_title='legacy'; tab=''
				fi
			fi
			;;
			1) set_beta='beta'; _drv_title='beta'; tab='- -';;
		esac
		case $_exist in
			0) in_repos='is not in your repository'
				DOWN_list+=("false"); DOWN_list+=("$_drive"); DOWN_list+=("($_drv_title)"); ((in_dl_repos++))
			;;
			1) in_repos='is in your repository'; ((in_local_repos++))
			;;
		esac

		COMP_L+=("${j}$_name${end} ${v}($_drive), $comp_a${end}")
		COMP_L+=("$comp_b")
		main_msg+=("\n${v}The $set_beta version is :${end}${ge} ${tab} - - - - - - ${end}${y}$_drive${end}")
		more_msg+=("\n${j}$_drive${end}${vB} $in_repos.${end}${v}$set_in${end}$dl_warn")
		## define the appropriate UI.
		case $in_local_repos in
			0|1) ui_mod=1		# dl/inst selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg='Nothing to do.' ;;
					1) if [ $in_dl_repos -eq 0 ]; then
								ui_mod=2
						fi
						if [ $in_installed -eq 1 ]&&[ ${#DOWN_list[*]} -eq 0 ]; then
							ui_mod=0; end_msg='Nothing to do.'
						fi
					;;
				esac
			;;
			2|3) ui_mod=2		# inst local selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg='Nothing to do.' ;;
					1) if [ $in_dl_repos -gt 0 ]; then
							ui_mod=1
						fi
					;;
				esac
			;;
		esac
	done
	## this section is for lagacy driver part and has to be display only once.
	if [ $comp_display_legacy -ge 1 ]; then # normal
# 	if [ $comp_display -eq 0 ]; then # test
		case $comp_family in
			0) comp_c="${y}this driver is not supported anymore${end}"
				test $legacy -gt 0 && comp_d='\n'
			;;
			1) case $legacy in
					0) comp_d='' ;;
					1) comp_d="\n${v}Last ${y}$family_last${end} will be list.${end}"
						if [ $(ls -1 $nvdl/ | grep -c "$family_last") = 1 ]; then
							in_repos='is in your repository'
							ui_mod=2
						else
							in_repos='is not in your repository'
							DOWN_list+=("false")
							DOWN_list+=("$family_last")
							DOWN_list+=("(last legacy)")
						fi
						more_msg+=("\n${j}$family_last${end}${vB} $in_repos.${end}")
					;;
				esac
				comp_c="\n${v}Devices compatibility found in ${y}$family${end} serie${end}$comp_d"

			;;
		esac
		COMP_L+=("$comp_c")
	fi
	compat_msg=$(cat <<< ${COMP_L[*]})
	IFS=$ifs

	extra_msg="\n${more_msg[@]}\n\n${v}$end_msg${end}"
	case $ui_mod in
		0)	zen_opts="--image=dialog-warning --borders=15 --button=Abort:1"
			table_opts=''
			list_opts=''
			;;
		1)	zen_opts='--list --radiolist --no-headers --borders=15 --button=Abort!undo-rtl:1 --button=Select!gtk-ok:0'
			table_opts='--column set --column 2 --column action --separator= --hide-column=2 --print-column=2'
			list_opts="true 1 Install false 2 Download ";;
		2)	zen_opts="--image=dialog-question --borders=15 --button=Abort!undo-rtl:1 --button=Select!gtk-ok:0 "
			table_opts=''
			list_opts=''
			;;
	esac
# 	case $ui_mod in
# 		0|2) if [ $zenity_ver -le 3420 ]; then
# 					w_height='--height=180'
# 				else
# 					w_height='--height=280'
# 				fi
# 		;;
# 		1) if [ $zenity_ver -le 3420 ]; then
# 				w_height='--height=450'
# 			else
# 				w_height='--height=550'
# 			fi
# 		;;
# 	esac
	case $ui_mod in
		0|2) w_height='--height=100' ;;
		1)   w_height='--height=200' ;;
	esac
	w_text=$(cat <<-MSG
		${jB}${bf}Available drivers${end}${end}

		${v}Driver version installed :${end}${ge} - - - - - ${end}${j}$(drv_installed)${end}
		$(cat <<< ${main_msg[@]})

		$compat_msg
		$extra_msg
	MSG
	)
	# Don't use yad window function for this.
	sel_cmd=$($d_yad --width=300 $w_height --window-icon=$img_zen_desktop --title="Zenvidia" --center \
	$zen_opts --text="$w_text" $table_opts $list_opts )
	if [ $? = 0 ]; then
		case $ui_mod in
			0) [ $_opt -gt 0 ] && exit 0 || base_menu ;;
			1) case $sel_cmd in
					"1") ok_label='Install'; from_net ;;
					"2") ok_label='Download'; download_only ;;
				esac ;;
			2) from_directory ;;
			*) [ $_opt -gt 0 ] && exit 0 || menu_install ;;
		esac
	else
		[ $_opt -gt 0 ] && exit 0 || base_menu
	fi
}
from_directory(){
	nv_dir(){
		unset list_drv
# 		table_opts='--column set --column action --separator=";"'
# 		zen_opts='--list --radiolist --hide-header'
		cd $nvdl; n=1
		for local_drv in ${nvdl_list[@]}; do
			if [ $_drive ]&&[[ "$local_drv" =~ "$_drive" ]]; then
				list_drv+=("true")
			else
				list_drv+=("false")
			fi
			list_drv+=("$local_drv")
		done
		l_text=$(
		cat <<-INFO
			${j}${bf}Install from stock${end}${end}

			Driver list in $nvdl

			$loaded
		INFO
		)
# 		drv_pick=$($d_zen --width=400 $w_height $win_icon --title="$_zen_title" $zen_opts \
# 		--text="$w_text" $table_opts ${list_drv[@]})

		IFS=$(echo -en "\n\b")
		cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		drv_pick=$( win_yad_list "${list_drv[*]}" )

		if [ $? = 0 ]; then
			IFS=$ifs
			if [ "$drv_pick" != '' ]; then
				run_pkg=$nvdl/$drv_pick
			else
				from_directory
			fi
		else
			IFS=$ifs
			if [ $_drive ]; then
				[ $_opt -gt 0 ] && exit 0 || menu_install # base_menu
			else
				[ $_opt -gt 0 ] && exit 0 || from_directory # menu_install
			fi
		fi
	}
	home_dir(){
		unset list_drv
# 		table_opts='--column set --column 2 --column action --separator=";" --hide-column=2'
# 		zen_opts='--list --radiolist --hide-header'
		for local_drv in ${home_list[@]}; do
			list_drv+=("false")
			list_drv+=("$local_drv")
			list_drv+=("$(sed -En "s|^.*\/||g;p" <<< $local_drv)")
		done
		l_text=$(
		cat <<-INFO
			${j}${bf}Install from user directory${end}${end}

			Select a driver from ${j}$(def_user)${end} download directory

			$loaded
		INFO
		)
# 		drv_pick=$($d_zen --width=400 $w_height $win_icon --title="$_zen_title" $zen_opts \
# 		--text="$w_text" $table_opts ${list_drv[@]})

		IFS=$(echo -en "\n\b")
		cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		drv_pick=$( win_yad_list "${list_drv[*]}" )

		if [ $? = 0 ]; then
			IFS=$ifs
			if [ "$drv_pick" != '' ]; then
				chmod a+x $drv_pick
				run_pkg=$drv_pick
			else
				from_directory
			fi
		else
			IFS=$ifs; [ $_opt -gt 0 ] && exit 0 || from_directory # menu_install
		fi
	}
	test $(version) && loaded="${v}<i>${y}$(version)${end} actually installed and loaded.</i>${end}"
	nvdl_list=( $(ls -1 $nvdl| grep -v ".sum"| tac) )
	home_list=( "$(find $(user_DL_DIR)/ -regextype sed -regex "^.*NVIDIA-Linux-.*\.run"| tac)" )
	if [ $ui_mod = 1 ]; then
# 		A="Use Zenvidia stock directory"
# 		B="Use a user local directory"
		unset list_array
		list_array=( false 1 "Use Zenvidia stock directory" false 2 "Use a user local directory" )
# 		zen_opts='--list --radiolist --hide-header'
# 		table_opts='--column set --column 2 --column action --separator=";" --hide-column=2'
		l_text=$(
		cat <<-INFO
			${j}<b>Local NVIDIA drivers STOCK</b>${end}

			Zenvidia release stock :	${j}<b>${#nvdl_list[*]}</b>${end} object(s) found.
			User home directory :		${j}<b>${#home_list[*]}</b>${end} object(s) found.

			${v}<b>Select the directory to install from.</b>${end}
		INFO
		)
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=220'
# 		else
# 			w_height='--height=320'
# 		fi
# 		from_cmd=$($d_zen --width=400 $w_height $win_icon --title="$_zen_title" $zen_opts \
# 		--text="${v}$w_text${end}" $table_opts false 1 "$A" false 2 "$B" )

		IFS=$(echo -en "\n\b")
		cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		from_cmd=$( win_yad_list "${list_array[*]}" )

		if [ $? = 1 ]; then IFS=$ifs; [ $_opt -gt 0 ] && exit 0 || base_menu; fi
		IFS=$ifs
		case $from_cmd in
			"1") nv_dir ;;
			"2") home_dir ;;
			*) [ $_opt -gt 0 ] && exit 0 || menu_install ;;
		esac
	elif [ $ui_mod = 2 ]; then
		nv_dir
	fi
	new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
	install_drv
}
from_net(){
# download functions
		cd $buildtmp
# 		unset REM_list
# 		nv_center=https://$nvidia_ftp-$ARCH
# 		wget -O /tmp/wget_list $nv_center/index.html 2>&1
# 		trap "/tmp/wget_list" EXIT
# 		REM_list=( $(sed -En "s/^.*span.*'dir'.*href='(.*)\/'.*$/\1/p") )
# 		if [ ${#REM_list[*]} -gt 0 ]; then
# 			for drv in ${REM_list[@]}; do
# 				DOWN_list+=("false")
# 				DOWN_list+=("$drv")
# 			done
# 		fi
		download_menu
		run_pkg=$nvdl/nv-update-$LAST_PACK
		if [ -f $buildtmp/$run_pack ]; then
# 			$d_zen --info $win_icon --title="$_zen_title" --no-wrap $icon_name=swiss_knife \
# 			--text="${v}Driver download ${j}$LAST_PACK${end} ended.${end}"

			warn_log="${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
			warn_image='swiss_knife'
			qst=0; cancel_lbl='Close!gtk-close' ; kill_yad=0
			win_yad_warns

			mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
			chmod 755 $nvdl/nv-update-$LAST_PACK
		fi
		new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
		install_drv
}
download_menu(){
		l_text=$( cat <<-INFO
			${jB}${bf}Downloads${end}${end}
			Select the drivers version you wish to $ok_label.
			in the list below
		INFO
		)
		output_type=1
	if [ ${#DOWN_list[*]} -gt 3 ]; then
		IFS=$(echo -en "\n\b")
		cancel_lbl='Back to main menu!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='300'; w_height='0'
		dl_cmd=$( win_yad_list "${DOWN_list[*]}" )
	else
		dl_cmd=${DOWN_list[1]}
		warn_log=$( cat <<-MSG
			${jB}${bf}Downloads${end}${end}
			NVIDIA ${y}$dl_cmd${end} driver is going to be $ok_label.

			${v}Are you sure ?${end}
		MSG
		)
		qst=1; ok_lbl='Ok!gtk-ok'; cancel_lbl='Back to main menu!undo-rtl' ; kill_yad=0
		win_yad_warns
	fi
	if [ $? = 1 ]||[ $y_output = 1 ]; then
		IFS=$ifs
		[ $_opt -gt 0 ] && exit 0 || base_menu
	else
		if [ "$dl_cmd" ]; then
			LAST_PACK=$dl_cmd
		else
# 			if [ ${#DOWN_list[*]} -le 3 ]; then
# 				LAST_PACK=${DOWN_list[1]}
# 			else
# 				IFS=$ifs
# 				[ $_opt -gt 0 ] && exit 0 || base_menu
# 			fi
			warn_log="${r}Driver download failure${end}\nOutput is empty."
			qst=0; ok_lbl='Ok!gtk-ok'; cancel_lbl='Back to main menu!undo-rtl' ; kill_yad=0
			win_yad_warns
			[ $_opt -gt 0 ] && exit 0 || base_menu
		fi
	fi
	IFS=$ifs

# 	if [ $? = 1 ]; then
# 		base_menu
# 	else
# 		if [ "$dl_cmd" ]; then
# 			LAST_PACK=$dl_cmd
# 		else
# 			test ${#DOWN_list[*]} -le 3 && LAST_PACK=${DOWN_list[1]} || base_menu
# 		fi
# 	fi
# 	IFS=$ifs
	last_pack
}
download_only(){
	cd $buildtmp
	download_menu
	if [ -f $buildtmp/$run_pack ]; then
# 		$d_zen --info $win_icon --title="$_zen_title" --no-wrap $icon_name=swiss_knife \
# 		--text="${v}Driver download ${j}$LAST_PACK${end} ended.\n$MM${end}"

		warn_log="${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
		warn_image='swiss_knife'
		qst=0; cancel_lbl='Close!gtk-close' ; kill_yad=0
		win_yad_warns

		test -f $buildtmp/$run_pack.sha256sum && rm -f $buildtmp/$run_pack.sha256sum
		mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
		chmod 755 $nvdl/nv-update-$LAST_PACK
		[ $_opt -gt 0 ] && exit 0 || base_menu
	else
# 		$d_zen --width=450 $win_icon --title="$_zen_title" --error \
# 		--text="${v}Driver download ${j}$LAST_PACK${end} failure.\n The package ${j}$run_pack${end} doesn't exist.\n$MM.${end}"

		warn_log="${v}Driver download ${j}$LAST_PACK${end} failure.\n The package ${j}$run_pack${end} doesn't exist.${end}"
		warn_image='swiss_knife'
		qst=0; cancel_lbl='Close!gtk-close' ; kill_yad=0
		win_yad_warns

		[ $_opt -gt 0 ] && exit 0 || base_menu
	fi
}
last_pack(){
	track(){
    # picked up & inspired by winetricks download progress commande:
    # Parse a percentage, a size, and a time into $1, $2 and $3
    # then use them to create the output line.
   	perl -p -e "$| = 1; s|^.* +([0-9]+%) +([0-9,.]+[GMKB]) +([0-9hms,.]+).*$|\1\n# $run_pack\t(\1): time left \3\t\2\/s|"
	}
	download_cmd(){
		$p_wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack $buildtmp/ 2>&1
	}
	download_error(){
# 		$d_zen --height=100 --error $win_icon $icon_name=xkill --no-wrap \
# 		--text="${v}$w_text${end}" --ok-label="Heeeh !?"
		warn_log="$w_text"
		qst=0; ok_lbl='' ; cancel_lbl='Got it!edit-redo-rtl' ; kill_yad=0; warn_image='xkill'
		win_yad_warns
# 		if [ $? = 1 ]; then base_menu; fi
		if [ $y_output = 1 ]; then base_menu; fi
	}
# 	$p_wget -q -O $nvtmp/bug_list https://$nvidia_ftp-$ARCH/$LAST_PACK/
# 	{ $p_wget -q -O $nvtmp/bug_list https://$nvidia_ftp-$ARCH/$LAST_PACK/ &
# 		wget_pid=$(pgrep wget)
# 		while [ -d /proc/$wget_pid ]; do
# 			for ((i=1; i<=30; i++)) {
# 				echo $i
# 				sleep 0.096
# 			}
# 		done
# 		cat $nvtmp/bug_list | grep -E -o "href='NVIDIA.*[0-9]+.*'"| perl -pe "s/^.*\'(.*)\'/\1/p" \
# 		> $nvtmp/selector
# 	} | $d_yad --width=500 --window-icon=$img_zen_desktop --title="$_zen_title" --center --auto-close \
# 	--no-buttons --progress --pulsate --hide-text --borders=15 \
# 	--text="${v}Remote content control...${end}"

	y_text="${v}Remote content control...${end}"
	pulse=1; log=0; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{ timeout=30
	{	$p_wget -q -O $nvtmp/bug_list https://$nvidia_ftp-$ARCH/$LAST_PACK/ &
		cat $nvtmp/bug_list | grep -E -o "href='NVIDIA.*[0-9]+.*'"| perl -pe "s/^.*\'(.*)\'/\1/p" \
		> $nvtmp/selector
	} & eval lpid=$!; y_pulse; } | win_yad_progress

	if [ -s $nvtmp/bug_list ]; then
# 		(	cat $nvtmp/bug_list | grep -E -o "href='NVIDIA.*[0-9]+.*'"| perl -pe "s/^.*\'(.*)\'/\1/p" \
# 			> $nvtmp/selector
# 			sleep 2
# 		) | $d_zen --width=500 $win_icon --progress --pulsate --auto-close --text="${v}Remote content control...${end}"
		if [ $(cat $nvtmp/selector | grep -c "$LAST_PACK") -gt 0 ] ; then
			RUN_PACK=$(cat $nvtmp/selector)
		fi

		unset drv_list
		for line in $RUN_PACK; do
			drv_list+=("false")
			drv_list+=("$line")
		done
# 		run_pack=$($d_zen --width=450 --height=300 $win_icon --title="$_zen_title" --list \
# 		--text="${v}Choose the version to install${end}" --radiolist --hide-header \
# 		--column "set" --column "action"  --separator=";")

		IFS=$(echo -en "\n\b")
		l_text="${v}Choose the version to install${end}"
		cancel_lbl='Back to main!undo-tlr'; ok_lbl='Select!gtk-ok'; l_tail=0; w_head=0
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='500'; w_height='300'
		run_pack=$(win_yad_list "${drv_list[*]}")

		if [ $? -eq 1 ]; then
			IFS=$ifs
			[ $_opt -gt 0 ] && exit 0 || base_menu
# 			if [ $_opt -gt 0 ]; then IFS=$ifs; exit 0; else IFS=$ifs; base_menu; fi
		fi
		IFS=$ifs
		## from there, look into 'selector' file for sha256sum file.
		if [ $(cat $nvtmp/selector| grep -c "sha256sum") -gt 0 ]; then
			run_pack_sha=$run_pack.sha256sum
		fi
# 		( 	test $run_pack_sha && $p_wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack_sha $buildtmp/ &>/dev/null
# 			download_cmd | track
# 		) | $d_zen --width=500 $win_icon --progress --auto-close --title="$_zen_title"

		y_text="<b>Downlaoding ${j}$LAST_PACK${end} driver from ${y}$nvidia_ftp${end}</b>"
		pulse=0; log=0; hold=0 ; hide_txt=0; [ $hold = 1 ] && win_log_options
		{	test $run_pack_sha && $p_wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack_sha $buildtmp/ &>/dev/null
			download_cmd | track
		} | win_yad_progress
		err=$?
		if test $err -gt 128; then
			if pid=`ps -A | grep ."wget" | awk '{print $1}'`; then
					echo User aborted download, killing wget
					kill $pid
			fi
		fi
		# get weight of the pack in ko.
		_local=$(du -h $buildtmp/$run_pack | awk '{print $1}'| grep -o "[0-9]*")
		_remote=$(cat $nvtmp/bug_list | grep -A1 "$run_pack<"|sed -En "s/^.*>(.*)<\/.*>.*$/\1/g;2p"| grep -o "[0-9]*")
		if [ -f $buildtmp/$run_pack.sha256sum ]; then
			local_sha=$buildtmp/$run_pack.sha256sum
			sha256sum $run_pack
			sha256sum --status -c $local_sha
			if [ $? = 1 ]; then
				w_text="${j}<b>Download check sum error</b>${end}.\nTransaction aborted\nTry to restart driver download from <b>Update menu</b>"
				download_error
			fi
		fi
		if [ $_remote -ne $_local ]; then
			w_text="${j}<b>Download unexpected end</b>${end}.\nPlease restart driver download from <b>Update menu</b>"
			download_error
		fi
		return $err
   else
# 		icone='xkill'
# 		w_label="Got it!"
# 		w_text="${rB}$fatal_dev\Remote directory is empty.\n${end}${v}Nvidia devs have probably forgoten to upload data.\nFeel free to try at a later time.${end}"
# 		win_warning
		warn_log=$( cat <<-WRN
			${r}<b>$fatal_dev Remote directory is empty.</b>${end}
			Nvidia devs have probably forgoten to upload data.
			Feel free to try at a later time.
		WRN
		)
		qst=0; ok_lbl='' ; cancel_lbl='Got it!gtk-close' ; kill_yad=0; warn_image='xkill'
		win_yad_warns
# 		if [ $? -eq 1 ]; then [ $_opt -gt 0 ] && exit 0 || base_menu; fi
		if [ $y_output -eq 1 ]; then [ $_opt -gt 0 ] && exit 0 || base_menu; fi
# 		base_menu
	fi
}

## TOOLS ###

## common windows.
## available icons with or without yad predifined values.
# 	yad-about      About        help-about			|	yad-refresh    Refresh      view-refresh
# 	yad-add        Add          list-add			|	yad-remove     Remove       list-remove
# 	yad-apply      Apply        gtk-apply			|	yad-save       Save         document-save
# 	yad-cancel     Cancel       gtk-cancel			|	yad-search     Search       system-search
# 	yad-clear      Clear        document-clear	|	yad-settings   Settings     gtk-preferences
# 	yad-close      Close        gtk-no		|	yad-yes        Yes          gtk-yes
# 	yad-edit       Edit         gtk-edit			|	gtk-go-up		green rtl arrow
# 	yad-execute    Execute      system-run			|	gtk-go-down		yellow ltr arrow
# 	yad-no         No           gtk-no				|	gtk-undo-ltr	red down ltr arrow
# 	yad-ok         OK           gtk-ok				|	gtk-undo-rtl	red down rtl arrow
# 	yad-open       Open         document-open		|	edit-redo		yellow down ltr arrow
# 	yad-print      Print        document-print	|	edit-redo-rtl	yellow down rtl arrow
# 	yad-quit       Quit         application-exit	|

win_confirm(){
	## Popup confirmation window to be complete with the following vars:
	#	confirm_msg="[string]" #TEXT
	#	val_title="[string]"   #TEXT
	#	val_confirm="[string]" #TEXT
	#	val_back="[string]"    #TEXT
	#	val_cancel="[string]"  #CMD
	#	val_exit="[string]"    #EXIT CMD

	unset menu_list
	IFS=$(echo -en "\n\b")
	l_text="$confirm_msg\n\n${v}What do you want to do ?${end}"
	menu_list=( false 1 "$val_confirm" false 2 "$val_back" )
	cancel_lbl='Abort!undo-tlr'; ok_lbl='Do it!gtk-ok'; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='300'; w_height='0'
	confirm_w=$(win_yad_list "${menu_list[*]}")

	if [ $? = 1 ]; then IFS=$ifs; ${val_cancel} ; fi
	IFS=$ifs
	case $confirm_w in
		"1") shift ;;
		"2") ${val_exit};;
		*) ${val_cancel};;
	esac
}
win_yad_log(){
	# x_hold='--auto-close'/'' # define if progress window will aut close at the end of process or not.
	$d_yad --width=600 --height=300 --title "Zenvidia" --window-icon=$img_zen_desktop --progress --center --borders=15 \
 	--hide-text --enable-log='' --log-expanded --log-height=300 $x_hold \
 	--text="${v}$y_text${end}"
}
win_yad_warns(){
	# warn_log="[warn message string]"
	# qst=1/0 < is dialog a question ?
	# ok_lbl='[string]!icon'
	# cancel_lbl='[string]!icon'
	# warn_image='[image]' #> specific image
	# kill_yad=0/1 < do we need to kill parent window ?
	#
	# ex :
	#	warn, one button, no kill		>> qst=0; ok_lbl='' ; cancel_lbl='Close!gtk-no' ; kill_yad=0
	#	question, no kill on error	>> qst=1; ok_lbl='Ok!gtk-ok' ; cancel_lbl='Closse!gtk-no' ; kill_yad=0
	#	question, yad kill on error	>> qst=1; ok_lbl='Ok!gtk-ok' ; cancel_lbl='Close!gtk-no' ; kill_yad=1
	# y_output replace $?

	IFS=$(echo -en "\n\b")
	if [ $qst = 1 ]; then
		cancel_btn="--button=$cancel_lbl:1"
		ok_btn="--button=$ok_lbl:0"
		[ "$warn_image" != '' ] || warn_image=dialog-question
	else
		cancel_btn="--button=$cancel_lbl:1"
		ok_btn=''
		[ "$warn_image" != '' ] || warn_image=dialog-warning
	fi
	$d_yad --width=420 --height=100 --title="Zenvidia" --window-icon=$img_zen_desktop --center \
	--image=$warn_image --borders=20 --text="$warn_log" $cancel_btn $ok_btn $kill_parent
	y_output=$?
# 	[ $kill_yad = 0 ] || if [ $yad_pid -gt 0 ]; then kill $yad_pid; fi
	[ $kill_yad = 0 ] || if [ $YAD_PID -gt 0 ]; then kill $YAD_PID; fi
	IFS=$ifs

}
win_yad_progress(){
	# syntax :
	# with pulse :	{ timeout=xx ;{ [script] ;}& eval lpid=$!; y_pulse; } | win_yad_progress
	# progress :	{ [script] } | win_yad_progress
	# options :
	# [ $hold = 1 ] && win_log_options
	# y_text="[string]"
	# pulse=0/1		#> do pulse or not
	# log=0/1		#> display log window or not
	# hold=0/1		#> Hold window or not
	# hide_txt=0/1	#> Hide progress bar txt or not
	# extra options : hold options need other strings and depend of base script predefine option.
	# >> [ $hold = 1 ] && win_log_options	#> display hold message or not.
	# >> echo -e $esc_message" (without '' arround text var) inside script string shell '{...}'
	#
	# ex : with hold >> pulse=1; log=1; hold=1 ; hide_txt=1 ;[ $hold = 1 ] && win_log_options
	#		 autoclose with no progress bar text	>> pulse=1; log=1; hold=0 ; hide_txt=1
	#		 autoclose with progres bar text			>> pulse=1; log=0; hold=0 ; hide_txt=0

	[ $log = 1 ] && do_log="--height=300 --hide-text --enable-log='' --log-expanded --log-height=300 $x_hold"
	autoclose='--auto-close'; nobutton='--no-buttons'
	if [ $hold = 1 ]&&[ "$xt_hold" = 1 ]; then autoclose=''; nobutton=''; fi
	[ $hide_txt = 1 ] && hide_txt='--hide-text' || hide_txt=''
	[ $pulse = 1 ] && do_pulse='--pulsate '$autoclose || do_pulse=$autoclose
#  	[ $colors = 1 ] && w_colors='--fore='$fg_xterm' --background='$bg_xterm # ALERT on test
	[ "$YAD_PID" ] || YAD_PID=0
	$d_yad --width=500 --window-icon=$img_zen_desktop --title="Zenvidia" --center \
	--progress $nobutton $do_pulse $hide_txt --borders=15 --text="${v}$y_text${end}" $do_log $w_colors
}
win_yad_list(){
	# 	synbtax : IFS=$(echo -en "\n\b"); win_yad_list "${[list_array][*]}"; IFS=$ifs
	# 	options :
	#	l_text="[string]"
	# 	cancel_lbl="[string]"
	# 	ok_lbl="[string]"
	#	list_type='radiolist/checklist'
	# 	columns='1/2/3/etc'
	# 	col_name=( "[string]" "[string]" "etc") 	#> may not be filled.
	# 	sep=',/;/etc'
	# 	sel_col='0/1/2/etc' 		#> witch columns in the output
	# 	hid_col='0/1/2/1,2' 		#> unvisible columns
	# 	edit_col='0/1/2/1,2' 	#> editable columns
	# 	col_tip='0/1/2/etc' 		#> witch column to be used as tool tip text, must be set in hid_col var.
	#  l_tail='0/1'				#> tail at the end of the list.
	#
	# ex : col_name=( "[string]" "[string]")
	#  cancel_lbl='Back to main!undo-tlr'; ok_lbl='Select!gtk-ok'
	# 	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='600'; w_height='420'
	# or : list_type='checklist'; columns=5; col_name=( 'Set' 'Definition' 'Conf Set' 'Extra' '5' );
	# 	sel_col='0'; sep=';' ;hid_col='3,5'; edit_col=0; col_tip=3; w_width='550'; w_height='400'

	unset col_list w_dim #buttons
	[ $w_head = 0 ] && unset col_name
	for ((i=0; i<=$(($columns-1)); i++)) {
# 		if [ ${#col_name[*]} -gt 0 ]; then id=${col_name[$(($i-1))]}; no_head=''; else id=$i; no_head='--no-headers'; fi
		if [ ${#col_name[*]} -gt 0 ]; then id=${col_name[$i]}; no_head=''; else id=$i; no_head='--no-headers'; fi
		[[ "$hid_col" =~ $(($i+1)) ]] && EXTRA=':HD' || EXTRA=''
# 		[[ $i = 1 ]] && EXTRA=':CHK'
		col_list+=("--column=$id$EXTRA");
	}
	[ $w_width -gt 0 ] && w_dim+=( '--width='$w_width )
	[ $w_height -gt 0 ] && w_dim+=( '--height='$w_height )
# 	w_dim=( '--width='$w_width '--height='$w_height )
	[ "$edit_col" != 0 ] && { edit_col='--editable-cols='$edit_col; editable='--editable'; } || edit_col=''
	[ $col_tip -gt 0 ] && tip_col='--tooltip-column='$col_tip || col_tip=''
	[ $sel_col -gt 0 ] && sel_col='--print-column='$sel_col || sel_col=''
	[ $l_tail -gt 0 ] && l_tail='--tail' || l_tail=''
	[[ "$list_type" =~ "checklist" ]] && list_type=( --checklist --multiple $editable ) || list_type='--radiolist'
	buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" )
	# an additional option could be pass in $2.
	$d_yad ${w_dim[*]} --window-icon=$img_zen_desktop --title="Zenvidia" --borders=15 --center \
	--list ${list_type[*]} $no_head --separator=$sep $tip_col $sel_col $edit_col $l_tail \
	${col_list[*]} --text="$l_text" ${buttons[*]} ${1} ${2}

}
win_yad_text(){
	# 	log_brief="[output]"
	# 	syntax : win_yad_text "$log_brief"
	# 	options :
	# 	log_txt="[string]"
	# 	cancel_lbl="[string]"
	# 	ok_lbl="[string]"
	# 	w_formatted=0/1	#> dispkay markup formats.
	# 	w_wrap=0/1			#> wrap text to window.
	# 	w_width='bool'		#> window width.
	# 	w_height='bool'	#> window height.
	# 	all_btn=0/1			#> display cancel button only (0) or both (1).
	#  colors=0/1			#> set foreground, background colours.
	# 	ex : w_formatted=1; w_wrap=0; _width='600'; w_height='400'; all_btn=0
	#
	#  log_txt="[string]"; cancel_lbl="Exit!gtk-close"; ok_lbl="Back!edit-redo-rtl"
	#	w_formatted=1; w_wrap=1; w_width='600'; w_height='400'; all_btn=1; colors=1
	#	win_yad_text "$log_brief"

	unset w_dim buttons
# 	if [ -s $1 ]; then
	if [ -f "$1" ]; then
		input_way=$(< "${1}")
	else
		input_way=$(cat <<< "${1}")
	fi
	fore_c='#000'
	back_c='#B6AB99'
	[ $w_wrap = 1 ] && w_wrap='--wrap' || w_wrap=''
	[ $w_formatted = 1 ] && w_formatted='--formatted' || w_formatted=''
# 	w_dim=( '--width='$w_width '--height='$w_height )
	[ $w_width -gt 0 ] && w_dim+=( '--width='$w_width )
	[ $w_height -gt 0 ] && w_dim+=( '--height='$w_height )
	[ $all_btn = 1 ] && buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" ) || buttons="--button=$cancel_lbl:1"
	[ $colors = 1 ] && w_colors=( "--fore=$fg_xterm" "--back=$bg_xterm" )
	$d_yad ${w_dim[*]} --title="Zenvidia" --window-icon=$img_zen_desktop --text="$log_txt" --borders=15 --center "${2}" \
	--text-info $w_formatted --margins=10 $w_wrap --hscroll-policy=never ${w_colors[*]} ${buttons[*]} \
	<<< "$input_way"
}
win_open_switch(){
	if [ $open_drv -gt 0 ]; then
		if [ $_opt=1 ]&&[ -s $(user_CF_DIR)/old_basic.conf ]; then
			. $(user_CF_DIR)/old_basic.conf
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					drv_swt_message="${y}<b>Open Source driver</b>${end} will apply."
				else
					drv_swt_message="${y}<b>Closed Source driver</b>${end} will apply."
				fi
			else
				drv_swt_message="${j}<b>Open Source Driver</b>${end} will be removed."
			fi
			warn_log=$( cat <<-SPW
				${j}${bf}Task bar Driver switch${end}${end}

				<b>Nvidia Open driver configuration sets has been change</b>.
				$drv_swt_message
				${sf}<i>(driver license $($d_modinfo -F license nvidia -k $KERNEL) actualy loaded)</i>${end}

				Press button to apply.
				Confirmation window will be displayed.
			SPW
			)
			qst=0; ok_lbl=''; cancel_lbl='Apply!gtk-yes'; kill_yad=0
			win_yad_warns
			nv_open_switch
			rm -f $(user_CF_DIR)/old_basic.conf
			exit 0
		else
			old_open_drv=$open_drv
			old_use_open=$use_open
			if [ $use_open -gt 0 ]; then OPEN='TRUE'; PROP='FALSE'; else OPEN='FALSE'; PROP='TRUE'; fi
			l_text=$( cat <<-MSG
				${v}${j}${bf}Driver switch${end}${end}

				<b>Driver type selection (open source / proprietary)</b>.

				<i>( ${y}driver with license $($d_modinfo -F license nvidia -k $KERNEL) actualy loaded${end} )</i>${end}
			MSG
			)
# 			_title="$_zen_title"
# 			driver_swt=$($d_zen --width=500 --height=300 --list $win_icon --title="$_title" --text="$_text" \
# 			--column="check" --column="hide" --column="driver" --radiolist --print-column=2 --hide-column=2 \
# 			--separator='' --hide-header $PROP "0" "Load proprietary drivers" $OPEN "1" "Load Open Source Drivers")

# 			driver_swt=$($d_yad --width=500 --height=100 --list -title="Zenvidia" --window-icon=$img_zen_desktop \
# 			--text="$y_text" --borders=15 --center --list --radiolist --column="check" --column="hide" --column="driver" \
# 			--print-column=2 --hide-column=2 --separator='' --no-headers --button=Cancel:1 --button=Select:0 \
# 			$PROP "0" "Load proprietary drivers" $OPEN "1" "Load Open Source Drivers")

			unset list_array
			list_array=( $PROP "0" "Load proprietary drivers" $OPEN "1" "Load Open Source Drivers" )
			cancel_lbl='Cancel!undo-tlr'; ok_lbl='Select!gtk-ok'; l_tail=0; w_head=0
			list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='500'; w_height='0'
			IFS=$(echo -en "\n\b")
			driver_swt=$(win_yad_list "${list_array[*]}")
			IFS=$ifs

			if [ $? = 1 ]; then [ $_opt -gt 0 ] && exit 0 || menu_modif; fi
			if [ $? = 0 ]; then
				use_open=$driver_swt
				if [ $use_open -ne $old_use_open ]; then
					nv_open_switch
					[ $_opt -gt 0 ] && exit 0 || menu_modif
				fi
			fi
		fi
	fi
}

## PACKAGE MANAGING ###
manage_pcks(){
	w_height='--height=300'
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=300'
	else
		w_height='--height=400'
	fi
	hlp_tip=''
	w_text=$( cat <<-MSG

		${v}<b>Manage Drivers Packages</b>${end}:

		<u>Note</u> : <i>In case of issue after restoration (ex: driver not loading),
		try command line tools in first place after reboot.
		Many distro auto reload desktop manager at boot. If you meet this issue,
		you have to disable the desktop manager with systemcl before operating
		with "zenvidia rebuild [version]" command line</i>.
		MSG
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(cat <<-HLP

		${v}- <b>Remove downloaded packages</b>:
			Manage downloaded packages in Zenvidia directory.
		- <b>Backup tools</b>:
			Make a drivers and librairies backup of the current version.
		- <b>Restore tool</b>:
			Make a restoration of previously backed up drivers installation.
		- <b>Remove Nvidia and restore to default</b>:
			Remove completly Nvidia Drivers installation and restore default Nouveau drivers.${end}
		HLP
		)
		if [ $zenity_ver -le 3420 ]; then
			w_height='--height=400'
		else
			w_height='--height=500'
		fi
	fi
# 	menu_packs=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Manage drivers packages${end}${end}$w_text$hlp_tip" \
# 	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	false 1 "Remove downloaded package" false 2 "Backup tools" false 3 "Restore a backup" false 4 "Remove Nvidia and restore to default")
	unset list_array
	l_text="${j}${bf}Manage drivers packages${end}${end}$w_text$hlp_tip"
	list_array=( false 1 "Remove downloaded package" false 2 "Backup tools" false 3 "Restore a backup" false 4 "Remove Nvidia and restore to default" )
	cancel_lbl='Back to main!undo-tlr'; ok_lbl='Select!gtk-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b"); menu_packs=$(win_yad_list "${list_array[*]}")
	if [ $? = 1 ]; then IFS=$ifs; menu_modif; fi
	IFS=$ifs
	case $menu_packs in
		"1") remove_pcks ;;
		"2") backup_tools ;;
		"3") restore_pcks ;;
		"4") remove_nvidia ;;
		*) menu_modif ;;
	esac
}
remove_pcks(){
	# list package in release directory
	unset rm_packs packs_list
	for pack in $(ls -1 $nvdl); do
		packs_list+=("false")
		packs_list+=("$pack")
	done
	w_text=$( cat <<-MSG
		${j}<b>Remove downloaded package</b>${end}
		Select on or more packages to be removed.
	MSG
	)
# 	rm_packs=$($d_zen --width=400 --height=300 $win_icon --list --multiple \
# 	--checklist --hide-header --title="$_zen_title" \
# 	--text "${v}$w_text${end}" \
# 	--column "set" --column "action" --separator=" " \
# 	"${packs_list[@]}" )

	# win_yad_list
	l_text=$w_text
	cancel_lbl='Back to menu!undo-tlr'; ok_lbl='Select!gtk-ok'
	list_type='checklist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	IFS=$(echo -en "\n\b"); rm_packs=$( win_yad_list "${packs_list[*]}" )
	if [ $? = 1 ]; then IFS=$ifs; manage_pcks; fi
	IFS=$ifs

	# check that list not empty before proceed.
# 	if [[ $rm_packs ]]; then
	if [ ${#rm_packs[*]} -gt 0 ]; then
		w_text=$( cat <<-MSG
			Selected to be removed:
			${j}${rm_packs[*]}${end} driver(s).

			Please, confirm.
		MSG
		)
# 		$d_zen --width=300 $win_icon --title="$_zen_title" --question \
# 		--text="${vB}$w_text${end}" \
# 		--ok-label="$CC" --cancel-label="$PM"
# 		if [ $? = 0 ]; then
		# win_yad_warns
		warn_log="$w_text"
		qst=1; ok_lbl='Got it!gtk-ok' ; cancel_lbl='Back to menu!undo-rtl' ; kill_yad=0
		win_yad_warns
		if [ $y_output = 0 ]; then
			for vers in ${rm_packs[@]}; do
				pack_vers=$(printf "$vers"|sed -n "s/^.*-//g;p")
				vers_ref=$(printf "$pack_vers"|sed -n "s/\.//p")
				ls -d /var/lib/dkms/nvidia/$pack_vers &>/dev/null
				if [ $? = 0 ]; then
					w_text=$(cat <<-INFO
						${j}<b>$pack_vers still exist in DKMS tree</b>.${end}

						Remove all associated package and directory ?
						<i>(All reference in $nv_root will be also removed if found)</i>

						Please, confirm.
					INFO
					)
# 					$d_zen --width=300 $win_icon --title="$_zen_title" --question \
# 					--text="${v}$w_text${end}"
# 					if [ $? = 0 ]; then
					# win_yad_warns
					warn_log="$w_text"
					qst=1; ok_lbl='Got it!gtk-ok' ; cancel_lbl='Back to menu!undo-rtl' ; kill_yad=0
					win_yad_warns
					if [ $y_output = 0 ]; then
						if [[ $ver_pack = $ver_txt ]]; then
							w_text=$( cat <<-WRN
							<b>WARNING</b>
							The associated directory you're about to remove is the same as the actually running.

							This action will fataly break ${j}$pack_vers${end} installation
							You don't want to do this.

							Action skipped.
							WRN
							)
# 							$d_zen --height=100 $win_icon --title="$_zen_title" \
# 							$icon_name=xkill --error --no-wrap --text="${v}$w_text${end}" \
# 							--ok-label="I understand my mistake"
							# win_yad_warns
							warn_log="$w_text"
							qst=0; ok_lbl='' ; cancel_lbl='I understand my mistake!gtk-ok' ; kill_yad=0
							win_yad_warns
							manage_pcks
						else
							test -d $nv_root/nvidia.$pack_vers && rm -Rf $nv_root/nvidia.$pack_vers
# 							echo -e "$nv_root/nvidia.$pack_vers DKMS REMOVE"
							rm -f $nvdl/nv-update-$pack_vers
							$p_dkms remove nvidia/$pack_vers --all
							test -d /var/lib/dkms/open-nvidia/$pack_vers && $p_dkms remove open-nvidia/$pack_vers --all
						fi
					fi
				else
					test -d $nv_root/nvidia.$pack_vers && rm -Rf $nv_root/nvidia.$pack_vers
					test -f $nvdl/nv-update-$pack_vers && rm -f $nvdl/nv-update-$pack_vers
# 					echo -e "$nv_root/nvidia.$pack_vers REMOVE"
# 					echo -e "$nv_root/nvidia.$pack_vers REMOVE"
				fi
			done
# 			$d_zen --height=100 $win_icon --title="$_zen_title" \
# 			$icon_name=swiss_knife --info --text="${vB}Driver(s):\n${j}$rm_packs${end}\npackage(s) removed.${end}" --no-wrap
			# win_yad_warns
			warn_log=$( cat <<-MSG
				${v}<b>Driver(s)</b>:${end}
				${j}${rm_packs[*]}${end} package(s) removed.
			MSG
			)
			qst=0; ok_lbl='' ; cancel_lbl='Got it!gtk-ok' ; kill_yad=0
			win_yad_warns
			manage_pcks
		else
			manage_pcks
		fi
	else
		manage_pcks
	fi
}
remove_baks(){
	# list package in release directory
	unset rm_bak bak_list
	for back in $(ls -1 $nvbackup); do
		bak_list+=("false")
		bak_list+=("$back")
	done
	w_text=$( cat <<-MSG
		${j}<b>Remove backed up package</b>${end}
		Select on or more archives to be removed.
	MSG
	)
# 	rm_bak=$($d_zen --width=400 --height=300 $win_icon --list --multiple \
# 	--checklist --hide-header --title="$_zen_title" \
# 	--text "${v}$w_text${end}" \
# 	--column "set" --column "action" --separator=" " \
# 	"${bak_list[@]}" )
	# win_yad_list
	l_text=$w_text
	cancel_lbl='Back to menu!undo-tlr'; ok_lbl='Select!gtk-ok'
	list_type='checklist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	IFS=$(echo -en "\n\b"); rm_bak=$( win_yad_list "${bak_list[*]}" )

	if [ $? = 1 ]; then IFS=$ifs; manage_pcks; fi
	IFS=$ifs
	# check that list not empty before proceed.
# 	if [[ $rm_bak ]]; then
	if [ ${#rm_bak[*]} -gt 0 ]; then
# 		rem_list=$(echo -n "$rm_bak"| sed -En "s/ /\n/g;p")
# 		rem_list="${rm_bak[*]}"
		w_text=$( cat <<-MSG
			Selected driver(s) to be removed:
			${j}${rm_bak[*]}${end}

			Please, confirm.
		MSG
		)
# 		$d_zen --width=300 $win_icon --title="$_zen_title" --question \
# 		--text="${vB}$w_text${end}" \
# 		--ok-label="$CC" --cancel-label="$PM"
# 		if [ $? = 0 ]; then
		# win_yad_warns
		warn_log="$w_text"
		qst=1; ok_lbl='Got it!gtk-ok' ; cancel_lbl='Back to menu!undo-rtl' ; kill_yad=0
		win_yad_warns
		if [ $y_output = 1 ]; then
			manage_pcks
		else
			for vers in ${rm_bak[@]}; do
				test -f $nvbackup/$vers && rm -f $nvbackup/$vers
# 				echo -e "$nvbackup/$vers REMOVE"
			done
# 			$d_zen --height=100 $win_icon --title="$_zen_title" \
# 			$icon_name=swiss_knife --info --text="${vB}Driver(s) Archive(s) removed.${end}" --no-wrap
			# win_yad_warns
			warn_log="${vB}Driver(s) Archive(s) removed.${end}"
			qst=0; ok_lbl='' ; cancel_lbl='Got it!gtk-ok' ; kill_yad=0
			manage_pcks
# 		else
# 			manage_pcks
		fi
	else
		manage_pcks
	fi
}
remove_nvidia(){
## clean remove of nvidia packeges and nouveau restoration.
	## display warn before process. Zenity hare.
	w_text=$( cat <<-MSG
		${j}<b>NVIDIA driver installation will be completaly removed.</b>${end}
		Only Nouveau driver will usable after reboot.

		${y}Please, confirm.${end}
	MSG
	)
# 	$d_zen --width=300 $win_icon --title="$_zen_title" --question \
# 	--text="${vB}$w_text${end}" --ok-label="$CC" --cancel-label="$PM"
# 	if [ $? = 1 ]; then manage_pcks; fi
	# win_yad_warns
	warn_log="$w_text"
	warn_image='xkill'
	qst=1; ok_lbl='Got it!gtk-ok' ; cancel_lbl='Panic Button!undo-rtl' ; kill_yad=0
	if [ $y_output = 1 ]; then manage_pcks; fi

# 	{*
	y_text="${y}<b>Nvidia drivers complete removal</b>${end}"
	{ timeout=30 ;{
# 	echo -e "# Nvidia Removing ..."; sleep 2
	## nvidia version backup.
	if [ ! -f $nvbackup/nvidia.$(version).tar.gz ]; then
		echo -e "# Making security $(version) backup."; sleep 2
		backup_pcks
	fi
	echo -e "# Nvidia Installation removal ..."; sleep 2
	## then remove nvidia files.
		rm -f /etc/OpenCL/vendors/nvidia.ics
		rm -f /etc/ld.so.conf.d/nvidia-*
		test -f /etc/modprobe.d/open-NVIDIA.conf && rm -f /etc/modprobe.d/open-NVIDIA.conf
		test -f /etc/udev.d/01-nvidia-driver.rules && rm -f /etc/udev.d/01-nvidia-driver.rules
		rm -f /etc/modprobe.d/blacklist-nouveau.conf
		test -f /etc/modprobe.d/nvidia-drm.conf && rm -f /etc/modprobe.d/nvidia-drm.conf
		test -f /etc/modprobe.d/nvidia-blacklist.conf && rm -f /etc/modprobe.d/nvidia-blacklist.conf
		#rm -f /home/$(def_user)/.zenvidia/basic.conf
		rm -f /etc/X11/xorg.conf
		rm -f /etc/X11/xorg.conf.nvidia
		rm -f /etc/systemd/system/systemd-hibernate.service.wants
		rm -f /etc/systemd/system/systemd-suspend.service.wants
		rm -f /lib/modules/$KERNEL/$(module_dest_location)/nvidia*
		rm -f /lib/firmware/nvidia/$(version)
		rm -f $nv_root/nvidia
		rm -Rf $nv_root/nvidia.$(version)
		rm -f /usr/lib/systemd/system/nvidia-*
 		[ -d /usr/$master$ELF_32/nvidia ]&& rm -Rf /usr/$master$ELF_32/nvidia
 		[ -d /usr/$master$ELF_64/nvidia ]&& rm -Rf /usr/$master$ELF_64/nvidia
		rm -f /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so
		rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*
		rm -Rf /usr/src/nvidia-$(version)
		if [ -d /usr/src/open-nvidia-$(version) ]; then
			rm -Rf /usr/src/open-nvidia-$(version)
		fi
		rm -f $install_dir/bin/nvidia-*
		if [[ $(ls -1 /usr/local/$master$ELF_32/libnvidia-*| grep -c $(version)) -gt 0 ]]; then
			rm -f $install_dir/$master$ELF_32/libnvidia-*
			rm -f $install_dir/$master$ELF_64/libnvidia-*
		else
			rm -f $install_dir/$master$ELF_64/libnvidia-*
 		fi
 		rm -Rf $install_dir/share/nvidia
 		rm -f /usr/share/nvidia
		rm -Rf /var/lib/dkms/nvidia
		[ -d /var/lib/dkms/open-nvidia ] && rm -Rf /var/lib/dkms/open-nvidia
		rm -Rf /var/lib/nvidia*
		rm -f $nvdir/version.txt

		echo -e "# Libraries registry update."; sleep 2
		## retore library path to default.
		ldconfig
		echo -e "# Grub update."; sleep 2
		test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='rhgb quiet'
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$grub_orig\"/" $grub_def
		$d_grub-mkconfig -o $grub_cfg
		echo -e "# Perform modules dependencies and initramfs update."; sleep 2
		## restore kernel sys link to default.
		#exec_depmod : depmod -a
		progress_msg(){ echo -e "# Depmod $KERNEL modules ($m sec.)"; }; m=0; do_slp=1
		progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c
		progress_msg(){ echo -e "# Exec $KERNEL modules init/reload ($m sec.)"; }; m=0; do_slp=1
		exec_initramfs
# 		} | $d_zen $win_icon --width=450 --title="$_zen_title" --progress --pulsate --auto-close
		# win_yad_progress
		pulse=1; log=0; hold=0 ; hide_txt=0
		}& eval lpid=$!; y_pulse; } | win_yad_progress
		w_text=$( cat <<-MSG
			${j}<b>NVIDIA driver installation is now completaly removed</b>${end}.

			Restart the computer for change to take effect.

		MSG
		)
# 		icone='xkill'
# 		w_label="Got it!"
# 		w_text="${vB}$w_text${end}"
# 		win_warning
		# win_yad_warns
		warn_log="$w_text"
		#warn_image='xkill'
		qst=0; ok_lbl='' ; cancel_lbl='Got it!edit-redo-rtl' ; kill_yad=0
		win_yad_warns
		base_menu
}
backup_tools(){
# 	if [ $zenity_ver -le 3420 ]; then
# 		w_height='--height=180'
# 	else
# 		w_height='--height=280'
# 	fi
	hlp_tip=''
	w_text=$( cat <<-MSG

		${v}Select the driver tool to use.${end}
	MSG
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$( cat <<-INFO

			${v}<b>Make a backup</b> :
			- Back up the current isntalled driver installation.
			<b>Remove a backup</b> :
			- Remove archived installation driver packages.
			${end}
		INFO
		)
	fi
# 	menu_backup=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Backup manager${end}${end}$hlp_tip$w_text" \
# 	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	false 1 "Make a backup" false 2 "Remove a backup")
# 	if [ $? = 1 ]; then menu_modif; fi

	unset list_array
	l_text="${j}${bf}Backup manager${end}${end}$hlp_tip$w_text"
	list_array=( false 1 "Make a backup" false 2 "Remove a backup" )
	cancel_lbl='Back to main!undo-tlr'; ok_lbl='Select!gtk-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b"); menu_backup=$(win_yad_list "${list_array[*]}")
	if [ $? = 1 ]; then IFS=$ifs; menu_modif; fi
	IFS=$ifs
	case $menu_backup in
		"1") backup_pcks ;;
		"2") remove_baks ;;
		*) manage_pcks ;;
	esac
}
backup_pcks(){
	bak_version=$(version)
	if [ -f $nvbackup/nvidia.$bak_version.tar.gz ]; then
# 		$d_zen --width=250 --height=100 $win_icon --title="$_zen_title" --info \
# 		$icon_name=swiss_knife --no-wrap \
# 		--text="${j}$bak_version${end}${v} is already backed up.\nNo reason to do it again.${end}"
		warn_log=$(cat <<-MSG
			${j}$bak_version${end} is already backed up.
			No reason to do it again.

			Do you want to overwrite ?
		MSG
		)
		qst=1; ok_lbl='Overwrite!gtk-ok' ; cancel_lbl='No!gtk-no' ; kill_yad=0
		win_yad_warns
		if [ $y_output = 1 ]; then menu_modif; fi
	else
# 		w_text=$( cat <<-WRN
		warn_log=$( cat <<-WRN
			You are going to backup ${j}$bak_version${end} driver installation

			Please, confirm.
		WRN
		)
# 		$d_zen --width=250 --height=100 $win_icon --title="$_zen_title" --question \
# 		--text="${v}$w_text${end}" \
# 		--ok-label="$CC" --cancel-label="$R"
		qst=1; ok_lbl='Ok!gtk-ok' ; cancel_lbl='Close!gtk-no' ; kill_yad=0
		win_yad_warns
		if [ $y_output = 1 ]; then menu_modif; fi
	fi
	if [ $? = 0 ]; then
# 		( backup_old_version ) | $d_zen --width=450 $win_icon --title="$_zen_title" --progress  \
# 		--text="Backup : $bak_version backup archive creation" --auto-close
		y_text="Backup : $bak_version backup archive creation"
		pulse=0; log=0; hold=0 ; hide_txt=0
		{ backup_old_version; } | win_yad_progress
		manage_pcks
	else
		manage_pcks
	fi
}
restore_pcks(){ # ALERT TMP_C
	alert_message(){
	# current version overwrite ALERT message
		warn_log=$( cat <<-WRN
			${jB}Driver install overwrite${end}

			${v}The backup you are going to restore is the same as the one used by the system.

			To prevent data loss when restoring and others ugly deasagrements (like X server crash),
			Zenvidia wont replace the actual install by overwriting ${j}$res_version${end} over itself.

			If you really wish to overwrite, use the command line tool with desktop manager
			service disabled and closed the actual desktop session
			(<i>ex: systemctl disable $dm_serv.service</i>)${end}
		WRN
		)
# 		$d_zen --error --title="$_zen_title" $icon_name=xkill \
# 		--text="$warning_msg" --no-wrap --ok-label="Thanks for the advice!"
		qst=0; ok_lbl='' ; cancel_lbl='Close!gtk-no' ; kill_yad=0
		win_yad_warns
		base_menu
	}
	nv_build_options
	# list package in release directory
	from_install=0
	unset drive_list
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	nv_root_repo=$(ls -1 $nvbackup | grep "nvidia."| sed -n "s/.tar.gz//p")
	for drive in $nv_root_repo; do
		drive_list+=("false")
		drive_list+=("$drive")
	done
	l_text=$( cat <<-MSG
		${j}${bf}Restoration tool${end}${end}

		Driver actually loaded $(drv_installed)

		${v}Select the driver you want to restore.${end}
	MSG
	)
# 	drive_packs=$($d_zen --width=400 --height=300 $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "$w_text" --column "set" --column "action" --separator=";" \
# 	"${drive_list[@]}" )

	cancel_lbl='Back to main!undo-tlr'; ok_lbl='Select!gtk-ok'
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	IFS=$(echo -en "\n\b"); drive_packs=$(win_yad_list "${drive_list[*]}"); IFS=$ifs

	if [ $? = 1 ]; then manage_pcks; fi
	# check that list not empty before proceed.
	if [[ $drive_packs ]]; then
		export present_version=$(mktemp --tmpdir zn_old.XXX)
		rem_tmp+=("rm -f $present_version")
		trap "${rem_tmp[*]}" EXIT
		res_version=$(printf "$drive_packs"|sed -n "s/nvidia.\([0-9]*\)/\1/p")
		ver_res=$(printf "$res_version"| sed -n "s/\.//g;p")
		ver_mod=$(printf "$(version)"| sed -n "s/\.//g;p")
		echo "$(version)" > $present_version
# 		old_back_version=$(cat $present_version)
		if [ ! -d $nv_root/$drive_packs ]; then
			confirm_msg="${v}Restoring ${j}$res_version${end} will replace actual${end} ${j}$(version)${end}."
			val_title="Zenvidia"
			val_confirm="Yes, restore and replace."
			val_back="Back to menu"
			val_cancel="base_menu"
			val_exit="manage_pcks"
			win_confirm
			## win yad options
			y_text=${v}Restore driver $res_version and missing modules.${end}
			pulse=1; log=0; hold=0 ; hide_txt=0
			## $d_zen window open here.
# 			{
			{ timeout=30 ;{
			echo -e "# Restoring from nvidia.$res_version.tar.gz..."; sleep 2
			if [ "$res_version" != "$(version)" ]; then
				rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$(version)
				rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$(version)
				rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$(version)
			fi
			# p: preserve perm, h: preserve sym, f: file.
			progress_msg(){ echo -e "# ($m sec.) - Restoring from nvidia.$res_version.tar.gz"; echo "$m"; }
			m=1; do_slp=1;progress "tar -zxf $nvbackup/nvidia.$res_version.tar.gz -C /" #; rm -f $tmp_c # ALERT
			ldconfig
			progress_msg(){ echo -e "# ($m sec.) - Rebuild modules dependencies (depmod)"; echo "$m"; }
			m=1; do_slp=1 ; progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c # ALERT
			## restore or rebuild drivers.
			$d_modinfo -F version nvidia -k $KERNEL | grep "$res_version" &>/dev/null
			if [ $? -eq 1 ]; then
				echo -e "# Rebuilding missing $res_version drivers for $KERNEL kernel.."
				sleep 2
				rt_options
				if [ -d /usr/src/nvidia-$res_version ]||[ -d /usr/src/open-nvidia-$res_version ]; then
# 					version(){ echo $res_version; }
					restore_msg=" (restored)"
					driver_logfile=$nvlog/$(version)-$KERNEL.log
					tmp_b=$(mktemp --tmpdir zn_vars.XXX)
					rem_tmp+=("rm -f $tmp_b")
					trap "${rem_tmp[*]}" EXIT
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo -e "# FAILURE : DKMS compilation ERROR !!"; sleep 2
						echo -e "# FAILURE : See 'update modules menu' to force build."; sleep 2
						manage_pcks
					fi
				else
					echo -e "# FAILURE : No source directory found for $res_version"; sleep 2
					manage_pcks
				fi
				## exec_mod_load is useless here, a modprobe reload all doesn't catch change on kernel init.
				progress_msg="Rebuilding INITRAMFS (required)\t\t\t"
				msg_suffix=" sec."
				progress_msg(){ echo "# ($m sec.) - Rebuilding INITRAMFS"; echo "$m"; }; m=1; do_slp=1
				exec_initramfs
			else
				echo -e "# Clear : $res_version modules checked in $KERNEL kernel."
				sleep 2
				echo -e "# Restore $res_version modules system symlinks for $KERNEL kernel."
				# exec_mod_load seems to work here when archive modules are already build for active kernel.
				exec_mod_load
				## when it want, so fallback to initramfs.
# 				progress_msg(){ echo "# ($m sec.) - Rebuilding INITRAMFS"; echo "$m"; }; m=1; do_slp=1
# 				exec_initramfs
			fi
			## remove /opt/nvidia.prev_version for compatibility future restore purpose
# 			test -d $nv_root/nvidia.$(old_version) && rm -Rf $nv_root/nvidia.$(old_version)
			if [ -d $nv_root/nvidia.$(old_version) ]&&[ "$(old_version)" != "$res_version" ]; then
				rm -Rf $nv_root/nvidia.$(old_version)
			fi
# 			}| $d_zen --width=450 --title="$_zen_title" $win_icon --progress --pulsate --auto-close \
# 			--text="${v}Restore driver $res_version and missing modules.${end}"
			} & eval lpid=$!; y_pulse; } | win_yad_progress
		else
			# current version overwrite ALERT message
			alert_message
		fi
	else
		manage_pcks
	fi
	manage_pcks
}

## EDITION TOOLS ###
edit_script_conf(){
	## build list
	unset conf_list orig_conf cnf_list conf_base conf_chg
	IFS=$(echo -en "\n\b")
	conf_list=( $(cat $basic_conf | sed -En "s/^# (.*):.*/\1/p") )
	old_conf=$(user_CF_DIR)/old_basic.conf
	test -s $old_conf && rm -f $old_conf
	for conf_set in "${conf_list[@]}"; do
		cnf_text="$conf_set"
		setted=$(grep -A1 "$cnf_text" $basic_conf | sed -n "2p")
		set_id=$(echo "$setted"|sed -En "s/(.*)=(.*)/\1/p")
		set_val=$(echo "$setted"|sed -En "s/(.*)=(.*)/\2/p")
		if [ $set_val -gt 0 ]; then setted='TRUE'; else setted='FALSE'; fi
		if [ $set_val -gt 1 ]; then extra_val=$set_val; else extra_val='none'; fi
		cnf_list+=("$setted")
		cnf_list+=("$cnf_text")
		cnf_list+=("$set_id")
# 		cnf_list+=("$set_val")
		cnf_list+=("$extra_val")
		cnf_list+=("$set_val")
# 		cnf_list+=("|")
		orig_conf+=("$set_id;$extra_val;$set_val")
	done
	help_tip="${v}\nDefine options and functions you would like to use of change\n${end}"
# 	if [ $zenity_ver -le 3420 ]; then
# 		w_height='--height=500'
# 	else
# 		w_height='--height=600'
# 	fi
	[ $_opt -gt 0 ] && cancel_lbl='Exit!undo-ltr' || cancel_lbl='Back to menu!undo-ltr'
	ok_lbl='Apply!gtk-ok'; list_type='checklist'; columns=5; col_name=( 'Set' 'Definition' 'Conf Set' 'Extra' '5' )
	sel_col='0'; sep=';'; hid_col='3,5'; edit_col=4; col_tip=3; w_width='580'; w_height='500'; l_tail=0; w_head=1
	l_text="${j}${bf}Zenvidia Configuration${end}$help_tip${end}"

	conf_base=$( win_yad_list "${cnf_list[*]}" )

	## output : use help tip;hlp_txt;0;cairo;1;28 etc
	if [ $? = 1 ]; then
		IFS=$ifs
		test -s $old_conf && rm -f $old_conf
		[ $_opt -gt 0 ] && exit 0 || base_menu
	fi
# 	IFS=$ifs
	## split ouput in readable list
	## and remove blank lines.
	conf_orig=( $orig_conf )
# 	conf_chg=( $(echo -e "${conf_base[*]}"|sed -n "s/#/\n/g;p"|sed -n "s/^;\|;$//g;p"|\
# 	sed -n "/^[[:space:]]*$/d;s/^\ //i;p") )

	## some previous set have to be saved before read and change.
	old_drm_modset=$drm_modset
	[ $_opt = 1 ] && echo -e "old_drm_modset=$drm_modset" > $old_conf
	## check open_drv setiing before changing anything
	if [ $open_drv ]; then
		old_open_drv=$open_drv
		if [ $use_open ]; then old_use_open=$use_open; fi
		[ $_opt = 1 ] && echo -e "old_open_drv=$open_drv" >> $old_conf
		[ $_opt = 1 ] && echo -e "old_use_open=$use_open" >> $old_conf
	fi
	## modify new set value.
# 	for output in ${conf_chg[@]}; do

	for output in ${conf_base[@]}; do
# 			set=$(echo "$output"| cut -d';' -f1| sed -n "s/(\|)//g;p")
			set=$(echo "$output"| cut -d';' -f3)
			value=1
# 			bis_value=$(echo "$output"| cut -d';' -f3)
			bis_value=$(echo "$output"| cut -d';' -f4)
			if [[ "$bis_value" ]]&&[[ "$bis_value" != 'none' ]]; then value=$bis_value; fi
			if [ $(grep -E -c "$set=$value" $basic_conf) -eq 0 ];then
# 				sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
				sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
				if [[ $set == "use_open" ]]; then export use_open=$value; fi
				eval $set=$value
			fi
	done
	## modifiy unset value.
	for input in ${orig_conf[@]}; do
		if [ $(grep -c "$input" <<< ${conf_base[@]}) -eq 0 ]; then
# 			set=$(echo "$input"| cut -d';' -f1| sed -n "s/(\|)//g;p")
			set=$(echo "$input"| cut -d';' -f1)
# 			set=$(echo "$input"| cut -d';' -f3)
			value=0
			bis_value=$(echo "$input"| cut -d';' -f2)
# 			bis_value=$(echo "$input"| cut -d';' -f4)
			if [[ "$bis_value" ]]&&[[ "$bis_value" != 'none' ]]; then value=$bis_value; fi
			if [[ $set != 'xt_delay' ]]; then
				if [ $(grep -E -c "$set=$value" $basic_conf) -eq 0 ];then
# 					sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
					sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
					if [[ $set == "use_open" ]]; then export use_open=$value; fi
					eval $set=$value
				fi
			fi
		fi
	done
	IFS=$ifs
	[ $_opt = 1 ] && echo -e "open_drv=$open_drv" >> $old_conf
	[ $_opt = 1 ] && echo -e "use_open=$use_open" >> $old_conf
	if [ $UID = 0 ]||[ $_opt = 0 ]; then
		## remove old_basic that could confised script with other external functions
		rm -f $old_conf
		## if drm_modset is change nivdia modprobe options has to be change accordingly.
		if [ $drm_modset -ne $old_drm_modset ]; then
			y_text="Reconfigure grub and/or modules options sets"
			pulse=1; log=1; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options

			{ timeout=30; { blacklist_and_grub_set; } & eval lpid=$!; y_pulse; } | win_yad_progress

# 			blacklist_and_grub_set | win_yad_log
	# 		echo "options nvidia_drm modeset=$drm_modset" > /etc/modprobe.d/nvidia-drm.conf
		fi
		if [ $use_open -ne $old_use_open ]; then
			qst=1; ok_lbl="Yes, apply!gtk-ok"; cancel_lbl="No, I'll apply later!gtk-close"; kill_yad=0
			warn_log=$( cat <<-WRN
				${jB}Open Driver Switch${end}
				${v}<b>Open driver settings have been change</b>.

				Do you want to apply now ?${end}
			WRN
			)
			win_yad_warns
# 			if [ $? = 0 ]; then
			if [ $y_output = 0 ]; then
				## if open_drv is change, DKMS autoinstall boot time command has to be change by adding the blank file
				## 'no-autoinstall' in /etc/dkms directory. Method seems to work without issue except for package manager
				## udpate program that apprently need 'autoinstall all' to be set (fedora here).
				if [ $open_drv -ne $old_open_drv ]; then
					if [ $open_drv = 1 ]; then
						touch /etc/dkms/no-autoinstall
					else
						test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
					fi
				fi
				nv_open_switch
			fi
		fi
		## if use_open is change, then apply open/close source switch.
# 		if [ $use_open -ne $old_use_open ]; then
# 			w_text=$( cat <<-WRN
# 				${jB}Driver Switch${end}
# 				${vB}Open driver settings have been change.
#
# 				Do you want to apply now ?${end}
# 			WRN
# 			)
# 			$d_zen --width=450 --title="$_zen_title" $win_icon --question --no-wrap \
# 			--text="$w_text" $icon_name=xkill --cancel-label="No, I'll apply later" --ok-label="Yes, apply"
# 			if [ $? = 0 ]; then
# 				nv_open_switch
# 			fi
# 		fi
	else
		if [ $old_open_drv -ne $open_drv ]||[ $old_use_open -ne $use_open ]; then
			qst=0; ok_lbl=''; cancel_lbl='Got it!gtk-yes'; kill_yad=0
			warn_log=$( cat <<-WRN
				${jB}Driver Switch${end}
				${v}<b>Open driver settings have been change.</b>

				${j}You don't have superuser priviledges${end}.
				Please launch ${y}Open Driver switch${end} task bar menu entry to apply.${end}
			WRN
			)
			win_yad_warns
		fi
		exit 0
	fi
	## then go back to Section Menu.
	menu_modif
}
edit_color_conf(){
	## color tmep file test preview
	if ! [ "$color_TMP" ]; then
	color_TMP=$(mktemp --tmpdir nv_color.XXXX)
	cat $color_conf > $color_TMP
	rem_tmp+=("rm -f $color_TMP")
	trap "${rem_tmp[*]}" EXIT
	fi
	edit_color_gui(){
		test_text=$(
		cat <<-SPL
			DISPLAY PREVIEW :
			${rBB}TITLE${end}
			${j}${bf}Sub TTILE${end}${end}
			TEXT, main and alternate text :
			${v}Once upon a time in south west ? I don't care !${end}.
			${y}But I can alternate between Est and West,
			but I still don't care ...${end}.
			LOGS :
			${vB}Command cleared${end}\t\t${gB}passed${end}\t> ${y}log message values.${end}
			${vB}Command issue warning${end}\t${jB}warning${end}\t> ${y}log message values.${end}
			${vB}Command non fatal error${end} ${rB}error${end}\t\t> ${y}log message values.${end}
		SPL
		)
		w_text=$(
		cat <<-TXT
			${j}${bf}Basic font colors and style${end}${end}
			${v}Change GUI font colors to fit your desktop theme.${end}
		TXT
		)
		sample=$(
		cat <<-SPL
			${rBB}TITLE${end}\t${j}${bf}Sub TTILE${end}${end}
			${v}main text${end} ${y}Log messages${end}
			${gB}Log cleared${end} ${jB}Log warnings${end} ${rB}Log Errors${end}
		SPL
		)
		w_tip=$(
		cat <<-TIP
			${j}NOTICE${end}${v}: Colors will appled immediatly after validation.
			Do not forget Xterm only support a limited type of colors.${end}
			${y}Xterm colors are also applied to Yad's text logging windows.${end}
		TIP
		)
		style1=$(grep -E -io "[a-z]*$" <<< $font1)
		style0=$(grep -E -io "[a-z]*$" <<< $font0)
		font_color=$(
		$d_yad --width=300 --height=300 --title "Zenvidia" --center \
			--window-icon=$img_zen_desktop --text "$w_text" \
			--button='Abort:1' --button='Preview;;Reload with newly setted values:2' --button='Done:0' \
			--form --separator="|" --item-separator=";" --borders=15 --field="":LBL '' \
			--field="${v} Title and warning messages font color${end}":CLR "$title" \
			--field="${v} Sub window title font color${end}":CLR "$sub" \
			--field="${v} Main window font color\t\t${end}":CLR "$main" \
			--field="${v} Log message font color\t\t${end}":CLR "$log_msg" \
			--field="${v} Log clear font color\t\t${end}":CLR "$log_grn" \
			--field="${v} Log warning font color\t\t${end}":CLR "$log_warn" \
			--field="${v} Log error font color\t\t${end}":CLR "$log_err" \
			--field="${v} Sub Titles font type${end}":FN "$font1 $style1 $size1" \
			--field="${v} Normal font type${end}":FN "$font0 $style0 $size0" \
			--field="":LBL '' \
			--field="${v} Xterm forground color${end}":CLR "$fg_xterm" \
			--field="${v} Xterm background color${end}":CLR "$bg_xterm" \
			--field="":LBL '' \
			--field="$w_tip":LBL '' \
			--field="":LBL '' \
			--field="$test_text":LBL ''
		)
		out=$?
		if [ $out = 0 ]; then
			menu=menu_modif
		elif [ $out = 1 ]; then
			base_menu
		elif [ $out = 2 ]; then
			menu="$@ edit_color_gui"
		fi
		if [ $out -eq 2 ]; then
			color_temp=$color_TMP
		else
			color_temp=$color_conf
		fi
		IFS=$(echo -en "\n\b")
		unset input_colors output_colors output_conf
		input_colors=$(cat $color_temp | cut -d'=' -f1)
		output_colors=( $(echo -e "$font_color"| sed -En "s/^\||[\|]{3}$//g;s/\|/\n/g;p") )
		C=0
		for type in ${input_colors[@]}; do
			if [[ $type =~ font* ]]; then
				font_n=$(echo "$type"| grep -o "[0-9]")
				eval style=\$'style'$font_n
				new_font=$(echo "${output_colors[$C]}"|grep -E -io ".*[a-z]")
				new_style=$(echo "$new_font"|awk '{print $3}')
				if [[ $new_style == '' ]]; then stylish=' '$style; else stylish=''; fi
				output_conf+=("$type;$new_font$stylish")
				shift 0
			elif [[ $type =~ size* ]]; then
				output_conf+=("$type;$(echo "${output_colors[$C]}"|grep -E -o "[0-9].*$")")
				((C++))
			else
				output_conf+=("$type;${output_colors[$C]}")
				((C++))
			fi
		done
		for sets in ${output_conf[@]}; do
			setting=$(printf "$sets"| cut -d';' -f1)
			value=$(printf "$sets"| cut -d';' -f2)
			if [ $(grep -c "$setting='$value'" $color_temp) -eq 0 ]; then
				sed -Ei "s/^($setting)=.*$/\1='$value'/g" $color_temp
			fi
		done
		IFS=$ifs
		if [ $out -eq 2 ]; then
			. $color_temp
			zen_colors
		fi
		${menu}
	}
	if [ $d_yad ]; then
		edit_color_gui
	fi
}
edit_xorg_conf(){ # TODO YAD
	xorg_cfg=/etc/X11/xorg.conf.nvidia
	hlp_tip=$(
	cat <<-HLP
	${v}Edit or manage Xorg config and options.${end}

	HLP
	)
	menu_xorg=$($d_zen --width=400 --height=300 $win_icon --list \
	--radiolist --hide-header --title="$_zen_title" \
	--text "${j}${bf}Edit Xorg Config File${end}${end}\n$hlp_tip" \
	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
	TRUE 1 "Edit full Xorg config file" FALSE 2 "Manage Device Options only" FALSE 3 "Execute Xorg auto config")
	if [ $? = 1 ]; then
		if [ $from_install = 0 ]; then
			[ $_opt -gt 0 ] && exit 0 || menu_modif
		fi
	fi
	case $menu_xorg in
		"1") edit_xorg_full_text ;;
		"2") edit_xorg_options ;;
		"3") xorg_conf; edit_xorg_conf ;;
	esac
}
edit_xorg_options(){ # TODO YAD
	unset options options_list options_orig options_new options_old
	IFS=$(echo -en "\n\b")
	options=$(sed -En '/Section "Screen"/,/EndSection/p' $xorg_cfg| grep "Option")
	for e in $pci_dev_nb; do
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			options=$(sed -En "/Identifier.*\"Device${dev_n[$e]}\"/,/EndSection/p" $xorg_cfg| grep "Option")
		fi
	done
	for line in ${options[@]}; do
		if [[ $line =~ \#.*$ ]]; then setted='FALSE'; else setted='TRUE'; fi
		option=$(printf "$line"| sed -En "s/^.*Option\t(\".*\") (\".*\")$/\1/p"|sed -n "s/\"//g;p")
		if [ ! $option ]; then
			option=$(printf "$line"| sed -En "s/^.*Option\t(\".*\")$/\1/p"|sed -n "s/\"//g;p")
		fi
		value=$(printf "$line"| sed -En "s/^.*Option\t(\".*\") (\".*\")$/\2/p"|sed -n "s/\"//g;p")
		options_list+=("$setted")
		options_list+=("$option")
		options_list+=("$value")
		options_list+=("#")
		options_orig+=("$option;$value")
	done
	hlp_tip=$(
	cat <<-HLP
	${v}Select/unselect options you need.

	Options added manually will be displayed here also.${end}

	HLP
	)
	if [ $zenity_ver -le 3420 ]; then
		w_height='--height=500'
	else
		w_height='--height=600'
	fi
	options_conf=$($d_zen --width=550 $w_height $win_icon --list \
	--multiple --editable --checklist --title="$_zen_title" \
	--text "${j}${bf}Zenvidia Configuration${end}${end}\n${v}$hlp_tip${end}" \
	--column "Set" --column "Option" --column "Set" \
	--column "4" --hide-column=4 \
	--print-column=2,3,4 \
	--separator=";" \
	"${options_list[@]}" )
	if [ $? = 1 ]; then IFS=$ifs; edit_xorg_conf; fi
	options_old=( $(echo -e "${options_orig[*]}") )
	options_new=( $(echo -e "${options_conf[*]}"|sed -n "s/#/\n/g;p"|sed -n "s/^;\|;$//g;p"|\
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p") )

	## modify new set value.
	for output in ${options_new[@]}; do
			output_set=$(echo "$output"| cut -d';' -f1)
			value=$(echo "$output"| cut -d';' -f2)
			if [[ "$value" ]]; then reg_val=' (\".*\")' ; opt_val=" \"$value\""; else reg_val=''; opt_val=''; fi
			if [ $(grep -c "^#.*$output_set" <<< $options ) -gt 0 ]|| \
			[ $(grep -c "$output_set.*$value" <<< $options) -eq 0 ]; then
				sed -Ei "s/^[#]?(.*Option\t\"$output_set\")$reg_val/\1$opt_val/" $xorg_cfg
			fi
	done
	## modifiy unset value.
	for input in ${options_orig[@]}; do
		input_set=$(echo "$input"| cut -d';' -f1)
		value=$(echo "$input"| cut -d';' -f2)
		if [ $(grep -c "$input_set" <<< $options_conf) -eq 0 ]; then
			if [ $(grep -E -c "#.*Option.*\"$input_set\"" $xorg_cfg) -eq 0 ];then
				if [[ "$value" ]]; then reg_val=' (\".*\")' ; opt_val=" \"$value\""; else reg_val=''; opt_val=''; fi
				sed -Ei "s/^(.*Option\t\"$input_set\")$reg_val/#\1$opt_val/" $xorg_cfg
			fi
		fi
	done
	IFS=$ifs
	edit_xorg_conf
}
edit_xorg_full_text(){ # TODO YAD
	edit_xorg=$($d_zen --width=500 --height=400 $win_icon --title="$_zen_title" --text-info --editable \
	--text="${v}Edit xorg config file${end}" --filename="$xorg_cfg" \
	--checkbox="Confirm to overwrite" )
	if [[ $(printf "$edit_xorg"| sed -n '1p') != '' ]]; then
		printf "$edit_xorg\n" > $xorg_cfg
	fi
	if [ $? = 0 ]; then
		[ $_opt -gt 0 ] && exit 0 || edit_xorg_conf
	fi
}
edit_distro_conf(){
	## warn about no config file
# 	w_text=$(cat <<-WRN
	warn_log=$(cat <<-WRN
	${j}<b>You are going to modify $plug_version configuration file</b>${end}

	Variables and datas from this file are very sensitives and could potentialy
	breaks Zenvidia.

	${r}<i>Are you sure about what you are doing ?</i>${end}

	WRN
	)
# 	$d_zen --width=450 $win_icon --title="$_zen_title" --question --no-wrap \
# 	--text="${vB}$w_text${end}" --ok-label="I live dangerously" --cancel-label="Well, I'm finally a coward"
# 	if [ $? = 1 ]; then menu_modif; fi

	# warn
	qst=1; ok_lbl='I live dangerously!gtk-ok' ; cancel_lbl="Well, I'm finally a coward!undo-rtl" ; kill_yad=0
	win_yad_warns
	if [ $y_output = 1 ]; then menu_modif; fi

	## edit config file.
# 	edit_plug_conf=$( $d_zen --width=640 --height=400 $win_icon --title="$_zen_title" \
# 	--text-info --editable --filename="$(user_CF_DIR)/$plug_conf" \
# 	--checkbox="Confirm to overwrite" --cancel-label="Abort (panic button)" --ok-label="Write")
	# text
	log_brief="$(user_CF_DIR)/$plug_conf"
	IFS=$(echo -en "\n\b")
	log_txt="${j}<b>$plug_version configuration file</b>${end}"
	cancel_lbl="Abort (panic button)!undo-rtl"; ok_lbl='Write!gtk-ok'
	w_formatted=1; w_wrap=1; w_width='640'; w_height='400'; all_btn=1; colors=0
	edit_plug_conf=$(win_yad_text "$log_brief" "--editable")
	if [ $? = 0 ]; then
		IFS=$ifs; echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf; menu_modif
	else
		IFS=$ifs; menu_modif
	fi
}
read_help(){
# 	$d_yad --width=680 --height=400 --title="Zenvidia" --window-icon=$img_zen_desktop --button="yad-close" \
# 	--center --text-info --formatted < $zen_docs/HELP.txt
# 	menu_manage
	# ++++++++++++++++++++++
	IFS=$(echo -en "\n\b")
	log_brief="$zen_docs/HELP.txt"
	log_txt="${j}<b>Zenvidia help text</b>${end}"; cancel_lbl="Back to menu!undo-rtl"; ok_lbl=''
	w_formatted=1; w_wrap=1; w_width='720'; w_height='400'; all_btn=0; colors=1
	win_yad_text "$log_brief"
	IFS=$ifs
	[ $_opt -gt 0 ] && exit 0 || menu_manage
}
read_about(){
	log_txt=$(cat <<-ABOUT
		${v}${j}${bf}About Zenvidia${end}${end}
		Version :	${y}$(cat $(user_CF_DIR)/zen_version)${end}
		License :	${y}LGPLv3${end}
		Author :	${y}@PirateProd - 2020-2023${end}
		website :	${y}$zenvidia_git${end}
		contact :	${y}wildtruc@noneltd.net${end}
		${end}
	ABOUT
	)
	IFS=$(echo -en "\n\b")
# 	log_brief="$HOME/Devel/NVIDIA/dev_zenvidia/docs/ABOUT.txt"
	log_brief="$zen_docs/ABOUT.txt"
	log_txt="$log_txt"; cancel_lbl='Back to menu!undo-tlr'; ok_lbl=''
	w_formatted=1; w_wrap=1; w_width='700'; w_height='400'; all_btn=0; colors=1
# 	win_yad_text "$HOME/Devel/NVIDIA/dev_zenvidia/docs/ABOUT.txt" "--image=swiss_knife"
	win_yad_text "$log_brief" "--image=swiss_knife"
	IFS=$ifs
	[ $_opt -gt 0 ] && exit 0 || menu_manage
}
read_nv_help(){
	IFS=$(echo -en "\n\b")
	if [[ ${#chapter_index[@]} -le 1 ]]; then
		unset chapter_index chapters_list
		chapters_list=$(sed -En "/TABLE OF.*$/,/1A. ABOUT.*$/p" $nvi_docs/README.txt | sed -n "/^___.*$/,/^___.*$/p"| grep -E "^Chapter|^Appendix")
		for chapter in ${chapters_list[@]}; do
			chapter_index+=("FALSE")
			chapter_index+=("$chapter")
		done
	fi
	## display index first
	[ $_opt -gt 0 ] && cancel_lbl='Exit!gtk-no' || cancel_lbl='Back to main!undo-tlr'
	ok_lbl='Select!gtk-ok'; l_tail=0; w_head=0
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='600'; w_height='420'
	l_text="${j}${bf}Nvidia Documentation ${end}$help_tip${end}"

	index=$( win_yad_list "${chapter_index[*]}" )

	if [ $? -eq 1 ]; then [ $_opt -gt 0 ] && exit 0 || base_menu; fi
	if [ "$index" != '' ]; then
		chap_start=$(printf "$index"| sed -n "s/(.*)//g;p")
		## then if chapter tag is not empty, dispaly chapter.
		chap_end=$(grep -E -A1 "$chap_start" <<< $chapters_list | sed -n 2p | sed -n "s/(.*)//g;p")
		chap_brief="$chap_start : "$(sed -En "/^$chap_start/,/^$chap_end/p" $nvi_docs/README.txt | sed -En "/^____/,/^____/p")

		log_txt="${j}Nvidia $(version) Documentation - ${y}$chap_start${end}${end}"
		[ $_opt -gt 0 ] && cancel_lbl='Exit!gtk-no' || cancel_lbl='Exit to main!undo-tlr'
		ok_lbl='Back to index!edit-redo-rtl'
		w_formatted=0; w_wrap=1; w_width='620'; w_height='400'; all_btn=1; colors=1

		win_yad_text "$chap_brief"

		if [ $? -eq 1 ]; then
			IFS=$ifs
			[ $_opt -gt 0 ] && exit 0 || menu_manage
		else
			IFS=$ifs; read_nv_help
		fi
# 		IFS=$ifs
 	else
		IFS=$ifs
		[ $_opt -gt 0 ] && exit 0 || menu_manage
 	fi
}
read_changelog(){
	unset entry_list entrylog_list
	IFS=$(echo -en "\n\b")
	relist_title=''; catch_title=''; txt_val=0
	brief(){
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$( cat <<-BRIEF
			$log_brief
			BRIEF
			)
		else
			log_brief=$(echo -e "\n\nNothing to display here.\n\nLog file empty.")
		fi
# 		if [ $catch_title != '' ]; then log_title="$catch_title"; else log_title="$entrylog"; fi
# 		if [ $catch_title != '' ]; then log_title="$catch_title"; else log_title="$entrylog"; fi
		log_txt="${bf}${j}Changelog : ${y}$entrylog${end}${end}${end}"
		[ $_opt -gt 0 ] && cancel_lbl='Exit!gtk-no' || cancel_lbl='Back to menu!undo-tlr'
		ok_lbl='Back to index!edit-redo-rtl'
		w_formatted=0; w_wrap=1; w_width='600'; w_height='400'; all_btn=1; colors=1
		win_yad_text "$log_brief"
		if [ $? -eq 1 ]; then
			IFS=$ifs
			[ $_opt -gt 0 ] && exit 0 || menu_manage
# 				if [ $_opt -gt 0 ]; then IFS=$ifs; exit 0; else IFS=$ifs; menu_manage; fi
		else
			if [[ $relist_title != '' ]]; then
				relist
			else
				relist_title=''
				IFS=$ifs ; read_changelog
			fi
		fi
# 		IFS=$ifs
	}
	relist(){
		if [[ $relist_title != '' ]]; then
			cancel_lbl='Back to list!edit-redo-rtl'
			ok_lbl='Read!gtk-ok'
		else
			[ $_opt -gt 0 ] && cancel_lbl='Exit!gtk-no' || cancel_lbl='Back to main!undo-tlr'
			ok_lbl='Select!gtk-ok'
		fi
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			for log_line in ${entry_list[@]}; do
				entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
			done
		fi
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; l_tail=0; w_head=0
		w_width='550'; w_height='420'
		l_text="${j}${bf}Nvidia Change Logs list $relist_title${end}${end}"
		entrylog=$( win_yad_list "${entrylog_list[*]}" )
		if [ $? -eq 1 ]; then
			IFS=$ifs
			if [[ $relist_title != '' ]]; then
# 				IFS=$ifs; read_changelog
				read_changelog
			else
# 				IFS=$ifs
				[ $_opt -gt 0 ] && exit 0 || menu_manage
			fi
		else
			if [[ $entrylog != '' ]]; then
				if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
					log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
					log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
					sed -n "s/^===.*$//g;p")
				else
					log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
					[ "$log_end" != "" ] || log_end="====.*$"
					log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
					sed -n "s/^===.*$//g;p")
				fi

				if [[ $relist_title != '' ]]; then
					if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
						log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
						sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
					else
						log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
						sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
					fi
					brief
				else
					log_brief=$(cat <<< $log_list | sed -En "s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}" )
				fi
			else
				IFS=$ifs
				[ $_opt -gt 0 ] && exit 0 || menu_manage
			fi
		fi
	}
	entry_list=$(grep -E -e "=====" $zen_docs/NVIDIA_Changelog | sed -En "s/[ ]?={8}[ ]?//g;p")
	relist
	if [[ $log_list =~ .*[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
		unset entry_list entrylog_list entry_catch
		if [ $(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$") -gt 0 ]; then
			txt_key="$(cat <<< $log_brief | sed -n '1p' | grep "\* [A-Z].*$"|sed -n "s/\* //g;p")"
			txt_val=$(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$")
			entry_list+=("First $entrylog Log")
		fi
		entry_catch=$(cat <<< $log_list | grep -E ".*[0-9]{4}-[0-9]{2}-[0-9]{2}"|sed -En "s/ ([0-9]{4})/\1/g;p")
		for catch in ${entry_catch[*]}; do
			entry_list+=("$catch")
		done
		relist_title=": ${y}$entrylog${end}"; catch_title=$entrylog
		relist
	else
		relist_title=''; catch_title=''
		brief
	fi
	IFS=$ifs
}
read_zen_changelog(){
	unset entry_list entrylog_list
# 	IFS=$(echo -en "\n\b")
	if [[ "$notif_desk_opt" =~ 'z' ]]; then log_from_local=1; else log_from_local=0; fi
	if [ $log_from_local = 1 ]; then
		log_pages=$(user_CF_DIR)/src/zen_git.log # from user dir
	else
		log_pages=$zen_docs/Changelog.txt # from install dir
	fi
	IFS=$(echo -en "\n\b")
	brief(){
# 		IFS=$(echo -en "\n\b")
		log_version=$(echo "$entrylog"| grep -E -o "v[0-9].[0-9](.[0-9]{1,2})?")
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$( cat <<-BRIEF
			Zenvidia changelog : ( $log_version )

			$log_brief
			BRIEF
			)
		else
			log_brief=$(echo -e "Zenvidia changelog ( $log_verion ) :\n\nNothing to display here.\nLog file empty.")
		fi

		if [ $_opt -gt 0 ]; then
			cancel_lbl="Exit!gtk-close"; ok_lbl="Back to list!edit-redo-rtl"
		else
			cancel_lbl="Back to previous!undo-rtl"; ok_lbl="Back to list!edit-redo-rtl"
		fi
		log_txt="${v}<b>Zenvidia changelog : ${y}$log_version${end}</b>${end}"
		w_formatted=1; w_wrap=1; w_width='600'; w_height='300'; all_btn=1; colors=1
		win_yad_text "$log_brief"

		if [ $? -eq 1 ]; then
			IFS=$ifs
			[ $_opt -gt 0 ] && exit 0 || menu_manage
# 			if [ $_opt -gt 0 ]; then IFS=$ifs; exit 0; else IFS=$ifs; base_menu; fi
		else
			IFS=$ifs
			read_zen_changelog
		fi
	}
	relist(){
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			for log_line in ${entry_list[@]}; do
				entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
			done
		fi
# 		IFS=$(echo -en "\n\b")
		l_text="${j}${bf}Zenvidia Change Logs list ${end}${end}"
		col_name=( "" "Version")
		if [ $_opt -gt 0 ]; then
			cancel_lbl='Exit!gtk-no'; ok_lbl='Read!gtk-ok'
		else
			cancel_lbl='Back to main!undo-rtl'; ok_lbl='Read!gtk-ok'
		fi
		list_type='radiolist'; columns=2; sel_col=2; sep=''; l_tail=1; w_head=1
		hid_col=0; edit_col=0; col_tip=0; w_width='500'; w_height='300'
		entrylog=$( win_yad_list "${entrylog_list[*]}" )

		if [ $? -eq 1 ]; then
			IFS=$ifs
			[ $_opt -gt 0 ] && exit 0 || menu_manage
		else
			if [[ $entrylog != '' ]]; then
				if [ $log_from_local = 1 ]; then
					entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
				else
					entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
				fi
				log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
				if [ "$log_end" != '' ]; then
					if [ $log_from_local = 1 ]; then
						log_end=$(echo -e "$log_end"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
					else
						log_end=$(echo -e "$log_end"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
					fi
				else
					log_end='^     $'
				fi
				log_list=$(cat $log_pages | sed -En "/$entrylog/,/$log_end/p"	)
				if [ $log_from_local = 1 ]; then
					log_brief=$(grep -E "^.*-" <<< $log_list) # from user dir
				else
					log_brief=$(grep -E "^[ ]{,3}-" <<< $log_list) # from install dir
				fi
			else
				IFS=$ifs
				[ $_opt -gt 0 ] && exit 0 || menu_manage
# 				if [ $_opt -gt 0 ]; then IFS=$ifs; exit 0; else IFS=$ifs; base_menu; fi
			fi
		fi
# 		IFS=$ifs
	}
	if [ $log_from_local = 1 ]; then
		entry_list=$(grep -E -e "^[Aa-Zz]{3} [0-9]{1,2} [0-9]{4} :" $log_pages) # from user dir
	else
		entry_list=$(grep -E -e "^* [0-9]{4}-[0-9]{1,2}-[0-9]{2} -" $log_pages | sed -n "s/^* //p") # from install dir
	fi
	relist
	brief
	IFS=$ifs
}
nv_config(){
	[ -x $d_nv_settings ] && \
	gpu_set=$($d_nv_settings -q gpus | grep -i "nvidia" | sed -En "s/^.*\[gpu:([0-9])\].*(\(.*\)).*$/GPU \1 - \2/g;p")
	$su_cmd "$(def_user)" $d_nv_settings -p "$gpu_set"
	menu_modif
}
zen_notif_setup(){
	setup_validation(){
# 		notif=$($d_zen --height=100 $win_icon --title="$_zen_title" --question --no-wrap \
# 		--text="${vB}Autostart launcher will be set to :\n<b>></b>${end} ${j}$_notif${end}" \
# 		--ok-label="Ok" --cancel-label="$PM")

		warn_log="${vB}Autostart launcher will be set to :\n<b>></b>${end} ${j}$_notif${end}"
		[ $_opt -gt 0 ] && cancel_lbl='Exit!gtk-no' || cancel_lbl='Back to menu!undo-rtl'
		qst=1; ok_lbl='Ok!gtk-ok' ; kill_yad=0
		win_yad_warns
		if [ $y_output = 0 ]; then
			sed -Ei "s/(Exec=zen_notify) -[a-z]/\1 $_set/" $notif_desk_file
		fi
		[ $_opt -gt 0 ] && exit 0 || menu_modif
	}
	#notif_desk_file=/home/$(def_user)/.config/autostart/zen_notify.desktop
	unset setup_list setup_option c_set_list
	setup_option=(
	"Check driver update only;driver check only;n"
	"Check zenvidia and driver update;driver and zenvidia check;z"
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$( cat <<-HLP

		${v}<i>You can leave it as it is or choose between
		one of the sets below</i>.${end}
		HLP
		)
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=350'
# 		else
# 			w_height='--height=450'
# 		fi
	else
		hlp_tip=''
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=300'
# 		else
# 			w_height='--height=400'
# 		fi
	fi
	st=1
# 	c_set_opt=$(cat $notif_desk_file |grep "Exec"| perl -p -e "s|^.*-+([a-z])|\1|")
	notif_desk_opt
	for n_set in "${setup_option[@]}"; do
		m_set=$(printf "$n_set"|cut -d';' -f1)
		c_set=$(printf "$n_set"|cut -d';' -f2)
		o_set=$(printf "$n_set"|cut -d';' -f3)
# 		if [[ $o_set == $c_set_opt ]]; then
		if [[ $o_set == $notif_desk_opt ]]; then
			c_set_cnf=$c_set
			set_state='true'
		else
			set_state='false'
		fi
		setup_list+=("$set_state")
		setup_list+=("$st")
		setup_list+=("$m_set")
		((st++))
	done
	l_text=$(cat <<-MSG
		${j}${bf}Notifications config${end}${end}

		Notification is currently set to: ${y}$c_set_cnf${end}


	MSG
	)
# 	menu_notif=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" --text="$w_text" \
# 	--column "set" --column "2" --column "action" --hide-column=2 \
# 	"${setup_list[@]}")

	IFS=$(echo -en "\n\b")
	[ $_opt -gt 0 ] && cancel_lbl='Exit!gtk-no' || cancel_lbl='Back to main!undo-rtl'
	ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='0'

	menu_notif=$( win_yad_list "${setup_list[*]}" )
	if [ $? = 1 ]; then IFS=$ifs; [ $_opt -gt 0 ] && exit 0 || menu_modif; fi
	IFS=$ifs

# 	if [ $? = 1 ]; then menu_modif; fi
	case $menu_notif in
		"1") _set='-n'; _notif="driver check only" ;;
		"2") _set='-z'; _notif="driver and zenvidia check" ;;
		*) [ $_opt -gt 0 ] && exit 0 || menu_modif ;;
	esac
	setup_validation
}

### SUB MENU ###
menu_install(){
	unset install_list ins_cmd ins_list
	if [ $hlp_txt = 1 ]; then
		hlp_tip="\n$hlp_01b"
		hlp_tip=$( cat <<-HLP

		${vB}Select the install type${end}
		   - ${vB}From a local package${end}:
		   Install a new driver from a user directory local package
		   or a listed already downloaded with zenvidia.
		   - ${vB}From Nvidia server${end}:
		   Will display the full drivers list from the Nvidia server.
		   Install and download will be executed in the next step.
		HLP
		)
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=300'
# 		else
# 			w_height='--height=400'
# 		fi
	else
		hlp_tip="\n${vB}Select here the install type${end}"
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=200'
# 		else
# 			w_height='--height=300'
# 		fi
	fi
	install_list=("From a local package" "From NVIDIA server")
	n=1
	for ins_cmd in "${install_list[@]}"; do
		ins_list+=("false")
		ins_list+=("$n")
		ins_list+=("$ins_cmd")
		n=$[ $n+1 ]
	done 
# 	menu_inst=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Install new drivers${end}\n${end}${v}$hlp_tip${end}" \
# 	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	"${ins_list[@]}")
	IFS=$(echo -en "\n\b")
	l_text="${j}${bf}Install new drivers${end}\n${end}${v}$hlp_tip${end}"
	cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_inst=$( win_yad_list "${ins_list[*]}" )

	if [ $? = 1 ]; then IFS=$ifs; base_menu; fi
	IFS=$ifs
	ui_mod=1
	case $menu_inst in
		"1") menu_msg="${vB}NVIDIA package update from local dir. ${end}"; from_directory ;;
		"2") menu_msg="${vB}NVIDIA package from NVIDIA server.${end}"; net_version_selector ;;
		*) base_menu ;;
	esac
}
menu_update(){
	check_version
	if [ $hlp_txt = 1 ]; then
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=450'
# 		else
# 			w_height='--height=550'
# 		fi
		hlp_tip=$(cat <<-HLP

		<b>Select here the element to update or install</b>
		- <b>Driver upgrade</b>
		   Check for new driver update.
		   You can select during the process to download only or install directly.
		   If <i>download only</i> is chosen, for installation afterward
		   go back to : » ${j}main${end} menu » ${j}Install Drivers${end}
		   <u>Note</u> : All download are stored.
		- <b>Update driver only (dkms)</b>
		   Install nvidia dkms modules for a new running kernel.
		- <b>Update driver only (force)</b>
		   Optional command to force install from driver sources in case of
		   DKMS failure.
		- <b>Update driver for an other kernel (dkms)</b>
		   Optional command to update nvidia modules for an other kernel.
		HLP
		)
	else
		hlp_tip=''
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=300'
# 		else
# 			w_height='--height=400'
# 		fi
	fi
	nu=1
	if [ $hlp_txt = 0 ]; then hlp_tip="\n${vB}\Select here the element to update or install${end}"; fi
		if [ $use_dkms = 1 ]; then
			up_cmd_list=("Driver upgrade" "Update driver only (dkms)" "Update driver only (force)" "Update driver for an other kernel (dkms)")
		else
			up_cmd_list=("Driver upgrade" "Update driver only" "Update driver for an other kernel")
		fi
	unset up_list
	for up_cmd in "${up_cmd_list[@]}"; do
		up_list+=("false")
		up_list+=("$nu")
		up_list+=("$up_cmd")
		nu=$[ $nu+1 ]
	done 
# 	menu_upd=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Update Drivers or kernel modules${end}${end}${v}$hlp_tip${end}" \
# 	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	"${up_list[@]}" )

	IFS=$(echo -en "\n\b")
	l_text="${j}${bf}Update Drivers or kernel modules${end}${end}${v}$hlp_tip${end}"
	cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_upd=$( win_yad_list "${up_list[*]}" )

	if [ $? = 1 ]; then IFS=$ifs; base_menu; fi
	IFS=$ifs
	git_tmp=$(mktemp --tmpdir nv_git.XXXX)
	rem_tmp+=("rm -f $git_tmp")
	trap "${rem_tmp[*]}" EXIT
	home=/home/$(def_user)
	if [ $use_dkms = 1 ]; then
		case $menu_upd in
			"1")	menu_msg="${v}Check driver updates list${end}"; legacy_drv=0; check_for_newer; check_update ;;
			"2")	menu_msg="${v}Build module for current kernel (dkms)${end}"
					upgrade_other=0; force='--force'
					upgrade_kernel; base_menu ;;
			"3")	menu_msg="${v}Build module for current kernel (force)${end}"
					upgrade_other=0; use_dkms=0;
					upgrade_kernel; base_menu ;;
			"4")	menu_msg="${v}Build module for the selected kernel (dkms)${end}"
					upgrade_other=1;
					upgrade_new_kernel; base_menu ;;
			*) base_menu ;;
		esac
	fi
}
menu_modif(){
	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(cat <<-HLP

		<b>Select here the element to modify or edit</b>:
		- <b>Edit Xorg config file</b>:
			Edit the current xorg configuration file in /etc/X11.
		- <b>Edit script config</b>:
			Edit Zenvidia basic user conf script to set or unset mostly everything.
		- <b>Edit GUI $d_zen font colors</b>:
			Change default Zenity font colors.
			<u>Note</u> : graphic UI is available with Yad installed.
		- <b>Nvidia settings</b>:
			Start Nvidia-setting graphic UI tool.
		- <b>Edit distro config</b>:
			Modify the distribution configation file.
			<u>Warning</u> : This very sensitive, bad config file breaks Zenvidia.
		- <b>Manage drivers packages</b>:
			This tool is to backup, restore and remove old or current driver install.
			It also manage dowloaded nvidia's .run pack.
			<u>Note</u> : if old installation is found during driver update,
			it is automatically backup prior to new version installation.
		- <b>Notication settings</b>:
			Configuration tool for Zen_notify daily update checker.
		- <b>Open driver switch tool</b> (optional):
			When available, this tool allow to switch between
			open and proprietary source drivers.
		HLP
		)
		w_height='--height=660'
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=660'
# 		else
# 			w_height='--height=700'
# 		fi
	else
		hlp_tip="\n${vB}Select here the element to modify or edit${end}"
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=330'
# 		else
# 			w_height='--height=400'
# 		fi
	fi
	nd=1
	mod_menu_list=("Edit xorg config file" "Edit Zenvidia config" "Edit GUI Colors" "Nvidia-settings" "Edit Distro config" "Manage drivers packages"  "Zenvidia notification config")
	unset mod_list
	if [ $open_drv -gt 0 ]; then
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("Open driver switch tool")
		nd=$[ $nd+1 ]
	fi
	for mod_cmd in "${mod_menu_list[@]}" ; do
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("$mod_cmd")
		nd=$[ $nd+1 ]
	done
# 	menu_mod=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Configuration and Tools${end}${end}${v}$hlp_tip${end}" \
# 	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	"${mod_list[@]}")

	IFS=$(echo -en "\n\b")
	l_text="${j}${bf}Configuration and Tools${end}${end}${v}$hlp_tip${end}"
	cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_mod=$( win_yad_list "${mod_list[*]}" )

	if [ $? = 1 ]; then IFS=$ifs; base_menu; fi
	IFS=$ifs
	if [ $open_drv -gt 0 ]; then
		case $menu_mod in
			"1") if [ $UID = 0 ]; then win_open_switch; else  is_SU; menu_modif; fi;;
			"2") from_install=0; if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; menu_modif; fi;;
			"3") edit_script_conf ;;
			"4") edit_color_conf ;;
			"5") nv_config ;;
			"6") if [ $UID = 0 ]; then edit_distro_conf; else is_SU; menu_modif; fi;;
			"7") if [ $UID = 0 ]; then manage_pcks; else is_SU; menu_modif; fi;;
			"8") zen_notif_setup ;;
			*) base_menu ;;
		esac
	else
		case $menu_mod in
			"1") from_install=0; if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; menu_modif; fi;;
			"2") edit_script_conf ;;
			"3") edit_color_conf ;;
			"4") nv_config ;;
			"5") if [ $UID = 0 ]; then edit_distro_conf; else is_SU; menu_modif; fi;;
			"6") if [ $UID = 0 ]; then manage_pcks; else is_SU; menu_modif; fi;;
			"7") zen_notif_setup ;;
			*) base_menu ;;
		esac
	fi
}
menu_manage(){
# 	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(
		cat <<-TIP

			${v}README and Help file from Nvidia $(version) and other.${end}

			- ${vB}Documanetation${end}:\tRead the current Nvidia help file.
			- ${vB}Change Logs${end}:\tRead the current Nvidia changelog file.
			- ${vB}Zenvidia Logs${end}:\tRead the Zenvidia changelog file.
			- ${vB}Zenvidia Help${end}:\tRead Zenvidia doc file.
			- ${vB}About Zenvidia${end}:\tRead current Zenvidia README file.
		TIP
		)
# 		w_height='--height=300'
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=450'
# 		else
# 			w_height='--height=550'
# 		fi
	else
		hlp_tip="\n${v}README and Help file from Nvidia $(version) and other.${end}"
		w_height='--height=300'
# 		if [ $zenity_ver -le 3420 ]; then
# 			w_height='--height=300'
# 		else
# 			w_height='--height=400'
# 		fi
	fi
	nm=1
	unset mng_list
	for mng_cmd in "Documention manual ($(version))" "Change Logs ($(version))" "Zenvidia Logs" "Zenvidia Help" "About Zenvidia (README)"; do
		mng_list+=("false")
		mng_list+=("$nm")
		mng_list+=("$mng_cmd")
		nm=$[ $nm+1 ]
	done
# 	menu_mng=$($d_zen --width=400 $w_height $win_icon --list \
# 	--radiolist --hide-header --title="$_zen_title" \
# 	--text "${j}${bf}Help and Documentation${end}${end}${v}$hlp_tip${end}" \
# 	--column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	"${mng_list[@]}")
#
	IFS=$(echo -en "\n\b")
	l_text="${j}${bf}Help and Documentation${end}${end}${v}$hlp_tip${end}"
	cancel_lbl='Back to main!undo-rtl'; ok_lbl='Select!gtk-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_mng=$( win_yad_list "${mng_list[*]}" )

	if [ $? = 1 ]; then IFS=$ifs; base_menu; fi
	IFS=$ifs
	case $menu_mng in
		"1") unset chapter_index chapters_list; read_nv_help ;;
		"2") read_changelog ;;
		"3") read_zen_changelog ;;
		"4") read_help ;;
		"5") read_about ;;
		*) base_menu ;;
	esac
}

### RESCUE COMMAND LINE ###
dm_serv_restore(){
	if [ $no_mod=0 ]; then
		if [ "$dkms_ins" == "$cmd_ver" ]; then
			for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
				if [ $(grep -owc "$drv" /etc/modprobe.d/nvidia-blacklist.conf) -eq 0 ]; then
				drv_list+=("$drv")
				fi
			done
			test $echec = 0 && ( echo -e "${nc}# ${yel}DM and $dkms_ins drivers re-init :${nc}" )
			echo -e "${nc}# ${yel}Unload $dkms_ins drivers if any${nc}."; sleep 2
			modprobe -r -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Load $cmd_ver drivers${nc}."; sleep 2
			command -v restorecon &>/dev/null || modprobe -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Exec $KERNEL modules reload."; sleep 2
			exec_mod_load
			echo -e "${nc}# ${yel}Exec $KERNEL modules init."; sleep 2
			progress_msg(){ echo -en "\r${nc}#${blu} ($m sec.) Exec $KERNEL modules initramfs."; }; m=1; do_slp=1
			exec_initramfs
			echo -e "\n${nc}# ${yel}Done.${nc}"
			echo -e "# ${yel}License is $license ${nc}."
			## catch console pid here
			if [ "$(dm_serv)" != "" ]; then
				test $($d_sys status $(dm_serv) | grep -c "disabled") -gt 0 && (
				echo -e "${nc}# ${yel}Restore $(dm_serv) service to 'enable'${nc}."; sleep 2; )
				$d_sys enable $(dm_serv).service
				echo -e "${nc}# ${yel}Start $(dm_serv) service${nc}."; sleep 2
				echo -e "${blu}(Press ENTER to start, CTRL-C to cancel)${nc}"; read
				$d_sys start $(dm_serv).service
			else
				echo -e "${nc}# ${yel}You can 'enable' and 'start' your Display Manager now.${nc}."
			fi
			## trying to kill console root's tty.
			if [ $(w | grep -c "root.*tty") -gt 0 ]; then
				sleep 40
				pkill -9 -t $(w | grep "root.*tty" | awk '{print $2}')
			fi
		else
			echo -e "${nc}# ${red} WARNING${yel}: $cmd_ver differ from installed driver ($dkms_ins); <rebuild> first.\nAbort.${nc}."
		fi
	else
		echo -e "${nc}# ${red} WARNING${yel}: No modules found for $KERNEL, install $cmd_ver first with <rebuild> option.\nAbort.${nc}."
	fi
}
restore_cmdline(){ # ALERT TMP_C
	echec=0
	echo -e "# ${yel}Restoring $cmd_ver driver for $KERNEL${nc} :\n"
	sleep 2
	## clean old librairies
	if [ "$dkms_ins" != "" ]; then
		if [[ $cmd_ver != $dkms_ins ]]; then
			echo -e "# ${blu}Cleaning $dkms_ins old installation${nc} ..."
			sleep 2
			rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$dkms_ins
			rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$dkms_ins
			rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$dkms_ins
			test -d /var/lib/dkms/nvidia/$dkms_ins && $p_dkms remove nvidia/$dkms_ins --all
			test -d /var/lib/dkms/open-nvidia/$dkms_ins && $p_dkms remove open-nvidia/$dkms_ins --all
			rm -Rf /usr/src/nvidia-$dkms_ins
			test -d /usr/src/open-nvidia-$dkms_ins && rm -Rf /usr/src/open-nvidia-$dkms_ins
			sleep 2
		fi
	fi
	echo -e "# ${yel}Uncompressing $cmd_ver archive for $KERNEL${nc} :\n"
	tar -zvxf $nvbackup/nvidia.$cmd_ver.tar.gz -C /
	echo -e "\n# ${blu}- Registering $cmd_ver librairies (ldconfig)${nc} ..."
	ldconfig
	echo -e "# ${blu}- Depmod $cmd_ver modules ..."
	progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
	m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c # ALERT
	## check modules
	echo -e "\n${nc}# ${blu}- Testing $cmd_ver modules availbility${nc} ..."
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	test $vermagic && echo -e "# ${yel}Initramfs update${nc}." || \
	( echo -e "# ${red}Test failed${nc}."; echec=1; rebuild_cmdline )
	sleep 2
	if [ $echec = 0 ]; then
		echo -e "\n${nc}# ${yel}Done.${nc}"
		echo -e "# ${yel}License is $license ${nc}.\n"
		dm_serv_restore
	fi
}
rebuild_cmdline(){
	if [ $echec = 1 ]; then
		echo -e "# ${red}WARNING ${yel}: No $cmd_ver modules set in the backup${nc}.\n"; sleep 2
	fi
	clear
	echo -e "# ${yel}Build & Install $cmd_ver DKMS $KERNEL modules ($license) :${blu}"; sleep 2
	if [ $($p_dkms status -m $module/$cmd_ver -k $KERNEL| grep -cv "added") -gt 0 ]; then
		$p_dkms remove -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms add -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	else
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	fi
	## recheck modules
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [[ $vermagic ]]; then
		echo -e "\n${nc}# ${yel}Initramfs update aand other routines.${blu}"; sleep 2
		dm_serv_restore
	else
		echo -e "\n# ${red}Failed${nc}."
	fi
}
rescue_cmdline(){ # ALERT TMP_C
	## modinfo will display error if modules is not found, just add comments.
	clear
	echo -e "# ${yel}Compling $module $cmd_ver sources${nc} :\n" ; sleep 2
	kernel_module_src=/usr/src/$module-$cmd_ver
	cd $kernel_module_src; make -j12
	## check again
	vermagic=$($d_modinfo -F vermagic $kernel_module_src/nvidia.*[ko\|ko.xz]| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [ $vermagic ]; then
		if [[ $vermagic == $KERNEL ]]; then
			cp -f *.ko $libmod/
			## compress modules.
			clear
			echo -e "# ${blu}- Compressing modules if needed${nc}."; sleep 2
			is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
			[ $is_RT = 0 ]|| xz -T12 $libmod/*.ko
			echo -e "# ${blu}- Depmod $cmd_ver modules ..."
			progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
			m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c # ALERT
			## rebuild initramfs in case of trouble booting.
			clear
			dm_serv_restore
		fi
	else
		echo -e "${nc}#${red} *** Something went wrong ! ***\n${nc}#${yel} Restoration script can't proceed, exit${nc}."
	fi
}
## root warning
is_SU(){
	w_text=$(cat <<-WRN
	${y}${bf}Your are not root${end}${end}
	This command can't be executed with ${j}<b>Zenvidia (user)</b>${end} unprivilegded desktop entry.
	See ${j}<b>Zenvidia</b>${end} <i>(admin)</i> desktop entry instead.
	WRN
	)
	icone='swiss_knife'
	w_label='Got it!'
	win_warning
}

### MAIN MENUS ###
base_menu(){
	devices(){
	e=0
	until [ $e -eq ${#dev_n[*]} ]; do
		printf "${vB}Card $((${dev_n[$e]}+1)) :${end}${ge} - - - - - - - - - ${end}${j}${dev[$e]} ($(printf "${vnd[$e]}"|awk '{print $1}'))${end}\n"
		((e++))
	done
	}
	open_check(){
	if [ $open_drv ]&&[ $open_drv = 1 ]; then
		if [ $use_open ]; then
			if [ $use_open = 1 ]; then open_used=" and in use"; else open_used=", but unused"; fi
		else
			open_used=", closed source used"
		fi
		echo -e "${vB}Open Source modules :${end}${ge}     ${end}${j}installed$open_used${end}"
		echo -e "${vB}Loaded module license :${end}${ge}  ${end}${j}$($d_modinfo -F license nvidia)\n${end}"
	fi
	}
	right_check(){
		if [ $UID = 0 ]; then
			echo "superadmin"
		else
			echo "$USER\n(system write priviledge not allowed)$scan_alert"
		fi
	}
	# remove deplist list in case of relaunching first because an update asking to
	unset deplist
	hlp_tip_txt=$( cat <<-HLP
		Help tips text is currently set.
		You can unset it at any moment in:
		${j}Configuration and Tools${end} menu » ${j}Edit script config${end}.\n\n"
	HLP
	)
# 	if [ "$(version)" == "0" ]; then
# 		drv_installed='not installed'
# 	else
# 		drv_installed=$(version)
# 	fi
# 	[ $hlp_txt = 0 ]|| { hlp_wrn="$hlp_tip_txt"; w_height=$(($w_height+50)); }
	[ $hlp_txt = 0 ]|| { hlp_wrn="$hlp_tip_txt"; }
# 	window_text=$( cat <<-MSG
	l_text=$( cat <<-MSG
		                            ${rBB}ZENVIDIA${end}
		                         ${y}${nf}Close and Open Source
		                         Nvidia drivers manager${end}${end}
		${vB}\nSystem :${end}${ge}  - - - - - - - - ${end}${j}$DISTRO${end}
		${vB}Processor type :${end}${ge} - - ${end}${j}$ARCH${end}
		$(devices)

		${vB}Driver version installed :${end} ${j}$(drv_installed)${end}$restore_msg
		${vB}Kernel version :${end}${ge}  - - - - - - -  ${end}${j}$KERNEL${end}
		${vB}GCC version :${end}${ge}  - - - - - - - - -  ${end}${j}$GCC${end}
		${vB}NVIDIA binary version :${end}${ge}    ${end}${j}$NV_bin_ver${end}$restore_msg
		$(open_check)
		${v}Network connection :${end} ${j}$cnx_msg${end}
		${v}Rights :${end} ${j}$(right_check)${end}

		${v}$hlp_wrn$ansWN${end}
	MSG
	)
# 	menu_cmd=$($d_zen --title="$_zen_title" --height=600 --width=300 --list $win_icon \
# 	--radiolist --hide-header --column "set" --column "2" --column "action" --separator=";" --hide-column=2 \
# 	--text="$window_text" \
# 	false 1 "Install drivers" false 2 "Update drivers or modules" false 3 "Configuration and Tools" false 4 "Help and Documentation" )

	IFS=$(echo -en "\n\b")
	unset col_name; cancel_lbl='Exit!undo-tlr'; ok_lbl='Select!gtk-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0
	w_width='300'; w_height='300'; l_tail=0; w_head=0
	menu_list=( false 1 "Install drivers" false 2 "Update drivers or modules" false 3 "Configuration and Tools" false 4 "Help and Documentation" )
	# 	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='600'; w_height='420''
	menu_cmd=$( win_yad_list "${menu_list[*]}" )

	if [ $? = 1 ]; then IFS=$ifs; exit 0; fi
	IFS=$ifs
	case $menu_cmd in
		"1") if_update=0; if [ $UID = 0 ]; then menu_install; else is_SU; base_menu; fi;;
		"2") if_update=1; if [ $UID = 0 ]; then menu_update; else is_SU; base_menu; fi;;
		"3") if_update=1; menu_modif ;;
		"4") if_update=1; menu_manage ;;
		*) exit 0 ;;
	esac
}
install_controls(){
	# check nvidia dir presence
	if [ -d $install_dir/zenvidia ] ; then
		dir_msg="${j} OK${end}"
	else		
		dir_msg="${j}ERROR\n${y}Zenvidia repository is missing${end}${end}"
		$d_zen --width=400 $win_icon --error --no-wrap --title="$_zen_title" \
		--text="$dir_msg"
	fi
	# check/change run packages permission
	nvdl_last=$(ls -1 $nvdl/|sed -n '$p')
	if [[ -s $nvdl/$nvdl_last ]] ; then
		for changes in $(ls -1 $nvdl ); do
			if [[ $(stat -c "%a" $nvdl/$changes) != 755 ]]; then
				chmod 755 $nvdl/$changes
			fi
		done
	fi
}
start_cmd(){
## this for function testing only in "$1"
# 	if [[ $cmd_opt != '' ]]; then
# 			$($cmd_opt)
# 	fi
	## check if X server is off before lauching cmd line tools.
# 	xprop -root &>/dev/null
# 	if [ $? -gt 0 ]; then
	if [ $x_alive -gt 0 ]; then
		help_text(){
			cat <<-HT
				Command line option : $(basename $0 ) [option] [driver version]
				Options :
				   restore	-> restore driver backup.
				   rebuild	-> rebuild driver.
				   rescue	-> force driver build from sources.
				   reinit	-> Rebuild initramfs and start DM.
			HT
			if [ $(ls -1 $nvbackup | grep -c .) -gt 0 ]; then
				echo -e "Driver version backups :"
				ls -1 $nvbackup | sed -En "s/^nvidia.([0-9]*.*).tar.gz/ - \1/p"
			fi
			file -E $libmod/nvidia.*[ko\|ko.xz] &>/dev/null
			if [ $? -eq 0 ]; then
				echo -e "Installed driver version : $dkms_ins"
				no_mod=0
			else
				echo -e "Found dkms driver version : $module » $dkms_ver"
				no_mod=1
			fi
			echo -e "Display Manager : $(dm_serv)"
		}
		libmod='/lib/modules/'$KERNEL'/'$(module_dest_location)
		echo -e "** ${red}X server not runing${nc} **"
		echo -e "${yel}"
		if [ -f /etc/modprobe.d/open-NVIDIA.conf ]; then
			module='open-nvidia'
			license='Dual MIT/GPL'
		else
			module='nvidia'
			license='NVIDIA'
		fi
		## check realtime kernel.
		is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
		if [ $is_RT = 1 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		fi
		## check dkms mods list.
		dkms_mod=$($p_dkms status -m $module | grep -v "added"| cut -d, -f1)
		dkms_ver=$(echo -e "$dkms_mod"| cut -d"/" -f2)
		dkms_ins=$($d_modinfo -F version $libmod/nvidia.*[ko\|ko.xz])
		echec=0
		if [[ $cmd_ver != '' ]]; then
			case $cmd_opt in
				restore) restore_cmdline ;;
				rebuild) rebuild_cmdline ;;
				rescue) rescue_cmdline ;;
				reinit) dm_serv_restore;;
				*) help_text ;;
			esac
		else
			 help_text
		fi
		echo -e "${nc}"
		exit 0
	else
		#dep_control
		test -x "$d_zen" || exit 0
		install_controls
		connection_control
		# define gcc options if defined.
		gcc_options
		initramfs_warn
# 		if [ "$(version)" == "0" ]; then
# 			drv_installed='not installed'
# 		else
# 			drv_installed=$(version)
# 		fi
		base_menu
	fi
}

## BASICS CHECK ###
## set default or null value before conf files reading.
use_dkms=1
use_uvm=1
use_drm=1
use_open=0
open_drv=0
no_warn=0
open_wrn=1
first_open=1
from_install=0
no_opti_warn=0
opti_preset=0
ARCH=$HOSTTYPE
_opt=0

## ### SCRIPT INTRO ###

# check distro elf type
libclass
# check distro and load specific config.
distro
## check dependies executables
p_xterm=$(command -v xterm) || (
	echo -e "${red}XTERM missing, installing ...${nc}"; $PKG_INSTALLER $pkg_opts$pkg_cmd xterm;
	export p_xterm=$(command -v xterm)
	)
#p_wget=$(command -v wget) || ( echo -e "${red}WGET missing, installing ...${nc}"; $PKG_INSTALLER $pkg_opts$pkg_cmd wget; )
dep_exec_check

# cmdline tool doesn't need to read config, so skip the step if in console only.
if [[ $(def_user) != "root" ]]; then
	test -d $(user_CF_DIR) || mkdir -p $(user_CF_DIR)
	test -d $(user_CF_DIR)/compats/series || mkdir -p $(user_CF_DIR)/{compats/series,updates,release}
# check if default user has conf file to load, or create it from shipped.
	for conf in {basic,color}; do
		if [ "$nvdir/$conf.conf" -nt "$(user_CF_DIR)/$conf.conf" ]; then
			install -bCm644 -o $(def_user) -g $(def_user) -t $(user_CF_DIR) $nvdir/$conf.conf
		fi
		eval ${conf}_conf=$(user_CF_DIR)/$conf.conf
	done
## define compats dirs.
nvcompat="$(user_CF_DIR)/compats"
upcompat="$(user_CF_DIR)/updates"
nvdl="$(user_CF_DIR)/release"
test -d $nvdl || mkdir -p $nvdl
## old version check and move.
if [ $(ls -1 $nvdir/release | grep -c .) -gt 0 ]; then
	mv -f $nvdir/release/* $(user_CF_DIR)/release/
fi
# drv_list_file=$(rem_drv_list)
## zen notify desktop entry option (define zenvidia changelog reading behaviour)
notif_desk_file=/home/$(def_user)/.config/autostart/zen_notify.desktop
notif_desk_opt=$(cat $notif_desk_file| sed -En "s/^Exec=.*-(.*)/\1/p")
## then read script conf.
. $basic_conf
. $color_conf
fi
# load $d_zen span font colors.
zen_colors
# pick all necessary env Definition
compil_vars
PCI_ID
## check/install dependies
dep_control
## zenity version above 3.92 is using gtk 4 gnome shell like theme.
## display is wierd and need to be adapted. Fall back to yad is probably the best to do.
zenity_ver=$($d_zen --version| sed -n "s/\.//g;p")
if [ $zenity_ver -le 3420 ]; then
	_zen_title='Zenvidia'
	win_icon='--window-icon='$img_zen_desktop
	icon_name='--icon-name'
else
	_zen_title=''
	win_icon=''
	icon_name='--icon'
fi
## configuration file check
if [ ! -s $script_conf ]; then $d_zen $win_icon --width=250 --error $icon_name=xkill --text="Script's config file missing."; exit 0; fi


## INITIALS checks

## pick cmd line options if any (X server off only).
 cmd_opt=$1; cmd_ver=$2
## option section is for zen_task_menu needs and is available only from zen_task_menu calls or from cammand line.
while [ $# -gt 0 ]
# 	getopts "rx" OPTION; do
	getopts "rdhxcnzouat" OPTION; do # 't' is the function's test option.
	_opt=1
	case $OPTION in
		r) read_zen_changelog;;
		d) read_changelog;;
		h) read_nv_help;;
		x) [ $UID = 0 ] && edit_xorg_conf;;
		c) edit_color_conf;;
		n) zen_notif_setup;;
		z) edit_script_conf;;
		o) [ $UID = 0 ] && win_open_switch;;
		a) read_about;;
		u) if [ $UID = 0 ]; then legacy_drv=0; check_for_newer; check_update; fi ;;
		t) read_about;;
	esac
exit 0
done
## ### LET'S START ###
start_cmd
