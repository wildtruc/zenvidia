#!/bin/bash
#  Zenvidia
#  Sat Feb  6 16:58:20 2010
#  Copyright  2010-2023  PirateProd
#  <wildtruc@noneltd.net>
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with main.c;if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301, USA

# set -x
# set -vxEmb
# set -xmb

### ZENVIDIA VARS
install_dir=/usr/local							# default tools & system install directory
nvdir=$install_dir/zenvidia					# default Zenvidia directory
conf_dir=$nvdir
script_conf=$nvdir/script.conf				# Zenvidia conf file
nv_root=/opt										# Nvidia main driver directory
nvtmp="$nvdir/temp"								# extract temp directory
buildtmp="$nvdir/build"							# build temp directory
nvlog="$nvdir/log"								# logs directory
nvdl="$nvdir/release"							# downlaod driver backups directory
nvbackup="$nvdir/backups"
nvcompat="$nvdir/compats"
### NVIDIA-INSTALLER VARS ###					# nvidia-installer option: install temp dir
nvi_docs="$install_dir/share/doc/NVIDIA_GLX-1.0"
zen_docs="$install_dir/share/doc/zenvidia"
docs="--documentation-prefix=$install_dir"
profile_path="$install_dir/share/nvidia"
profile="--application-profile-path=$profile_path"
icon_stock=$install_dir/share/pixmaps
img_zen_desktop=$icon_stock/zen-emblem.png
img_zen_bar=zen-emblem
# need by xterm to install it self for first and fresh launch.
xt_hold=0
xt_delay=4

export PATH=$PATH:$install_dir/bin
export TEXTDOMAIN=zenvidia
export TEXTDOMAINDIR=$nvdir/locale
## terminal fonts colors.
red='\e[1;31m'
yel='\e[0;33m'
grn='\e[0;32m'
blu='\e[0;34m'
cya='\e[0;36m'
pur='\e[0;35m'
nc='\e[0m'

## ### PROLOGUE ###
## check if X server is alive
ps -A | grep -i xorg &>/dev/null
eval x_alive=$?
## save sys IFS variable for restoration purpose.
## ex: IFS=$' \t\n'
ifs=$IFS
trap "IFS=$ifs" EXIT
## read script mandatory vars config first.
. $script_conf

## find first default values for distro and desktop user
## define who is facing the screen.
def_user(){
	user=$(who | grep "(:[0-9])" | awk '{print $1}')
	test "$user" && echo $user || echo $USER
	return
}
su_cmd(){
	case $plug_version in
# 		arch|sles|mageia|mandriva) su_cmd='su -l';;
		rhel|fedora|ubuntu|mint|debian) echo "$(command -v sudo) -u" && return;;
		*) cat $script_conf | sed -En "s/su_cmd=\"(.*)\"/\1/g;p" && return;;
# 		*) echo "$(command -v su) -l" && return;;
	esac
}
pkg_installer(){ # ALERT NEW
	pkg_mng=1
	case $plug_version in
 		arch|manjaro) echo "$(command -v pacman)" ;;
 		mageia|mandriva) echo "$(command -v urpmi)";;
		rhel|fedora|centos) echo "$(command -v dnf)";;
		opensuse|sles) echo "$(command -v zypper)";;
		ubuntu|mint|debian) echo "$(command -v apt-get)";;
# 		sles) echo "";;
		*) echo "none" ; pkg_mng=0 && return ;;
	esac
}
pkg_install_cmd(){ # ALERT NEW
	pkg_inst=1
	case $plug_version in
#  		arch) PKG_INSTALLER="pacman"; pkg_cmd='install'; pkg_opts='--noconfirm ';;
 		arch|manjaro) echo "$(pkg_installer) install --noconfirm ";;
 		mageia|mandriva) echo "$(pkg_installer) -y install ";;
		rhel|fedora|centos) echo "$(pkg_installer) -y install ";;
		opensuse|sles) echo "$(pkg_installer) --non-interactive install ";;
		ubuntu|mint|debian) echo "$(pkg_installer) -y install ";;
# 		sles) echo "";;
		*) echo "none" ; pkg_inst=0 && return ;;
	esac
}
Xorg_bin(){
# 	case $plug_version in
	case $(distro_version) in
 		arch|manjaro) echo "$(command -v Xorg)";;
 		rhel|fedora|centos|mageia|mandriva|opensuse|sles) echo "$(command -v X)";;
		ubuntu|mint|debian) echo "$(command -v Xorg)";;
		*) echo "X" && return ;;
	esac
}
# elf types
libclass(){
	# debian : /x86_64-linux-gnu /i386-linux-gnu
	# arch : /usr/lib /usr/lib32
	# rpm base : /usr/lib64 /usr/lib
	unset ELF_LIST
	# remind that systemd-path system-library-arch give system arch kibs full path.
	# define distro base ELF type
	if [[ $(systemd-path system-library-arch) =~ "64" ]]; then
		ELF_TYPE="64"
		case $(distro_version) in
			arch|manjaro) master=lib; ELF_32='32'; ELF_64=''; ELF_LIST=( $ELF_64 $ELF_32 ) ;;
			rhel|fedora|centos|mageia|mandriva|opensuse|sles) master=lib; ELF_32=''; ELF_64='64';;
			ubuntu|mint|debian) master=lib; ELF_32='/i386-linux-gnu'; ELF_64='/x86_64-linux-gnu';;
			*) master=lib; ELF_32=''; ELF_64='64';;
		esac
		ELF_LIST=( $ELF_64 $ELF_32 )
		ELF_LIB_LIST=( $master$ELF_64 $master$ELF_32 )
	else
		ELF_TYPE=""
		case $(distro_version) in
			arch|manjaro) master=lib; ELF_32=''; ELF_64='' ;;
			rhel|fedora|centos|mageia|mandriva|opensuse|sles) master=lib; ELF_32=''; ELF_64='';;
			ubuntu|mint|debian) master=lib; ELF_32="/i386-linux-gnu"; ELF_64="/x86_64-linux-gnu";;
			*) master=lib; ELF_32=''; ELF_64='64';;
		esac
		ELF_LIST=( $ELF_64 )
		ELF_LIB_LIST=( $master$ELF_64 )
	fi
	# CHECK that /usr/local/ for lib is in LD conf.d path
	for LD in ${ELF_LIB_LIST[@]} ; do
		if [ $(ldconfig -p |grep -c "$install_dir/$LD") -eq 0 ]; then
			[ -e /etc/ld.so.conf.d/local-$LD.conf ] || \
			printf "$install_dir/$LD" > /etc/ld.so.conf.d/local-$LD.conf
			ldconfig
		fi
	done
}
kernel_src(){
	# debian : linux linux-headers /usr/src/kernel-headers-$(uname -r)
	# arch : linux linux-headers /lib/modules/$(uname -r)build
   # mageia, mandriva : kernel-desktop-devel-latest /usr/src/linux-$(uname -r)
	# rpm base : kernel-devel kernel-headers /usr/src/linux-$(uname -r)
	# rh : kernel-devel kernel-headers /usr/src/kernels/linux-$(uname -r)
	case $(distro_version) in
 		arch|manjaro) echo "/lib/modules/$(uname -r)/build" ;;
		rhel|fedora|centos) echo "/usr/src/kernels/linux-$(uname -r)";;
		mageia|mandriva) echo "/usr/src/linux-$(uname -r)";;
		ubuntu|mint|debian) echo "/usr/src/kernel-headers-$(uname -r)";;
		*) echo "/usr/src/linux-$(uname -r)";;
	esac
}
user_DL_DIR(){
	if [ $x_alive -eq 0 ]; then
		if [[ $(whoami) == "root" ]]; then
			echo $( $(su_cmd) $(def_user) xdg-user-dir DOWNLOAD )
		else
			echo "xdg-user-dir DOWNLOAD"
		fi
		return
	fi
}
user_CF_DIR(){
	if [ $x_alive -eq 0 ]; then
		if [[ $(whoami) == "root" ]]; then
			echo $( $(su_cmd) $(def_user) xdg-user-dir )'/.zenvidia'
		else
			echo "/home/$USER/.zenvidia"
		fi
		return
	fi
}
rem_drv_list(){
	if ! [ -f $(user_CF_DIR)/notify/drvlist ]; then
		$(su_cmd) "$(def_user)" $(command -v zen_notify) -n &>/dev/null
	fi
	echo "$(user_CF_DIR)/notify/drvlist" && return
}
distro_version(){ # var
	## taken from DKMS script for conformity with dkms queries.
	if [[ -r /etc/os-release ]]; then
		. /etc/os-release
		if [[ "$ID" = "ubuntu" ]]; then
			# ID_LIKE=debian in ubuntu
			echo $ID
		elif [[ ${#ID_LIKE[@]} != 0 ]]; then
			echo ${ID_LIKE[0]}
		else
			echo $ID
		fi
		return
	fi
	local DISTRIB_ID
	# Try the LSB-provided strings first
	if [ -r /etc/lsb-release ]; then
		. /etc/lsb-release
	elif type lsb_release &>/dev/null; then
		DISTRIB_ID=$(lsb_release -i -s)
	fi
	## fix case sensitive
	case ${DISTRIB_ID} in
		Fedora) echo fedora ;;
		RedHatEnterprise*|CentOS|ScientificSL) echo rhel ;;
		OpenSUSE|SUSE*) echo sles ;;
		Arch|Manjaro) echo arch ;;
		*) if [[ ${DISTRIB_ID} ]]; then
				echo "${DISTRIB_ID}"
			else
				echo unknown
			fi
		;;
	esac
}
distro_name(){
	local NAME
	if [[ -r /etc/os-release ]]; then
		. /etc/os-release
# 		echo $NAME
	else
		if [ -r /etc/lsb-release ]; then
		. /etc/lsb-release
		elif type lsb_release &>/dev/null; then
			NAME=$(lsb_release -i -s)
		fi
	fi
	echo $NAME
	return
}
set_su(){ # NOTE set_su is used by below fucntion only #
	w_text=$"$( cat <<-MSG
		<b><big>Zenvida didn't find any optional Distro config file
		for $plug_version</big></b>

		<b>Su command are not congigured</b>

		Without a proper <b>su</b> command prompt, Zenvidia main functions
		are unusable and script will abort.

		Please, enter <b>sudo</b> or <b>su</b> command line with options for default
		user admin priviledge.

		<i>If you don't know what is talking about here, just abort.
		</i>
	MSG
	)"
	su_opts="sudo -u!sudo -l -U!sudo -i!su -l"
	set_args=$($d_yad --width=400 --borders=15 --title="Zenvidia" --window-icon="$img_zen_desktop" --image="zen-warning" \
	--center --text="$w_text" --form --button=$"Abort"'!gtk-close:1' --button=$"Set"'!zen-ok:0' --field="":LBL '' \
	--separator=';' \
	--field=$"<b>Distribution name</b>"!$"Enter the name of the distribution if not displayed.":LABEL 'distro' \
	--field=$"<b>su comman line</b>"!$"Select a commande in the list or type one.":CBE "$su_opts"
	)
# 	set_args=$($d_yad --width=400 --borders=15 --title="Zenvidia" --window-icon="$img_zen_desktop" --image="zen-warning" \
# 	--center --text="$w_text" --form --button=$"Abort"'!gtk-close:1' --button=$"Set"'!zen-ok:0' --field="":LBL '' \
# 	--separator=';' \
# 	--field=$"<b>su command line</b>"!$"Select a commande in the list or type one.":CBE "$su_opts"
# 	)
	if [ $? = 0 ]; then
		[ "$set_args" != '' ] || exit 0
			plug_version=$(echo "$set_args"|cut -d';' -f2)
			plug_conf=$plug_version.conf
			su_cmd=$(echo "$set_args"|cut -d';' -f3)
# 			su_cmd=$(echo "$set_args"|cut -d';' -f2)
		if [ $(grep -c "su_cmd=" $script_conf ) -eq 0 ]; then echo -e 'su_cmd="'$su_cmd'"' >> $script_conf; fi
	else
		exit 0
	fi
}
distro(){ # NOTE : kept for specific distro ENV vars, if any #
	plug_version=$(distro_version)
	plug_conf=$plug_version.conf
	if [ "$(def_user)" != "root" ]; then
		if [ ! -f $conf_dir/distro/$plug_conf ]; then
			if [[ $(ls -1 $conf_dir/distro | grep -ic "$plug_conf" ) -gt 0 ]]; then
			## conf file exist but in a different upper/lower case.
				dest_conf=$(ls -1 $conf_dir/distro | grep -i "$plug_conf")
			else
			## conf doesn't exist and need to be created
			## check first if name is unknown and ask default su commabnd for user admin priv.
 				if [ $(su_cmd) == '' ]; then set_su; fi
				cat <<-CONF > $(user_CF_DIR)/$plug_conf
					## examples between [] have to be remove by real texts, vars, commands.
					# DISTRO="$plug_version"
					## resolve_dep varriable tell the script that dependencies are not installed.
					if [ \$resolve_dep = 0 ]; then
						## distro specific depencies
						## You can had there any packages matching specific distro needs.
						## ex: deplist+=("[package1]"); deplist+=("[package2]"); etc
						# deplist+=("")
					fi
					## grub/grub2 directory if different than usual.
					grub_dir=/boot/grub2
					## you can add below very specifics environment variable
					## use only by your distribution.

				CONF
				## warn about no config file
				warn_log=$"$(cat <<-WRN
				<b>Main $plug_version distro variables are now setted</b>

				You need to create a <u>new configuration</u> based on your distro environment variables.

				<i>Note : Even in case you are not sure of what you are doing, new configuration file will be saved anyway.
				You will just have to go back to it in <u>$(user_CF_DIR)/$plug_conf</u> afterward.</i>
				WRN
				)"
				qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-ok' ; kill_yad=0
				win_yad_warns

				## edit new config file.
# 				IFS=$(echo -en "\n\b")
				log_txt=$"Zenvidia $plug_version edition"; cancel_lbl=$"Abort"'!gtk-close'; ok_lbl=$"Write"'!zen-ok'
				w_formatted=1; w_wrap=1; w_width='720'; w_height='400'; all_btn=1; colors=1
				edit_plug_conf=$(win_yad_text "$(user_CF_DIR)/$plug_conf")
# 				IFS=$ifs
				if [ $_exit -eq 0 ]; then
# 				if [ $? = 0 ]; then
					echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf
				else
					## display error message and close all processes.
					warn_log=$"$(cat <<-WRN
					<b>Zenvida can work without Distro config file for $plug_version</b>

					If your distribution need very specifics values try having a look at
					your distro's community forum and ask for help.
					Then going back to the saved config file in $(user_CF_DIR)
					WRN
					)"
					warn_image='zen-error'
					qst=1; ok_lbl=$"Continue"'!zen-ok' ; cancel_lbl=$"Abort"'!zen-close' ; kill_yad=0
					win_yad_warns
					if [ $_exit -eq 1 ]; then exit 0; fi
				fi
			fi
		else
			dest_conf=$(ls -1 $conf_dir/distro | grep -i "$plug_conf")
		fi
		test -f $(user_CF_DIR)/$plug_conf || { cp -f $conf_dir/distro/$dest_conf $(user_CF_DIR)/$plug_conf ;}
		. $(user_CF_DIR)/$plug_conf
	else
		## this is here add to get compatibility in terminal only mode and isn't used in graphic mode.
		plug_conf=$(ls -1 $conf_dir/distro |grep -i "$plug_version")
		if test -f $conf_dir/distro/$plug_conf; then
		    . $conf_dir/distro/$plug_conf
		else
		    echo -e $"${red} # No distribution conf file found. Abort.${nc}"
		    exit 0
		fi
	fi
}
module_dest_location(){
	case "$(distro_version)" in
		fedora* | rhel* | ovm*) echo "extra" && return ;;
		sles* | suse* | opensuse*) echo "updates" && return ;;
		debian* | ubuntu*) echo "updates/dkms" && return ;;
		arch*) echo "updates/dkms" && return ;;
		*) echo "extra" && return ;;
	esac
}
dm_serv(){
	echo "$($d_sys show display-manager.service | sed -En "s/^Id=(.*)\..*$/\1/p")"
	return
}
zen_colors(){
	# pango colors
	end='</span>'
	v='<span color="'$main'" weight="normal" font="'$size0'" font_family="'$font0'">'	#green
	j='<span color="'$sub'">'			#orange/yellow
	y='<span color="'$log_msg'">'		#cyan/blue
	r='<span color="'$title'">'
	# big red orange title
	rBB='<span color="'$title'" weight="bold" font="20" font_family="'$font1'">'	#red
	# Big
	bf='<span font="'$size1'">'
	nf='<span font="'$size0'">'
	mf='<span font="'$(($size0+2))'">'
	sf='<span font="'$(($size0-2))'">'
	# Bold
	vB='<span color="'$main'" weight="bold" font="'$size0'" font_family="'$font0'">'
	yB='<span color="'$log_msg'" weight="bold" font_family="'$font0'">'
	jB='<span color="'$log_warn'" weight="bold" font_family="'$font0'">'
	gB='<span color="'$log_grn'" weight="bold" font_family="'$font0'">'
	rB='<span color="'$log_err'" weight="bold" font_family="'$font0'">'
	# grey dash
	# 	ge='<span color="#68686F" weight="bold">' #68686F
	ge='<span color="#68686F">'
	nr='<span color="#000000">'
	## xterm colors
	xt_colors='-fg '$fg_xterm' -bg '$bg_xterm
	xN='\e[0m'
	xB='\e[1m'
}
### SYSTEM FUNCTIONS
PCI_ID(){
	## graphic cards id
	unset dev_n dev slot slot_id vnd vnd_id dev_name
	i=0
	optimus=0
	test $UID = 0 && tee /sys/bus/pci/rescan <<<1 &>/dev/null
	sleep 1
	## rescan in case of device power switch off (nvidia-xrun, bbswitch, etc).
	pci_list=( "$(lspci -mnn | grep "VGA")" )
	IFS=$(echo -en "\n\b")
	for dev_slot in ${pci_list[@]}; do
		dev_n+=("$i")
		vnd+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^(.*) \[.*\]$/\1/p")")
		vnd_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
		if [[ "${vnd_id[$i]}" =~ "10de" ]]; then
			dev+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}'| sed -En "s/^.*\[(.*)\] \[.*\].*$/\1/p")")
			dev_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
			dev_name+=( "${dev[$i]}" ); install_dev="${dev[$i]}"
		else
			[ "${vnd_id[$i]}" = "8086" ] && dev+=("Intel Graphic") # dev+=("Intel Graphic",modesettings)
			[ "${vnd_id[$i]}" = "1002" ] && dev+=("AMD Radeon") # dev+=("AMD Graphic",flglx)
			[ "${vnd_id[$i]}" = "1022" ] && dev+=("AMD Embed") # dev+=("AMD Graphic",radeon)
			dev_name+=( "modesetting" )
			((optimus++))
		fi
		slot+=("$(printf "$dev_slot"| awk '{print $1}')")
		slot_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.*\[.*\] \[(.*)\].*$/\1/p")")
		((i++))
	done
	[ $optimus -gt 0 ] && opti_preset=1
	IFS=$ifs
# 	dev_nb=${#dev_n[*]} # test control
	pci_dev_nb=${dev_n[*]}
	if [ $i -gt 1 ]; then
		if ! [[ "${vnd_id[*]}" =~ "10de" ]]; then
			scan_alert="\n\nNvidia device was not scanned.\nRun again with root priviledge and rescan pci bus."
		fi
	fi
}

## dependencies control
dep_exec_check(){
	## clean depencies list if any.
	unset deplist
	#p_xterm=$(command -v xterm) || deplist+=("xterm")
	## multi distro system bianries compatibilities.
	d_lspci=$(command -v lspci)
	d_modinfo=$(command -v modinfo)
	d_sys=$(command -v systemctl)
	p_git=$(command -v git) || deplist+=("git")
	p_wget=$(command -v wget) || deplist+=("wget")
	p_gcc=$(command -v gcc) || deplist+=("gcc")
	p_dkms=$(command -v dkms) || deplist+=("dkms")
	d_yad=$(command -v yad) || deplist+=("yad")
	d_zen=$(command -v zenity) || deplist+=("zenity")
	d_xdpy=$(command -v xdpyinfo) || deplist+=("xdpyinfo")
	d_ssl=$(command -v openssl) || deplist+=("openssl")
	d_randr=$(command -v xrandr) || deplist+=("xrandr")
	pk_exec=$(command -v pkexec) || deplist+=("polkit")
	d_nv_installer=$(command -v nvidia-installer)
	d_nv_settings=$(command -v nvidia-settings)
	d_nv_persistenced=$(command -v nvidia-persistenced)
	d_nv_probe=$(command -v nvidia-modprobe)
	d_probe=$(command -v modprobe)
	# grub could be, grub-[command] or grub2-[command]. Let 'find' catch it for us.
	d_grub=$(find /usr/{sbin,local/sbin} -regextype sed -regex ".*grub[0-9]\?-.*"| sed -n "s/-.*$//;1p")
	# debian : linux linux-headers /usr/src/kernel-headers-$(uname -r)
	# arch : linux linux-headers /lib/modules/$(uname -r)build
   # mageia, mandriva : kernel-desktop-devel-latest /usr/src/linux-$(uname -r)
	# rpm base : kernel-devel kernel-headers /usr/src/linux-$(uname -r)
	# rh : kernel-devel kernel-headers /usr/src/kernels/linux-$(uname -r)
	if [ $resolve_dep = 0 ]; then
		case $(distro_version) in
			arch|manjaro) deplist+=("kernel-headers") ;;
			rhel|fedora|centos) deplist+=("kernel-headers"); deplist+=("kernel-devel");;
			mageia|mandriva) deplist+=("kernel-desktop-devel-latest");; # deplist+=("kernel-desktop-devel");;
			ubuntu|mint|debian) deplist+=("kernel-headers"); deplist+=("kernel-devel-$(uname -r)");;
# 			*) ;;
		esac
	fi
}
dep_control(){
	unset dep_text
	plug_version=$(distro_version)
	if [ -x $(pkg_installer) ]; then
		p_xterm=$(command -v xterm) || (
		echo -e $"${red}XTERM missing, installing ...${nc}"; $(pkg_install_cmd) xterm;
		export p_xterm=$(command -v xterm)
		)
		if [ "${#deplist[*]}" -gt 0 ] ; then
			for d in ${deplist[@]}; do
				dep_text+=("$d, ")
			done
			if [ $d_yad ]; then
				warn_text=$"$(
				cat <<-DEP
					<b>Script Dependencies Check</b>

					Required dependencies are not met.
					${dep_text[@]} are missing.
				DEP
				)"
				if [ $UID = 0 ]; then
					warn_log=$"$(
					cat <<-DEP
						$warn_text

						Will you install them now ?
					DEP
					)"
					qst=1; ok_lbl=$"Install"'!zen-ok' ; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
					win_yad_warns
					if [ $_exit = 0 ]; then
						y_text=$"Depencies installation, please wait . . ."
						pulse=1; log=1; hold=1 ; hide_txt=1 ;[ $hold = 1 ] && win_log_options
						{ timeout=30 ;{
							$(pkg_install_cmd) ${deplist[*]} 2>&1 | \
							while read line; do echo "# ${line}"; done
							echo -e "# "
							$esc_message
							sleep 2
						}& eval lpid=$!; y_pulse; } | win_yad_progress
						sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
					else
						exit 0
					fi
				else
					warn_log=$"$(
					cat <<-DEP
						$warn_text

						<b>Your are not administrator</b>.
						You need to restart with adminsitratior priviledges
						or use your packages manager to install them.
					DEP
					)"
					qst=0; ok_lbl='' ; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
					win_yad_warns
					exit 0
				fi
			else
				if [ $UID = 0 ]; then
					EXEC=$"$(
						cat <<-DEP
							read -p "Will you install them now ? (Y/N) :" confirm
							if [[ "\$confirm" =~ [yY] ]]; then
								echo -e "\n${grn}Depencies installation, please wait . . .${nc}\n"
								$(pkg_install_cmd) ${deplist[*]}
								sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
							else
								echo -e "\n${red}Those dependencies are mandatory for Zenvidia.${nc}\n"
								echo -e "If you don't want Zenvidia to install them automatically,"
								echo -e "you need to use your packages manager instead"
								echo -e "BYE !"
							fi
						DEP
					)"
				else
					EXEC=$"$(
						cat <<-DEP
							echo -e "Zenvidia is start without admin priviledges."
							echo -e "You need to restart with ${red}Zenvidia (admin)${nc} to install them."
						DEP
					)"
				fi
				w_text=$"$(
					cat <<-DEP
						#set -x
						echo -e "${red}Script Dependencies Check${nc}\n"

						echo -e "Required dependencies are not met.\n"
						echo -e "${dep_text[*]}\n"
						$EXEC
						echo -e "\n${cya}*****  Close window to escape *****${nc}"
					DEP
					)"
				primary_dsp=$(xrandr --current| grep -w "connected"| grep primary)
				term_x_dsp=$(printf "$primary_dsp"| grep -o "[0-9]\{3,4\}[x]"|sed -n "s/x//p")
				xt_options=' -hold -fn 8x13 -geometry 80x24+'$[ ( ($term_x_dsp-660)/2) ]'+0'
				$p_xterm $xt_options -e "$w_text"
			fi
			dep_exec_check
		fi
	else
		echo -e $"${red}NO PACKAGE INSTALLER FOUND, ABORTING.${nc}\n"; exit 0
	fi
}
connection_control(){ #
	cnx=$(ping -c2 www.nvidia.com); cnx=$?
	if [ $cnx -eq 1 ]; then
		w_text=$"$( cat <<-MSG
			No internet connection detected.
			A valid network connection is required for any download.
		MSG
		)"
		echo -e "${red}$w_text${nc}"
		qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-warning' ; kill_yad=0
		win_yad_warns
		cnx_msg=$"NONE"
	else
		cnx_msg=$"Connected"
	fi
}

## If version 'undifined', control if driver is initialy installed.
check_version(){ # ALERT CHECK where the vars starts. #
	if [ $from_install = 0 ]; then
		if ! [[ $(version) =~ [0-9]* || $(new_version) =~ [0-9]* ]]; then
			warn_log=$"$( cat <<-ERR
				${j}${bf}Version text file not found.${end}${end}

				Look like driver isn't installed initialy.
				Go to ${y}<b>» Main menu » Install drivers</b>${end} first.
			ERR
			)"
			warn_image='zen-error'
			qst=0; ok_lbl=$"Ok"'!zen-ok' ; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
			win_yad_warns
			base_menu
		fi
	fi
}

# ### INSTALL & COMPIL SECTION ###
## TOOLS ###
## gcc and other compatibility control
display_and_compil_vars(){ #
	if [ -s ${d_nv_installer} ]; then
		NV_bin_ver=$($d_nv_installer -v | grep "nvidia-installer"|awk '{print $3}')
	else
		NV_bin_ver='none'
	fi
	if [[ $(gcc --version | grep "gcc") ]]; then
		GCC=$(gcc --version | grep "gcc" | sed -n "s/^.*) //p"| awk '{print $1}')
	else
		GCC='none'
	fi
	KERNEL=$(uname -r)
	kernel_path="/lib/modules/$KERNEL/$(module_dest_location)/"
	# xterm/yad  vars and messages.
	x_pixel=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.* ([0-9]{3,5})x([0-9]{3,5}) .*$/\1;\2/1p")
	x_milli=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.*\(([0-9]{3,4})x([0-9]{3,4}).*\).*$/\1;\2/1p")
	term_x_dsp=$(printf "$x_pixel"| cut -d';' -f1)
	[ $xt_hold = 0 ]|| xx_hold=' -hold'
	if [ $xt_hold = 1 ]; then
		x_esc_message=$"\n${nc}*****  Close window to escape *****"
		x_sleep=''
	else
		x_esc_message=$"\n${nc}*****  Window will auto-close in $xt_delay seconds *****"
		x_sleep="sleep $xt_delay"
	fi
	xt_options=$xt_colors''$xx_hold' -fn 8x13 -geometry 80x24+'$[ ( ($(printf "$x_pixel"| cut -d';' -f1)-660)/2) ]'+0'
	grub_cfg=$(find /boot -wholename "*/grub.cfg")
	grub_def=/etc/default/grub
}
## system pre config.
nv_open_modules_set(){ #
	# nvidia_installer give the possibility to use open driver version, but not the possibility to choose
	# between open or proprietary version by installing both, or just test open only.
	# let's do it.
	if [ $open_wrn = 1 ]; then
		if [ $extract_open = 1 ]; then
			if [ $use_open -ne 1 ]; then
				_title="$_zen_title"
				_text=$"$(cat <<-MSG
					${jB}Nvidia Open Source Modules${end}
					${vB}Since 515 driver series, it is possible to use nvidia open source drivers
					By default, Zenvidia will build them alongside the main ones.

					AT THIS POINT, OPEN SOURCE DRIVERS WILL BE ONLY BUILD.
					You will be able to switch between version with the ${j}Open Driver Switch Tool${end}
					in ${j}Configuration and Tools${end} menu (restart Zenvidia is mandatory).

					${j}WARNING ${end}:${v}<i> Open drivers are in still in early state, many features are not
					accessible at this point.
					Check progress in Nvidia Changelog update regulary</i>.${end}

					Do you want to build open source drivers ?${end}
				MSG
				)"
				warn_log=$_text
				qst=1; ok_lbl=$"Yes, please"'!zen-ok' ; cancel_lbl=$"No thanks"'!zen-close' ; kill_yad=0
				win_yad_warns
				if [ $_exit = 0 ]; then
					open_drv=1; use_open=0
				else
					open_drv=0; use_open=0
				fi
				sed -Ei "s/^(use_open)=[0-9]$/\1=$use_open/" $basic_conf
				sed -Ei "s/^(open_drv)=[0-9]$/\1=$open_drv/" $basic_conf
				if [ $first_open = 1 ]; then
					_text=$"$(cat <<-MSG
						${jB}Nvidia Open Source Modules${end}

						${j}WARNING ${end}:${vB}By default, Zenvidia send alert about open driver building,
						If you select ${j}<i>NO</i>${end} here, the previous window won't be displayed again.

						${v}<i>(Choice will be saved in configuration file and could be changed)</i>${end}

						Do you want to be warn at each drivers upgrade ?${end}
					MSG
					)"
					warn_log=$_text
					qst=1; ok_lbl=$"Yes, please"'!zen-ok' ; cancel_lbl=$"No thanks"'!zen-close' ; kill_yad=0
					win_yad_warns
					if [ $_exit = 0 ]; then
						first_open=0; open_wrn=1
					else
						first_open=0; open_wrn=0
					fi
					sed -Ei "s/^(open_wrn)=[0-9]$/\1=$open_wrn/" $basic_conf
					sed -Ei "s/^(first_open)=[0-9]$/\1=$first_open/" $basic_conf
				fi
			fi
		fi
	fi
	## check for open drivers source dir in tree
	if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
		cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open /usr/src/open-nvidia-$(new_version)
	fi
}
gcc_and_proc_options(){
	# test driver code compilator version __GNUC__, __GNUC_MINOR__
	test $(grep -E -c "gcc_mismatch" $basic_conf) -gt 0 && (
		if [ $gcc_mismatch = 1 ]; then ignore_mismatch="IGNORE_CC_MISMATCH=1"; else ignore_mismatch=''; fi
		export IGNORE_CC_MISMATCH=$gcc_mismatch
	)
	proc=$(grep -E -c "processor.*[0-9]{,2}" /proc/cpuinfo)
	## Select tuen compression coantainer for backup.
	if [ $use_gzip -eq 0 ]; then
	## XZ, ZST compression cab is not made for weak processors, try at least to define a minimum number of cores required.
 		#[ $proc -gt 12 ] && ZIP='ZST' && zip_opt='zst' && zip_ex='.zst'
		[ $proc -gt 8 ] && ZIP='XZ' && zip_opt='xz' && zip_ex='.xz'
		[ $proc -le 8 ] && ZIP='GZIP' && zip_opt='gzip' && zip_ex='.gz'
	else
		ZIP='GZIP'; zip_ex='.gz'
	fi
}
## PAY ATTENTION : With RT kernel, drivers could install properly but they could also not init at Xorg start.
## Do not ever overwrite current used kernel by RT one.
rt_options(){ #
# test if kernel is realtime.
	is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
	if [ $is_RT = 1 ]; then
		## user warning
		warn_log=$"$( cat <<-TXT
			${rBB}REALTIME Kernel Detected${end}
			${vB}ATTENTION :${v} You are about to install driver on a realtime kernel.

			Don't forget Nvidia drivers is not normaly made for realtime.
			Troubles init at boot time could happen.
			Think about making a root partition backup if you have no fallback.

			${j}"<b> dd if=/dev/sdxx of=root.img bs=1024k status=progress </b>"${end}
			(from a live usb)

			Do you really want to use compilation over realtime kernel ?${end}${end}
			TXT
		)"
		# yes 0, no 1
		warn_image='zen-warning'
		qst=1; ok_lbl=$"Proceed"'!zen-ok' ; cancel_lbl=$"Abort"'!zen-close' ; kill_yad=0
		win_yad_warns
		if [ $_exit = 0 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		else
			base_menu
		fi
	fi
}
## nvidia driver vars [in functions)
## some sets have to be place as function to be re-used at multi levels.
version(){ # NOTE : user config dir or not ?
	#test -f $(user_CF_DIR)/version.txt && cat $(user_CF_DIR)/version.txt || echo "0"
# 	test -f $nvdir/version.txt && cat $nvdir/version.txt || echo "0"
	test -f $nvdir/version.txt && cat $nvdir/version.txt || \
	{	$d_modinfo -F version nvidia &>/dev/null
		[ $? -eq 0 ] && $d_modinfo -F version nvidia || echo 0
	}
	return
}
new_version(){
	if [ $from_install ]&&[ $from_install = 1 ]; then
			if [ "$run_pkg" ]; then
				echo "$run_pkg" | sed -En "s/^.*-(.*)/\1/; s/.run//g;p"
			else
				echo "$LAST_PACK"
			fi
	else
		echo "$(version)"
	fi
	return
}
old_version(){
	$d_modinfo -F version nvidia -k $KERNEL &>/dev/null
	if [ $? -eq 0 ]; then
		if test -f $tmp_old; then
			cat $tmp_old
		else
			$d_modinfo -F version nvidia -k $KERNEL
		fi
	else
		echo "0"
	fi
	return
}
nv_old(){
	unset count_array prefix part
	count_array=( $(printf "$(old_version)"|tr . ' ') )
	for c in ${count_array[@]}; do
		i=$(printf "$c"|wc -m)
		for ((i=$i; i<3; i++)) { prefix='0';}
		part+=$(printf ${prefix}$c)
	done
	[ ${#count_array[*]} -eq 3 ] || suffix='000'
	echo "${part[*]}$suffix"
	return
}
nv_new(){
	if [ "$(new_version)" ]&&[ "$(new_version)" != "0" ]; then
		unset count_array prefix part
		count_array=( $(printf "$(new_version)"|tr . ' ') )
		for c in ${count_array[@]}; do
			i=$(printf "$c"|wc -m)
			for ((i=$i; i<3; i++)) { prefix='0';}
			part+=$(printf ${prefix}$c)
		done
		[ ${#count_array[*]} -eq 3 ] || suffix='000'
		echo "${part[*]}$suffix"
	else
		echo "$(version)"| sed -n "s/\.//g;p"
	fi
	return
}
mod_installed(){ # used by nv_build_dkms only
 	test -d $kernel_path && find $kernel_path -name "nvidia.*[ko\|ko.xz]" -print0 | xargs -0 modinfo -F version
 	return
}
old_inst(){ # used by nv_build_dkms only
	if [ $(mod_installed) ]; then
		unset count_array prefix part
		count_array=( $(printf "$(mod_installed)"|tr . ' ') )
		for c in ${count_array[@]}; do
			i=$(printf "$c"|wc -m)
			for ((i=$i; i<3; i++)) { prefix='0';}
			part+=$(printf ${prefix}$c)
		done
		[ ${#count_array[*]} -eq 3 ] || suffix='000'
		echo "${part[*]}$suffix"
	else
		echo "0"
	fi
}
chk_family(){ [ $(echo "$(new_version)"| grep -c '.') -gt 0 ] && echo "$(new_version)"| cut -d'.' -f1 || echo '0'; }
chk_old_family(){ [ $(echo "$(old_version)"| grep -c '.') -gt 0 ] && echo "$(old_version)"| cut -d'.' -f1 || echo '0'; }
## define installed driver version, if any
drv_installed(){ ## FIXME retirer la ligne de migration version.txt aux prochaines mises à jour.
	test -f $(user_CF_DIR)/version.txt || cat $nvdir/version.txt > $(user_CF_DIR)/version.txt
	[ "$(cat $(user_CF_DIR)/version.txt)" != "$(version)" ] && echo "$(version)" > $(user_CF_DIR)/version.txt
	if [ "$(version)" == "0" ]; then
		echo $"not installed"
	else
		echo $(version)
fi
}
## initramfs tools detect and config.
initramfs_tools(){
	## try to find 'dracut' first, then fallbback to 'update-initramfs' if not found.
	## look the possibility to add /usr/bin/mkinitcpio -p linux. how-to ?
	## if none are found, disable ramfs rebuild and warn.
	for init_sys in {dracut,update-initramfs,mkinitcpio}; do
# 	for init_sys in {update-initramfs,mkinitcpio,dracut}; do
		command -v $init_sys &>/dev/null && {
		[ "$init_sys" = "dracut" ] && echo "$init_sys -f --kver" && return
		[ "$init_sys" = "update-initramfs" ] && echo "$init_sys -u -k" && return
		[ "$init_sys" = "mkinitcpio" ] && echo "$init_sys -p linux --kernel" && return
		} || echo 0
	done
}
test_ramfs_tool(){
## detect if ramfs tool exist then send to initramfs_warn if none.
	test "$(initramfs_tools)" = 0 && echo 0 || echo 1
}
initramfs_warn(){ #
	if [ $(test_ramfs_tool) = 0 ]; then
		## send alert
		## and ask to proceed with modprobe reload if initramfs tool is no detected.
		_text=$"$( cat <<-WRN
			${j}<b>No tool were found to rebuild initramfs</b>${end}
			Modprobe reload could work for the used kernel,
			but probably not for an extra kernel.
			Updated Modules wont probably load at reboot.

			You have been warn !
		WRN
		)"
		warn_log=$_text
		warn_image='zen-warning'
		qst=1; ok_lbl=$"Proceed"'!zen-ok' ; cancel_lbl=$"Abort"'!zen-close' ; kill_yad=0
		win_yad_warns
		if [ $_exit = 1 ]; then
			exec_mod_tool=0
			base_menu
		else
			exec_mod_tool=1
		fi
	fi
}
## commands ###
exec_depmod(){
	 if [[ -f /boot/System.map-$1 ]]; then
        /usr/sbin/depmod -a "$1" -F "/boot/System.map-$1"
    else
        /usr/sbin/depmod -a "$1"
    fi
    return $?
}
exec_mod_load(){ # NOTE : still in question.
	## from DKMS script (partly)
	# ATTENTION modprobe on device only ?
	#nv_pci=$(grep "10de" <<< ${pci_n[*]}|cut -d, -f2 )
# 	nv_pci=${slot[0]}
	#find /sys/devices -regextype sed -regex ".*$nv_pci.*modalias" -print0 | xargs -0 cat | xargs modprobe -b
# 	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.gz"
	# or modprobe on all mandatory ?
	find /sys/devices -name modalias -print0 | xargs -0 cat | xargs modprobe -a -b -q
# 	command -v restorecon &>/dev/null && restorecon -iF "/boot/symvers-$KERNEL.*"
	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.*"
	if [ -f /lib/systemd/system/systemd-modules-load.service ]; then
		$d_sys restart systemd-modules-load.service
	fi
	return $?
}
exec_initramfs(){
## rebuild initramfs if modules reload service found is uselees in the case.
	## progress message is place before fuction exec and formated like this :
	## progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; } for zenity.
	## progress_msg(){ echo -en "\r# ($m%) - Rebuilding INITRAMFS"; } for terminal.
	## last 'echo' is for zenity progress bar only. ex:
	# 	echo "# Updating $KERNEL initramfs."; sleep 2
	# 	progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; }
	# 	m=1 ;
	progress "$(initramfs_tools) $KERNEL" #; . $tmp_c
	return $?
}
nv_persistenced(){
	## nvidia percistenced allow GPU to be pre init in some case.
	nv_persist_ctl=/lib/systemd/system/nvidia-persistenced.service
	if [[ $use_persistenced = 1 || $use_open = 1 && $(chk_family) -ge 535 ]]; then
		[ -f $nv_persist_ctl ] || { touch $nv_persist_ctl; chmod 644 $nv_persist_ctl; nv_persistenced_conf;}
# 		nv_persistenced_conf
		systemctl daemon-reload
		systemctl enable nvidia-persistenced.service
		systemctl start nvidia-persistenced.service
	else
		[ -f $nv_persist_ctl ] && {
			systemctl disable nvidia-persistenced.service
			systemctl stop nvidia-persistenced.service
			systemctl daemon-reload
		}
	fi
}
back_old_driver(){
	mkdir -p $nvtmp/old_kernel/
	cp -f $kernel_path/nvidia* $nvtmp/old_kernel/
}
restore_old_driver(){ #
	if [ -f $nvtmp/old_kernel/nvidia.*[ko\|ko.xz] ]; then
		echo -e $"#${j} ** Restoring previous drivers to $kernel_path ** ${end}"
		cp -f $nvtmp/old_kernel/nvidia* $kernel_path/
		progress_msg(){ echo -e $"# ${ge}${sf} * Depmod $KERNEL modules ($m sec.)${end}${end}"; }
		m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"
	fi
}
restore__driver(){ #
	if [ -f $nvtmp/${1}/nvidia.*[ko\|ko.xz] ]; then
		echo -e $"#${j} ** Restoring drivers to $kernel_path ** ${end}"
		cp -f $nvtmp/${1}/nvidia* $kernel_path/
		progress_msg(){ echo -e $"# ${ge}${sf} * Depmod $KERNEL modules ($m sec.)${end}${end}"; }
		m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"
	fi
}
restore_pcks_cmd(){ #
	# p: preserve perm, h: preserve sym, f: file.
	if [ $cmd_ver ]; then
		res_version=$cmd_ver
		zip_type=$(ls -1 $nvbackup/nvidia.$cmd_ver.tar.* | sed -n 's/.*\.//;1p')
	else
		zip_type=$res_suffix
	fi
	[ "$zip_type" = "gz" ] && zip_opt='gzip'
	[ "$zip_type" = "xz" ] && zip_opt='xz'
	[ "$zip_type" = "zst" ] && zip_opt='zstd'
	if [ $x_alive -gt 0 ]; then
		echo -e $"# ${yel}Uncompressing $cmd_ver archive for $KERNEL${nc} :\n"
		verbose='-v'
	else
		if [ $from_install = 1 ]; then
			progress_msg(){ echo -e $"# ${j}($m s)${end}${ge}${sf} - Restoring from nvidia.$res_version.tar.$zip_type${end}${end}";
			echo "$m"; }
		else
			progress_msg(){ echo -e $"# ($m sec.) - Restoring from nvidia.$res_version.tar.$zip_type"; echo "$m"; }
		fi
	fi
	m=1; do_slp=1
	progress "tar --$zip_opt $verbose -xf $nvbackup/nvidia.$res_version.tar.$zip_type -C /"
	ldconfig
}
restore_broken_install(){
	# restore previous libs from backuyp if exist, then restore saved drivers.
	if [ $nv_old -gt 0 ]; then
		echo -e $"# ${j}<b>Restoring $(old_version) Librairies installation</b>${end}"
		res_version=$(old_version)
		res_suffix=$(ls -1 $nvbackup/$res_version.tar.* | sed -n 's/.*\.//;1p')
		restore_pcks_cmd
		$d_modinfo -F version nvidia -k $KERNEL | grep "$(old_version)" &>/dev/null
		if [ $? -eq 1 ]||[ "$($d_modinfo -F version nvidia -k $KERNEL)" != "$(old_version)" ]; then
			restore__driver "old_kernel"
		fi
	fi
}
## configuration ###
dm_service_patch(){ # # ALERT fix to remove nvidia-modules-reload
	systemd_dir=/usr/lib/systemd/system
	ExecStartPre=$(command -v zenvidia-modules-reload)
	ExecStart=$(command -v $(dm_serv))
# 	#### ALERT previous fix to remove in next release.
# 	if [ $(cat $systemd_dir/$(dm_serv).service | grep -c "Pre=/usr/local/bin/nvidia-modules-reload") -gt 0 ]; then
# 		cp -f $systemd_dir/$(dm_serv).service.bak $systemd_dir/$(dm_serv).service
# 	fi
# 	test -f /usr/local/bin/nvidia-modules-reload && rm -f /usr/local/bin/nvidia-modules-reload
# 	####
	## make dm.service backup
	[ -e $systemd_dir/$(dm_serv).service.bak ] || cp -f $systemd_dir/$(dm_serv).service $systemd_dir/$(dm_serv).service.bak
	if [ $(grep -c "$ExecStartPre" $systemd_dir/$(dm_serv).service) -eq 0 ]; then
		if [ $from_install = 1 ]; then
			echo $"# ${v}${j}($n%)${end} - Patching $(dm_serv).service for driver load at session restart (experimental)${end}"
			sleep 2
			n=$[ $n+2 ]; echo "$n"
		else
			echo $"# Patching $(dm_serv).service for driver load at session restart (experimental)."
		fi
		sed -Ei 's|^(ExecStart='${ExecStart}')$|ExecStartPre='${ExecStartPre}'\n\1|' $systemd_dir/$(dm_serv).service
# 		$d_sys daemon-reload
	fi
	$d_sys daemon-reload
}
restart_dm_warn(){ #
	# can be potentially add : gdm, sddm, lightdm, lxdm (gdm,kdm,xdm,lightdm,lxdm,slim,sddm)
	warn_log=$"$( cat <<-MSG
		$warn_log_title
		${v}Restart display manager service${end} (${y}experimental${end})

		This is a experimental feature allowing drivers to be relaod
		at simple display manager restart.

		Potentialy usable : gdm, sddm, lightdm, lxdm.
		Unsable : kdm
		(lighdm only tested at this point).

		Be aware that system driver management will be complete only
		after system reboot.

	MSG
	)"
	# win_yad_warns
	qst=1; ok_lbl=$"Yes"'!zen-ok' ; cancel_lbl=$"No, I will reboot"'!zen-undo' ; kill_yad=0
	win_yad_warns
	[ $_exit = 0 ] && { IFS=$ifs; touch /var/run/nv-modules-reload.pid; $d_sys restart display-manager.service; }
}
nv_persistenced_conf(){
	## NOTE : ExecStart could be added a multiple time.
	cat <<-SYS > $nv_persist_ctl
		[Unit]
		Description=NVIDIA Persistence Daemon
		Wants=syslog.target

		[Service]
		Type=forking
		PIDFile=/var/run/nvidia-persistenced/nvidia-persistenced.pid
		#Restart=always
		ExecStart=$d_nv_persistenced --user $(def_user) --persistence-mode --verbose
		ExecStopPost=/bin/rm -rf /var/run/nvidia-persistenced

		[Install]
		WantedBy=multi-user.target
		SYS
}
nv_open_switch(){ # NVIDIA MODULE SWITCH. #
	probe_open=/etc/modprobe.d/open-NVIDIA.conf
	reverse_conf(){
		[ $open_drv -ne $old_open_drv ]&& { sed -Ei "s/^(open_drv)=.*$/\1=$old_open_drv/" $basic_conf
			eval open_drv=$old_open_drv ;}
		[ $use_open -ne $old_use_open ]&& { sed -Ei "s/^(use_open)=.*$/\1=$old_use_open/" $basic_conf
			eval use_open=$old_use_open ;}
		[ $task_opt -gt 0 ] && exit 0 || menu_modif
	}
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -ne $old_use_open ]; then
			if [ $use_open -eq 1 ]; then
				drv_on='open-nvidia'
				drv_off='nvidia'
			else
				drv_on='nvidia'
				drv_off='open-nvidia'
			fi
			warn_log=$"$( cat <<-MSG
				${j}${bf}$drv_on switch${end}${end}
				${v}You are going to switch from ${j}$drv_off${end} to ${j}$drv_on${end}
				Are you sure ?${end}
			MSG
			)"
			# win_yad_warns
			qst=1; ok_lbl=$"Yes, switch to $drv_on"'!zen-ok' ; cancel_lbl=$"No, keep $drv_off"'!zen-undo' ; kill_yad=0
			win_yad_warns
			if [ $_exit = 1 ]; then reverse_conf; [ $task_opt -gt 0 ] && exit 0 || menu_modif; fi
			## Switch exec start here
			y_text=$"DRIVER SWITCH from DKMS ${j}$drv_off${end} to ${j}$drv_on${end} build"
			pulse=1; log=1; hold=1 ; hide_txt=1; [ $hold = 1 ] && win_log_options
			{	timeout=30
			{	echo -e $"# ${v}Switching from ${y}$drv_off${end} to ${y}$drv_on.${end}${end}"
				## 6 ops for progress.
				if [ -d /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module ]; then
					cp -f /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
					echo -e $"# ${v}Depmod ${j}$KERNEL${end} modules ...${end}"
					sleep 2
					progress_msg(){ echo -e $"# ${ge}${sf} * Depmod $KERNEL modules ($m sec.)${end}${end}"; }
					m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"
				else
					## NOTE : in case of a fresh kernel update, only the predifined type is compile and install by dkms
					## and thus, var/lib/dkms module dir doesn't exist. It is there need to recompile the all stuff
					tmp_b=$(mktemp --tmpdir zn_vars.XXX)
					rem_tmp+=("rm -f $tmp_b")
					nv_build_dkms
				fi
				if [[ $drv_on == "nvidia" ]]; then
					license="NVIDIA"
				else
					license="Dual MIT/GPL"
				fi
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "$license" ]]; then
					echo -e $"# ${v}License is $license${end}"
				else
					echo -e $"# ${r}ERROR!${end}${y}: License is steal $license, reversing all.${end}"
					reverse_conf
				fi
				sleep 2
				## add or remove open-driver kernel options.
				if [ $use_open -eq 1 ]; then
					if [ $(chk_family) -lt 545 ]; then
						echo -e $"# ${v}Set ${y}$drv_on${end} kernel options.${end}"
						cat <<-CONF > $probe_open
							options nvidia NVreg_OpenRmEnableUnsupportedGpus=1
						CONF
					fi
				else
					echo -e $"# ${v}Unset ${y}$drv_off${end} kernel options.${end}"
					[ -f $probe_open ] && rm -f $probe_open
				fi
				nv_persistenced
				echo -e $"# ${v}Re-create ${j}$KERNEL${end} initramfs ...${end}"
				sleep 2
				progress_msg(){ echo $"# ${ge}${sf} * Exec $KERNEL modules iniramfs ($m sec.)${end}${end}"; echo "$m"; } ; m=1; do_slp=1
				#rebuild initramfs
				if [ $exec_mod_tool = 1 ]; then
					echo -e $"# ${v}Exec ${j}$KERNEL${end} modules reload${end}"; sleep 2
					exec_mod_load
				else
					## rebuild iniramfs first.
					echo -e $"# ${v}Exec ${j}$KERNEL${end} modules initramfs update${end}"; sleep 2
					exec_initramfs
					echo -e $"# ${v}Restore ${j}$KERNEL${end} modules selinux connection ...${end}"
					sleep 2
					## systemctl restart systemd-modules-load.service
					progress_msg(){ echo $"# ${ge}${sf} * Exec $KERNEL modules reload ($m sec.)${end}${end}"; echo "$m"; } ; m=1; do_slp=1
					exec_mod_load
				fi
				sleep 2
				## add no-autoinstall blank file
				touch /etc/dkms/no-autoinstall
				## set DKMS AUTOINSTALL values for each driver type.
				echo -e $"# ${v}Set ${y}$drv_on${end} DKMS AUTOINSTALL option to \"yes\".${end}"
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/$drv_on-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
				sed -ni "s/AUTOINSTALL.*$/*/;{/^.*\*$/d;s/^\ //g;p}" /usr/src/$drv_off-$(version)/dkms.conf
				## set diplayed license by driver type.
				sleep 2
				echo -e "# "
				# echo -e "# ${v}Reboot for ${y}$drv_on${end} to take effect.${end}"
				echo -e $"# ${v}Driver ${y}$drv_on${end} switch done.${end}"
				sleep 2
				echo -e $esc_message
				$x_sleep
				sed -Ei "s/^(use_open)=.*$/\1=$use_open/" $basic_conf
			} & eval lpid=$!; y_pulse; } | win_yad_progress
			warn_log_title=$"${j}${bf}$drv_on switch${end}${end}"
			restart_dm_warn
		fi
		trap "${rem_tmp[*]}" EXIT
	else
		if [ $open_drv -ne $old_open_drv ]; then
			confirm_msg=$"$( cat <<-MSG
			${j}${bf}Open Driver removal${end}${end}
			${v}You are going to remove open source driver from driver tree.
			Are you sure ?${end}
			MSG
			)"
			# win_yad_warns
			qst=1; ok_lbl=$"Yes, remove"'!zen-ok' ; cancel_lbl=$"No, preserve"'!zen-undo' ; kill_yad=0
			win_yad_warns
			if [ $_exit = 1 ]; then reverse_conf; [ $task_opt -gt 0 ] && exit 0 || menu_modif; fi
			## remove dkms driver tree.
			y_text=$"Open Source Drivers deletion"
			pulse=1; log=1; hold=1 ; hide_txt=1; [ $hold = 1 ] && win_log_options
			{	timeout=30
			{	sleep 2
				## 7 ops progress.
				echo -e $"# ${v}Remove ${j}open source${end} drivers from DKMS tree${end}"
				/usr/sbin/dkms remove -m "open-nvidia"/$(version) -all
				sleep 2
				echo -e $"# ${v}Restoring ${y}default${end} Nvidia drivers.${end}"
				cp -f /var/lib/dkms/nvidia/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
				sleep 2
				echo -e $"# ${v}Depmod ${j}$KERNEL${end} modules ...${end}"
# 				depmod -a -kver $KERNEL
				progress_msg(){ echo -e $"# ${ge}${sf} * Depmod $KERNEL modules ($m sec.)${end}${end}"; }
				m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"
				sleep 2
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "NVIDIA" ]]; then
					echo -e $"# ${v}License is back to NVIDIA${end}"
				else
					echo -e $"# ${r}ERROR!${end}${y}: License is still Dual MIT/GPL, abort.${end}"
					reverse_conf
					exit 1
				fi
				echo -e $"# ${v}Restore ${j}$KERNEL${end} modules connection ...${end}"
				sleep 2
				## systemctl restart systemd-modules-load.service
				progress_msg(){ echo $"# ${ge}${sf} * Exec $KERNEL modules reload ($m sec.)${end}${end}"; echo "$m"; } ; m=1; do_slp=1
				exec_mod_load
				## remove no-autoinstall blank file
				test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
				echo -e $"# ${v}Set Nvidia DKMS AUTOINSTALL option to \"yes\".${end}"
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/nvidia-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
				sed -n "s/AUTOINSTALL.*$/*/i;{/^.*\*$/d;s/^\ //i;p}" /usr/src/open-nvidia-$(version)/dkms.conf
				sleep 2
				echo -e $"# ${v}Unset ${y}$drv_off${end} kernel options (if any).${end}"
				[ -f $probe_open ]&& rm -f $probe_open
				sleep 2
				echo -e $"# ${v}Set back Configuration file to NVIDIA only.${end}"
				sed -Ei "s/^(open_drv)=.*$/\1=0/" $basic_conf
				sed -Ei "s/^(use_open)=.*$/\1=0/" $basic_conf
				sleep 2
				echo -e ""
				echo -e $"# ${v}Reboot for change to take effect.${end}"
				sleep 2
				echo -e $esc_message
				$x_sleep
			} & eval lpid=$! ; y_pulse; } | win_yad_progress
			warn_log_title=$"${j}${bf}Nvidia Driver refresh.${end}${end}"
			restart_dm_warn
		fi
	fi
}
blacklist_and_grub_set(){ # Perform blacklist and grub config. #
	## font display differently if install process in on.
	if [ $from_install = 1 ]; then
		fonts="${j}($n%)${end}${ge}${sf}"
		sub_fonts="${ge}($n%)${sf}"
	else
		fonts="${ge}${nf}"
		sub_fonts="${ge}${sf}"
	fi
	blacklist='nouveau.modeset=0 rd.driver.blacklist=nouveau'
	test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='.* '
	## Older driver version wasn't supporting frame buffer distro splash screen, and need
	## drm_modset 0. NOTE : 440 serie is set as default, but the real serie where
	## this option is needed is not known > too old.
	[ $(chk_family) -le 440 ] && drm_modset=0
	[ $(chk_family) -ge 545 ] && drm_fbdev=' nvidia-drm.fbdev=1' || drm_fbdev=''
	## take care of modeset 1 for 515 serie too.
	if [ $opti_preset = 1 ]; then
		## optimus section.
		drm_modset=1; drm_msg='Optimus device'
		if [ "$old_drm_modset" != '' ]&&[ $drm_modset -ne $old_drm_modset ]; then
			sed -Ei "s/^(drm_modset)=.*$/\1=$drm_modset/" $basic_conf
		fi
	else
		drm_msg=$(chk_family)' serie'
	fi
	if [ $(grep -c "GRUB_CMD.*nouveau" $grub_def) -gt 0 ]; then
		if [ $(cat $grub_def| grep -E -c "^GRUB_CMD.*$blacklist nvidia-drm.modeset=$drm_modset$drm_fbdev $grub_orig.*$") -eq 0 ]; then
			if [ "$timeout" != '' ];then
				echo $"# GRUB conf options update."; sleep 2
			else
				echo $"# ${fonts} * GRUB conf options update.${end}${end}"; sleep 2
			fi
			## then, replace default env grub with new vars and update grub.cfg.
			sed -Ei "s/^(GRUB_CMD.*)=\"(.*) ($grub_orig.*)\"$/\1=\"$blacklist nvidia-drm.modeset=$drm_modset$drm_fbdev \3\"/" $grub_def
			$d_grub-mkconfig -o $grub_cfg 2>&1 | \
			while read -r line; do
				if [ "$timeout" != '' ];then
					echo "# * ${line}"
				else
					echo "# ${sub_fonts} * ${line}${end}${end}"; ((n++)); echo $n
				fi
			done
		else
			if [ "$timeout" != '' ];then
				echo $"# GRUB conf already set."; sleep 2
			else
				echo $"# ${fonts} * GRUB conf already set.${end}${end}"; sleep 2
			fi
		fi
	else
		if [ "$timeout" != '' ];then
			echo $"# Create GRUB conf for nouveau driver blacklisting and other options."; sleep 2
		else
			echo $"# ${fonts} * Create GRUB conf for nouveau driver blacklisting and other options.${end}${end}"; sleep 2
		fi
		sed -En "s/^GRUB_CMD.*=\"(.*)\"$/grub_orig='\1'/p" $grub_def > $(user_CF_DIR)/grub-orig
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$blacklist nvidia-drm.modeset=$drm_modset$drm_fbdev \2\"/" $grub_def
		$d_grub-mkconfig -o $grub_cfg 2>&1 | \
		while read -r line; do
			if [ "$timeout" != '' ];then
				echo "# * ${line}"
			else
				echo "# ${sub_fonts} * ${line}${end}${end}"; ((n++)); echo $n
			fi
		done
	fi
	## blacklist nouveau
	[ -e /etc/modprobe.d/blacklist-nouveau.conf ] || echo "blacklist nouveau" > /etc/modprobe.d/blacklist-nouveau.conf
	## NOTE : This part is unsure, usualy nvidia driver prefer modeset config in grub,
	## this filter could be remove in near future.
	if [ $(chk_family) -ge 535 ]; then
		drm_conf_file=/etc/modprobe.d/nvidia-drm.conf
		grep "modeset=$drm_modset" $drm_conf_file &>/dev/null
		if [ $? -gt 0 ]; then
			if [ "$timeout" != '' ];then
				echo $"# Update modprobe nvidia-drm option for $drm_msg."; sleep 2
			else
				echo $"# ${fonts} * Update modprobe nvidia-drm option for $drm_msg.${end}${end}"; sleep 2
			fi
			echo "options nvidia_drm modeset=$drm_modset" > $drm_conf_file
			if [ "$timeout" != '' ];then
				echo $"# Modprobe $drm_msg nvidia-drm option already set."; sleep 2
			else
				echo $"# ${fonts} * Modprobe $drm_msg nvidia-drm option already set.${end}${end}"; sleep 2
			fi
		fi
	fi
}
## OPTIMUS SETUP
# let xorg_conf configure the xorg config file, then ask for prime or optimus if detected.
# Then modify as appropiate.
prime_setup(){ # DONE
	xorg_version=$(cat /var/log/Xorg.0.log| sed -En "/Build ID:/{;s/^.*\ ([1\.]?[0-9]*[.].*)-.*$/\1/p}")
	xorg_last=$(printf $xorg_version | grep -c 21)
	xorg_cfg=/etc/X11/xorg.conf.nvidia
	old_preset=$opti_preset
	old_offload=$offload
	old_render=$render
# 	if [ $opti_preset = 1 ]; then
	if [ $opti_auto_set = 1 ]; then
		[ $offload = 1 ] && render='PRIME'
	else
		prime_setup_window
	fi
	if [ "$render" = "PRIME" ]; then
		## modify xorg conf. Disable iGPU.
		## Screen 1 "nvidia" 0 0 ou Screen 0 "nvidia" 0 0
		## Inactive	"intel"
		for e in ${dev_n[@]}; do
			[[ ${vnd_id[$e]} =~ "10de" ]] && com='' || com='#'
			sed -Ei "s/^[#]?(.*Screen ${e}.*$)/${com}\1/" $xorg_cfg
		done
		sed -Ei "s/^#(.*Inactive.*$)/\1/" $xorg_cfg
	elif [[ "$render" = "PRIME render offload"|| "$render" = "NONE" ]]; then
		## modify xorg conf. Disable dGPU
		## Screen 0 "intel" 0 0
		## Inactive	"nvidia"
		## Option	"AllowNVIDIAGPUScreens"
		## Option	"AllowPRIMEDisplayOffloadSink" "true"
		## __NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia "$@"
		## add specific sets for xrandr to avoid tearing
		## modesettings create tearing on iGPU sync. To prevent this it's needed to workaround:
		# $ xrandr --output <output> --set "PRIME Synchronization" 0 # disabling.
		# $ xrandr --output <output> --set "PRIME Synchronization" 1 # enabling.
		echo $render
		for e in ${dev_n[@]}; do
			[[ ${vnd_id[$e]} =~ "10de" ]] && com='#' || com=''
			sed -Ei "s/^[#]?(.*Screen ${e}.*$)/${com}\1/" $xorg_cfg
		done
		sed -Ei "s/^[#]?(.*Inactive.*$)/#\1/" $xorg_cfg
		if [ "$render" = "NONE" ]; then
			sed -Ei "s/^[#]?(.*Option.*\"AllowNVIDIAGPUScreens\".*$)/#\1/" $xorg_cfg
			sed -Ei "s/^[#]?(.*Option.*\"AllowPRIMEDisplayOffloadSink\".*$)/#\1/" $xorg_cfg
		else
			sed -Ei "s/^[#]?(.*Option.*\"AllowNVIDIAGPUScreens\".*$)/\1/" $xorg_cfg
			sed -Ei "s/^[#]?(.*Option.*\"AllowPRIMEDisplayOffloadSink\".*$)/\1/" $xorg_cfg
		fi
	fi
	if [ $(chk_family) -ge 435 ]; then
		## Prime version. REVERSE PRIME since 435 and above.
		## Offload and REVERSE PRIME version since 495 and above doesn't need known specific sets.
		xrandr_conf=$(
			cat <<-CONF
				xrandr --setprovideroutputdevice modesetting NVIDIA-G0
				xrandr --auto
			CONF
		)
		gdm_conf='xrandr --setprovideroutputsource modesetting NVIDIA-G0'
	elif [[ $(chk_family) -ge 390 && $(chk_family) -lt 435 ]]; then
# 		if [ $offload = 1 ]; then
			## PRIME vesion since 390 and above.
			xrandr_conf=$(
			cat <<-CONF
				xrandr --setprovideroutputdevice modesetting NVIDIA-0
				xrandr --auto
			CONF
			)
			gdm_conf='xrandr --setprovideroutputsource modesetting NVIDIA-0'
# 		fi
	fi
	## add Arch primus_run to /usr/local/bin.
	if [ ! -e /usr/local/bin/run_offload ]; then
	cat <<-BIN>/usr/local/bin/run_offload
		#!/bin/bash
		__NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia "$@"
	BIN
	fi
	## wroten sets to dm config.
	if [ "$(dm_serv)" == "lightdm" ]; then
		## make security backup if not exist.
		[ -s /etc/lightdm/lightdm.conf.bak ] || cp -f /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak
		## change Seat /etc/lightdm/lightdm.conf
		if [ "$render" = "NONE" ]; then
			[ -e /etc/lightdm/prime_ini ] && rm -f /etc/lightdm/prime_ini
			sed -Ei "s/^.*(type=.*)$/#\1/" /etc/lightdm/lightdm.conf
			sed -Ei "s/^.*(display-setup-script)=.*$/#\1=\/etc\/lightdm\/prime_ini/" /etc/lightdm/lightdm.conf
		else
			## add conf
			cat <<-INI >/etc/lightdm/prime_ini
				#! /bin/bash

				$xrandr_conf
			INI
			chmod 755 /etc/lightdm/prime_ini
			sed -Ei "s/^.*(type)=.*$/\1=local/" /etc/lightdm/lightdm.conf
			sed -Ei "s/^.*(display-setup-script)=.*$/\1=\/etc\/lightdm\/prime_ini/" /etc/lightdm/lightdm.conf
		fi
	elif [ "$(dm_serv)" == "sddm" ]; then
		## make security backup if not exist.
		[ -s /usr/share/sddm/scripts/Xsetup.bak ] || cp -f /usr/share/sddm/scripts/Xsetup /usr/share/sddm/scripts/Xsetup.bak
		## modify conf /usr/share/sddm/scripts/Xsetup
		if [ "$render" = "NONE" ]; then
			cp -f /usr/share/sddm/scripts/Xsetup.bak /usr/share/sddm/scripts/Xsetup
		else
			cat <<-INI >/usr/share/sddm/scripts/Xsetup
				#! /usr/bin/sh

				$xrandr_conf
			INI
			chmod 755 /usr/share/sddm/scripts/Xsetup
		fi
	elif [ "$(dm_serv)" == "gdm" ]; then
		# /usr/share/gdm/greeter/autostart/optimus.desktop
		# /etc/xdg/autostart/optimus.desktop
		desktop_conf=$(cat <<-CONF
			[Desktop Entry]
			Type=Application
			Name=Optimus
			Exec=sh -c "$gdm_conf; xrandr --auto"
			NoDisplay=true
			X-GNOME-Autostart-Phase=DisplayServer
		CONF
		)
		if [ "$render" = "NONE" ]; then
			[ -e /usr/share/gdm/greeter/autostart/optimus.desktop ] && rm -f /usr/share/gdm/greeter/autostart/optimus.desktop
			[ -e /etc/xdg/autostart/optimus.desktop ] && rm -f /etc/xdg/autostart/optimus.desktop
		else
			echo "$desktop_conf" > /usr/share/gdm/greeter/autostart/optimus.desktop
			echo "$desktop_conf" > /etc/xdg/autostart/optimus.desktop
		fi
	# 	elif [ "$(dm_serv)" == "" ]; then # OTHERS DESKTOP MANAGERS.
	fi
	## write or update render, offload and opti_auto_set in user config file.
	[ $offload -ne $old_offload ] && sed -Ei "s/^(offload)=.*$/\1=$offload/" $basic_conf
	[ $opti_auto_set -ne $opti_auto_set ] && sed -Ei "s/^(opti_auto_set)=.*$/\1=$opti_auto_set/" $basic_conf
	[ "$render" != "$old_render" ] && sed -Ei "s/^(render)=.*$/\1=\"$render\"/" $basic_conf
	## if program is not launch from install process, go back section menu or exit if task bar cmd.
	[ $from_install = 0 ] && { [ $task_opt = 1 ] && exit 0 || menu_modif ;}
# 	fi
}
prime_setup_window(){ #
	#xorg_version=$(cat /var/log/Xorg.0.log| sed -En "/Build ID:/{;s/^.*\ ([1\.]?[0-9]*[.].*)-.*$/\1/p}")
	[ $(chk_family) -ge 390 ] && applicable_list+="PRIME!"
	[ $(chk_family) -ge 435 ] && applicable_list+="PRIME render offload!"
	[ $opti_preset = 0 ] && opti_set='FALSE' || opti_set='TRUE'
	[ $offload = 0 ] && offload_set='FALSE' || offload_set='TRUE'
	tip_1=$"$(
		cat <<-TIPS
			If set, GPU renderer choice will be set to PRIME by default
			You can changed this set in : > Configuration and Tools > Edit Zenvidia config.
		TIPS
	)"
	tip_2=$"$(
		cat <<-TIPS
			If set, this window wont be displayed at the next installation or update and recorded sets applicable.
			You can changed this set in : > Configuration and Tools > Edit Zenvidia config.
		TIPS
	)"
	w_text=$"$(
		cat <<-INFO
			${j}<b>PRIME Display GPU configuration</b>${end}
			${v}There a few usable method to use Nvidia GPU for applications or desktop.${end}
			${y}<u>PRIME</u>${end} : use NVIDIA dGPU as a primary renderer with iGPU off.
			${y}<u>PRIME render offload</u>${end} : use NVIDIA dGPU as renderer and iGPU as desktop default.
			${y}<u>NONE</u>${end} : use iGPU only, don't use NVIIDA dGPU (this cancel previous config too).
			${sf}
			${v}Notes${end} :
			<b>PRIME Render</b> is applicable for all version since 390 serie.
			<b>PRIME Render Offload</b> is applicable from 435 serie and X version 1.20.7

			<b>You're actually running the ${y}$xorg_version${end} Xorg version. ${j}Only applicables will be listed${end}</b>.

			${j}Notice${end} : <b>run_offload</b> script will be created during proces.
			It contains default ENV variables for <b>PRIME render offload</b>. This, is necessary to run any
			applications with dGPU render and need to be insert in desktop file or command line as below :
			> <b>[YOUR_ENV_VAR] run_offload [application]</b>

			<b>Full documentation can be found in</b> : > ${j}Help and Documentation${end} > ${j}Documentation Manual${end}
			 - Chapter 17. <i>Using the NVIDIA Driver with Optimus Laptops</i>
			 - Chapter 34. <i>Offloading Graphics Display with RandR 1.4</i>
			 - Chapter 35. <i>PRIME Render Offload</i>
			${end}
		INFO
	)"
	#--image="dialog-warning" \
	select_render_sets=$($d_yad --width=400 --borders=15 --title="Zenvidia" --window-icon="$img_zen_desktop" --wrap --center \
	--text="$w_text" --form --button=$"Abort"'!gtk-close:1' --button=$"Set"'!gtk-ok:0' --separator=';' \
	--field="":LBL '' \
	--field=$"Select the default NVIDIA dGPU behaviour"!$"Select in the list.":CB "${applicable_list[*]}NONE" \
	--field="":LBL '' \
	--field=$"Set Prime instead of Offload by default"!"$tip_1":CHK "$offload_set" \
	--field=$"Set Optimus Render config auto"!"$tip_2":CHK "$opti_auto_set")
	## exit status here.
	if [ $? = 1 ]; then
		if [ $from_install = 1 ]; then
			render='NONE'; offload=0; opti_auto_set=0
		else
			[ $task_opt = 1 ] && exit 0 || menu_modif
		fi
	else
		## cut output here.
		render=$(echo $select_render_sets| cut -d';' -f2)
		offload=$( [ "$(echo $select_render_sets| cut -d';' -f4)" = "TRUE" ] && echo 1 || echo 0 ;)
		opti_auto_set=$( [ "$(echo $select_render_sets| cut -d';' -f5)" = "TRUE" ] && echo 1 || echo 0 ;)
	fi
}
xorg_conf(){
## prime setup start here.
# Is opti_preset set ?
# If opti_preset is set, ask if user wants to config prime and warn about modesetting TearFree option is not available
# until version 21.2 of Xorg. 20.14 here.
	[ -f $x_tmp ] || { x_tmp=$(mktemp --tmpdir zn_xorg.XXXX); rem_tmp+=("rm -f $x_tmp") ;}

## creation order :
## 	sec_files		x 1
## 	sec_layout		x X
## 	sec_device		x X
## 	sec_option_df	x X/1
## 	sec_screen		x X/1
	sec_files(){
		if [ $ELF_TYPE -eq 64 ]; then
			ELF=$ELF_64
		else
			ELF=''
		fi
		conf_date=$(date +%D-%T)
		cat <<-XF > $x_tmp
			## xorg conf originaly created by $(new_version) nvidia installer.
			## Edited automaticaly by Zenvidia > $conf_date

		XF
		if [ $(chk_family) -lt 430 ]; then
			cat <<-XF >> $x_tmp
			Section "Files"
			   ModulePath "$nv_root/nvidia/xorg/modules"
			   ModulePath "/usr/$master$ELF/xorg/modules"
			EndSection

			XF
		fi
	}
	sec_layout(){
		layout_screen(){
			for e in ${dev_n[@]}; do
				if [ $opti_preset = 0 ]; then
					cat <<-XF
						   Screen ${dev_n[$e]}	"Screen${dev_n[$e]}" 0 0
					XF
				else
					if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
						cat <<-XF
						#   Screen ${dev_n[$e]}	"Screen${dev_n[$e]}" 0 0
						XF
					else
						cat <<-XF
						   Screen ${dev_n[$e]}	"Screen${dev_n[$e]}" 0 0
						#   Inactive	"Device${dev_n[$e]}"
						XF
					fi
				fi
			done
		}
		## layout section may differ with second card (optimus).
		## main screen become nvidia's.
		if [ $opti_preset = 0 ]; then
			cat <<-XF >> $x_tmp
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"Xinerama" "0"
				#   InputDevice	"Mouse0" "CorePointer"
				EndSection

			XF
		else
			cat <<-XF >> $x_tmp
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"AllowNVIDIAGPUScreens"
				## AllowPRIMEDisplayOffloadSink is needed by Xorg 1.20.6 (435 serie)
				#   Option	"AllowPRIMEDisplayOffloadSink" "false"
				   Option	"Xinerama" "0"
				#   InputDevice	"Mouse0" "CorePointer"
				EndSection

			XF
		fi
		cat <<-XF >> $x_tmp
			Section "ServerFlags"
				# allows the server to start up even if the mouse does not work
			   AllowMouseOpenFail
			EndSection

		XF
	}
	## optional. Input Device section. Undocumented.
	sec_input(){
		cat <<-XF >> $x_tmp
			Section "InputDevice"
			## generated from default
			   Identifier	"Mouse0"
			   Driver	"mouse"
			   Option	"Protocol" "auto"
			   Option	"Device" "/dev/input/mice"
			   Option	"Emulate3Buttons" "no"
			   Option	"ZAxisMapping" "4 5"
			EndSection
		XF
	}
	## optional. optimus primay gpu set.
	sec_output(){
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			cat <<-XF >> $x_tmp
				Section "OutputClass"
					Identifier	"Screen${dev_n[$e]}"
					Device	"Device${dev_n[$e]}"
					Driver	"nvidia"
					MatchDriver	"nvidia"
				EndSection
			XF
		fi
	}
	sec_device(){
			pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			cat <<-XF >> $x_tmp
				Section "Device"
				   Identifier	"Device${dev_n[$e]}"
				   Driver	"nvidia"
				   VendorName	"${vnd[$e]}"
				   BusID	"PCI:$pci_slot"
			XF
			else
				if [ $opti_preset = 1 ]; then
					pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
					cat <<-XF >> $x_tmp
						Section "Device"
						   Identifier	"Device${dev_n[$e]}"
						   Driver	"modesetting"
						   VendorName	"${vnd[$e]}"
						   BusID	"PCI:$pci_slot"
						## modesetting Tear Free is available starting xorg version 21.2.
						#   Option	"TearFree" "true"
						   Option	"SWcursor" "false"
						#   Option	"kmsdev" "/dev/dri/card0"
							Option	"ShadowFB" "true"
							Option	"DoubleShadow" "false"
						   Option	"AccelMethod" "glamor"
							Option	"PageFlip" "false"
						#   Option	"ZaphodHeads" "LVDS,VGA-0"
					XF
				fi
			fi
	}
	sec_option_df(){
	## compute X screen DPI ex : (1080x25.4)/286. From Nvidia Doc formula.
		if [ $d_xdpy ]; then
			w_pix=$(printf "$x_pixel"| cut -d';' -f1)
			h_pix=$(printf "$x_pixel"| cut -d';' -f2)
			w_mil=$(printf "$x_milli"| cut -d';' -f1)
			h_mil=$(printf "$x_milli"| cut -d';' -f2)
			## formule
			dpi_w=$(echo "($w_pix*25.4+$w_mil-1)/$w_mil"| bc -l| sed -n "s/\..*$//p")
			dpi_h=$(echo "($h_pix*25.4+$h_mil-1)/$h_mil"| bc -l| sed -n "s/\..*$//p")
			## inclusion
			x_dpi=$dpi_w" x "$dpi_h
		else
			## fallback value.
			x_dpi="96 x 96"
		fi
		## get display current def and freq
		x_plore=$(xrandr --current | grep -m1 "*")
		def=$(printf "$x_plore"| awk '{print $1}')
		freq=$(printf "$x_plore"| sed -En "s/.* ([0-9]{2,3}\.[0-9]{2})\*.*$/\1/g;p")
		freq_prim=$(printf "$freq"| cut -d. -f1)
		freq_scnd=$(printf "$freq"| cut -c 4)
		if [ $freq_scnd -gt 5 ]; then freq=$(($freq_prim+1)); else freq=$freq_prim; fi
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			if [ $opti_preset = 1 ]; then
				cat <<-XF >> $x_tmp
					   Option	"AllowEmptyInitialConfiguration"
				XF
			fi
			cat <<-XF >> $x_tmp
				#   Option	"NoLogo" "true"
				#   Option	"DPMS" "true"
				#   Option	"HardDPMS" "true"
				   Option	"UseEDID" "true"
				#   Option	"CustomEDID" "DFP-0:/tmp/edid[x].bin"
				   Option	"ProbeAllGpus" "false"
				#   Option	 "AllowExternalGpus" "true"
				#   Option	"UseDisplayDevice" "none"
				#   Option	"ConnectedMonitor" "DFP"
				#   Option	"DynamicTwinView" "false"
				#   Option	"AddARGBGLXVisuals"
				   Option	"SLI" "Off"
				#   Option	"MultiGPU" "Off"
				   Option	"BaseMosaic" "off"
				#   Option	"UseEdidDpi" "false"
				#   Option	"ColorSpace" "YCbCr444"
				#   Option	"ColorRange" "limited"
				   Option	"Stereo" "0"
				#   Option	"ForceStereoFlipping" "0"
				   Option	"RenderAccel" "true"
				   Option	"NoRenderExtension" "false"
				   Option	"AllowIndirectGLXProtocol" "true"
				#   Option	"AllowGLXWithComposite" "true"
				#   Option	"TripleBuffer" "true"
				   Option	"Coolbits" "8"
				#   Option	"UBB" "true"
				#   Option	"Overlay" "false"
				#   Option	"CIOverlay" "false"
				#   Option	"NoFlip" "true"
				#   Option	"GLShaderDiskCache" "false"
				#   Option	"SWCursor" "false"
				#   Option	"HWCursor" "false"
				#   Option	"ConnectToAcpid" "true"
				#   Option	"EnableACPIBrightnessHotkeys" "true"
				   Option	"DPI" "$x_dpi"
				   Option	"ConstantDPI" "true"
				   Option	"nvidiaXineramaInfoOrder" "DFP-0"
				   Option	"MetaModes" "${def}_${freq} +0+0"
				EndSection

			XF
		else
		## here second card option merge to Device section.
			cat <<-XF >> $x_tmp
				EndSection

			XF
		fi
	}
	sec_screen(){
		cat <<-XF >> $x_tmp
			Section "Screen"
				Identifier	"Screen${dev_n[$e]}"
				Device	"Device${dev_n[$e]}"
				Monitor	"Monitor${dev_n[$e]}"
				DefaultDepth	24
			EndSection

		XF
	}
	x_conf_dir=/etc/X11
	sec_files
	sec_layout
	for e in ${dev_n[@]}; do
		#sec_output
		sec_device
		sec_option_df
		sec_screen
	done
# 	install -bm644 $x_tmp $x_conf_dir/xorg.conf.nvidia
# 	ln -sfr $x_conf_dir/xorg.conf.nvidia $x_conf_dir/xorg.conf
}
fix_profiles_rc(){
	## If nvidia profile doesn't exist in user nv dir, create.
	## Then, create an empty user profile alongside the nvidia copy
	## in nvidia-application-profiles-rc.d/user-application-profiles-rc
	## If profile exist, convert to fixed in user nv dir
	## NOTE : some lines can't be convert because they are not formated like others and have to be manualy add in user-rc,
	## WARNING : some are really faulty, don't add them.
	create_rules(){
		echo -e "$headers" > $fixed_rc
		echo -e "  \"rules\": [" >> $fixed_rc
		## extract rules patterns "pattern" "profile"
		cat $version_rc | sed -n "/^.*\"rules\" : \[.*$/,/^    \].*$/p"| \
		sed -En "s/.*(\{) (\"pattern\"[ ]?: \".*\",).*(\"profile.*\") (\},).*/${tab}  \1\n${tab}   \2\n${tab}   \3\n${tab}  \4/p" >> $fixed_rc
		## extract rules patterns "pattern" "feature" "matches" "profile"
		cat $version_rc | sed -n "/^.*\"rules\" : \[.*$/,/^    \].*$/p"| \
		sed -En "s/.*(\{) (\"pattern\"[ ]?: \{) (\"feature.*\",).*(\"matches.*\") (\},).*(\"profile.*\") (\}[,]?).*/\
${tab}  \1\n${tab}   \2\n${tab}    \3\n${tab}    \4\n${tab}   \5\n${tab}   \6\n${tab}  \7/p" >> $fixed_rc
		echo -e "  ]," >> $fixed_rc
	}
	create_profiles(){
		## extract profiles patterns and add "key" "value" to each xml sections.
		cat $version_rc | sed -n "/^.*\"profiles\" : \[.*$/,/^.*\],.*$/{;s/    /  /g;p}"| \
		sed -En "s/.*(\"settings\"[ ]?: \[) (\".*\",) (.*) \].*/\
${tab}  \1\n${tab}${tab}\{\n${tab}${tab} \"key\": \2\n${tab}${tab} \"value\": \3\n${tab}${tab}\}\n${tab}  \]/i;s/\],/\]/g;p" >> $fixed_rc
		echo -e "}" >> $fixed_rc
	}
	nv_user_dir=/home/$(def_user)/.nv
	version_rc=$install_dir/share/nvidia/nvidia-application-profiles-$(new_version)-rc
	fixed_rc=$nv_user_dir/nvidia-application-profiles-rc
	[ -d $nv_user_dir/nvidia-application-profiles-rc.d ] || {
		mkdir -p $nv_user_dir/nvidia-application-profiles-rc.d
		touch $nv_user_dir/nvidia-application-profiles-rc.d/user-application-profiles-rc
	}
	headers=$( cat <<-HEAD
		# Application profiles originaly created by Zenvidia from
		# Nvidia profiles rc version $(new_version) - $(date)
		# Be aware that some rules are not filtered because their formats differ from default.
		{
	HEAD
	)
	local tab='    '
	create_rules
	create_profiles
}
## ### AFTER INSTALL ###
clean_old_version(){ # post install part. #
	y_text=$"Cleaning old ${j}$(old_version)${end} source and DKMS tree"
	pulse=1; log=0; hold=0 ; hide_txt=0; [ $hold = 1 ] && win_log_options
	# syntax: { timeout=xx ;{ [script] }& eval lpid=$!; y_pulse; } | win_yad_progress
	{	timeout=30
	{	unset drv_srctimeout=30
		dkms_clean(){
			$p_dkms remove -m nvidia/$(old_version) --all
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
				rm -rf /var/lib/dkms/$rep_clean/$(old_version)
			fi
		}
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
		fi
		for rep_clean in ${drv_src[*]}; do
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
				echo $"# Cleaning $rep_clean $(old_version) DKMS tree"; sleep 2
				dkms_clean
			fi
			if [ -d /usr/src/$rep_clean-$(old_version) ]; then
				echo $"# Cleaning $rep_clean $(old_version) source tree"; sleep 2
				rm -rf /usr/src/$rep_clean-$(old_version)
			fi
		done
		}& eval lpid=$! ; y_pulse ;} | win_yad_progress
}
POST_INSTALL(){ # PROGRESS : TODO optimus section.
	echo "# "
	echo $"# ${v}${j}($n%)${end} - ${mf}Post install routines${end}${end}"; sleep 2
	echo $"# ${v}${j}($n%)${end} - Create XORG config file for Nvidia device${end}"; sleep 2
	xorg_conf # 8
	n=$[ $n+2 ]; echo "$n" # 8
	echo $"# ${v}${j}($n%)${end} - Librairies sub routines${end}"; sleep 2
	echo $"# ${j}($n%)${end}${ge}${sf} * Linking $nv_root libs to system${end}${end}"; sleep 2
	n=$[ $n+2 ]; echo "$n" # 9
	## set old_version and new_version function in the first place for loop,
	## the modinfo calculation slow down the process to much.
	local old_lib_version=$(old_version)
	local new_lib_version=$(new_version)
	# libnvidia-wfb.so is broken with old version, need to be replace with xorg server libwfb.so. If exist in nvidia's dirs.
	if [ $(chk_family) -lt 418 ]; then
		## 418 and above don't need nvidia libwfb.so to be replace anymore
		if [ -e $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so ]; then
			mv -f $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so.orig
			ln -sf /usr/$master$ELF_64/xorg/modules/libwfb.so $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so
			report_log+=($"\t\t\t${gB} libwfb\t\t${end}> ${y}link to system${end}.\n")
		fi
	fi
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/install-$new_version.log; fi
	echo $"# ${j}($n%)${end}${ge}${sf} * Fixing broken libs and links if needed${end}${end}"; sleep 2

	## wayland-client and vulkan-producer are dedicate to wayland.
	## NOTE need to understand how wayland is detected.
	[ $wayland_link = 1 ] && wayland="wayland-client"
	## 545 serie updates.
	[ $(chk_family) -gt 396 ] && { allocator="allocator"; pkcs11="pkcs11"; openssl="pkcs11-openssl3" ;}
	[ $(chk_family) -lt 545 ] && vulkanprod="vulkan-producer"
	[ $(chk_family) -ge 545 ] && gpucomp="gpucomp"
	link_list=( "fbc" "cfg" "gtk2" "gtk3" ${pkcs11} ${openssl} ${allocator} ${vulkanprod} ${gpucomp} ${wayland} )
	## Remove previous version libs if needed.
	unset lib_x fixed_lib_log
	for lib_X in "${ELF_LIB_LIST[@]}"; do
		for old_lib in ${link_list[@]}; do
			if [ -s $install_dir/$lib_X/libnvidia-$old_lib.so.${old_lib_version} ]; then
				rm_lib=libnvidia-$old_lib.so.${old_lib_version}
				rm -f $install_dir/$lib_X/$rm_lib
				if [ -h $install_dir/$lib_X/libnvidia-$old_lib.so ]||\
				[ -h $install_dir/$lib_X/libnvidia-$old_lib.so.1 ]; then
					rm -f $install_dir/$lib_X/libnvidia-$old_lib.so*
				fi
				fixed_lib+=("$old_lib")
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ "$lib_X" =~ "64" ]]; then lib_x="x86_64"; else lib_x="i386"; fi
			fixed_lib_log+=($" cleaned ($lib_x)\n")
		fi
	done
	## send report from previous list before.
	if [ ${#fixed_lib_log[*]} -gt 0 ]; then
		for line in ${fixed_lib_log[*]}; do
			report_log+=($"\t\t\t${gB} lib fix\t\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
		done
	fi
	## fix lib64 prefix libs links if needed
	unset fixed_lib_log
	r_dir=$install_dir/$master$ELF_64
	for links in ${link_list[@]}; do
		if [ ! -e $r_dir/libnvidia-$links.so.${new_lib_version} ]; then
			cp -f $nvtmp/$extracted_release/libnvidia-$links.so.${new_lib_version} $r_dir/
		fi
		if [ ! -h $r_dir/libnvidia-$links.so.1 ]; then
			if [ -f $r_dir/libnvidia-$links.so.${new_lib_version} ]; then
				ln -sfr $r_dir/libnvidia-$links.so.1 $r_dir/libnvidia-$links.so
				ln -sfr $r_dir/libnvidia-$links.so.${new_lib_version} $r_dir/libnvidia-$links.so.1
				fixed_lib_log+=("$links,")
			fi
		fi
	done
	if [ ${#fixed_lib_log[*]} -gt 0 ]; then
		if [[ $ELF_64 =~ "64" ]]; then elf_x='(x86_64)'; else elf_x='(i386)'; fi
		fixed_lib_log+=($" links updated $elf_x")
		report_log+=($"\t\t\t${gB} link fix\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
	fi
	## symlink libvdpau_nvidia to system
	for lib_V in "${ELF_LIB_LIST[@]}"; do
		link_v=$(file -p /usr/$lib_V/vdpau/libvdpau_nvidia.so.1| grep -c "nvidia.${new_lib_version}")
		if [ $(chk_family) -lt 430 ]; then
			if [ $link_v -eq 0 ]; then
				[ -d /usr/$lib_V/vdpau ]|| mkdir -p /usr/$lib_V/vdpau
				ln -sfr /usr/$lib_V/vdpau/libvdpau_nvidia.so /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
				ln -sf $nv_root/nvidia.${new_lib_version}/$lib_V/vdpau/libvdpau_nvidia.so.${new_lib_version} \
				/usr/$lib_V/vdpau/libvdpau_nvidia.so.1
			fi
		else
			[ -h /usr/$lib_V/vdpau/libvdpau_nvidia.so.1 ]&& rm -f /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
		fi
	done
	n=$[ $n+2 ]; echo "$n" # 10
	## link now all new libraries and nvidia-application-profiles-key-documentation to system.
	if [ -d /usr/share/nvidia ]; then
		## ALERT Clean old profile version if exist before new one (done by last 535 serie version).
		test -f $install_dir/share/nvidia/nvidia-application-profiles-${old_lib_version}-rc && {
			if [ $(nv_new) -ne $(nv_old) ]; then
				rm -f $install_dir/share/nvidia/nvidia-application-profiles-${old_lib_version}-*
			fi
		}
# 		cp -Rf /usr/share/nvidia $install_dir/share/
		cp -rn /usr/share/nvidia $install_dir/share/
		rm -rf /usr/share/nvidia
		ln -sf -T $install_dir/share/nvidia /usr/share/nvidia
		## link new profile to sys. "$install_dir/share/nvidia"
		ln -sfr $install_dir/share/nvidia/nvidia-application-profiles-${new_lib_version}-key-documentation \
		$install_dir/share/nvidia/nvidia-application-profiles-key-documentation
		ln -sfr $install_dir/share/nvidia/nvidia-application-profiles-${new_lib_version}-rc \
		$install_dir/share/nvidia/nvidia-application-profiles-rc
		## copy doc to user $HOME/.nv
		cp -f $install_dir/share/nvidia/nvidia-application-profiles-${new_lib_version}-key-documentation \
		/home/$(def_user)/.nv/nvidia-application-profiles-key-documentation
		## if fix_profiles is set to 1, convert.
		if [ $fix_profiles = 1 ]; then
			echo $"# ${j}($n%)${end}${ge}${sf} * Fixing user's nvidia profiles rc file${end}${end}"; sleep 2
			n=$[ $n+2 ]; echo "$n"
			fix_profiles_rc
		fi
	fi
	## NVIDIA_GLX-1.0 changelog file is replace even if the file is older than the installed one.
	## To prevent overwwrite in case of downgrade, file copied in zenvidia doc dir, then update
	## if driver version is newer than the previous.
	if [ $(nv_new) -gt $(nv_old) ]; then
		cp -f $nvi_docs/NVIDIA_Changelog $zen_docs/
	fi
	if [ $(ls -1 /etc/ld.so.conf.d/ | grep -c "nvidia-") -eq 0 ]; then
		for lib in "${ELF_LIB_LIST[@]}"; do
			echo "/opt/nvidia/$lib" > /etc/ld.so.conf.d/nvidia-$lib.conf
		done
	fi
	echo $"# ${j}($n%)${end}${ge}${sf} * Validating new librairies (ldconfig)${end}${end}"; sleep 2
	ldconfig
	## old driver version (here optimus laptop case) doesn't create nvidia devs. ATTENTION EXPERIMENTAL
	UDEV_RULES='/etc/udev/rules.d/01-nvidia-driver.rules'
	if [ $(chk_family) -le 430 ]; then
		## partly inspired by Alexandre Freire dos Santos work in Batocera.PLUS
		## https://github.com/AlexxandreFS/Batocera.PLUS/blob/master/script/nvidia-driver-udev-rules.sh
		## thanks to him.
		echo $"# ${j}($n%)${end}${ge}${sf} * Creating udev rules for $(chk_family) serie${end}${end}"; sleep 2
		for dev in ${dev_id[@]}; do
			#SUPPORTED_GPUS_JSON=$nvi_docs'/supported-gpus/supported-gpus.json'
			#UDEV_RULES='/etc/udev/rules.d/01-nvidia-driver.rules'
			# OLD line : ACTION=="add", DEVPATH=="/bus/pci/drivers/nvidia", RUN+="$d_nv_probe -c 0 ${nv_mod_opts[*]}"
			test -f ${UDEV_RULES} || touch ${UDEV_RULES}
			cat <<-UDEV > ${UDEV_RULES}
			ACTION=="add", DEVPATH=="/bus/pci/drivers/nvidia", RUN+="$d_nv_probe -c 0 -m -u"
			UDEV
		done
		n=$[ $n+2 ]; echo "$n"
	else
		test -f ${UDEV_RULES} && rm -f $UDEV_RULES
	fi
	if [ $opti_preset = 1 ]; then
		prime_setup
		## here systemctl power management.
		if [ $opti_preset = 1 ]&&[ $enable_powerd = 1 ]; then
			if [ -f $install_dir/share/doc/NVIDIA_GLX-1.0/nvidia-dbus.conf ]; then
				cp -f $install_dir/share/doc/NVIDIA_GLX-1.0/nvidia-dbus.conf /etc/dbus-1/system.d
				ln -sf $install_dir/bin/nvidia-powerd /usr/bin/nvidia-powerd
				systemctl enable nvidia-powerd.service
			fi
		fi
	fi
	## if driver version greater than 430.xx, backup xorg modules content to default libs dirs. Just in case.
	if [ $(chk_family) -ge 430 ]; then
		if [ -s $xorg_def/modules/extensions/libglxserver_nvidia.so ]; then
			mkdir -p $nv_root/nvidia.${new_lib_version}/xorg/modules/{extensions,drivers}
			cp -rf $xorg_def/modules/extensions/libglxserver_* $nv_root/nvidia.${new_lib_version}/xorg/modules/extensions/
			cp -f $xorg_def/modules/drivers/nvidia_drv.so $nv_root/nvidia.${new_lib_version}/xorg/modules/drivers/
		fi
	fi
	if [[ $pass -eq 0 ]]; then
		## enable nvidia-persistenced if needed.
		nv_persistenced
		n=$[ $n+2 ]; echo "$n" # 11
		echo $"# ${v}${j}($n%)${end} - Blacklisting and other routines${end}"; sleep 1
		echo $"# ${j}($n%)${end}${ge}${sf} * Blacklist and GRUB conf update if needed${end}${end}"; sleep 2
		blacklist_and_grub_set
		n=$[ $n+2 ]; echo "$n" # 12
		## clean old install dir
		if [ $(nv_new) -ne $(nv_old) ]; then
			if [ -d $nv_root/nvidia.${new_lib_version} ]; then
				if [ -d $nv_root/nvidia.${old_lib_version} ]; then
					echo $"# ${v}${j}($n%)${end} - Cleaning old ${old_lib_version} source and DKMS tree if needed.${end}"; sleep 2
					rm -rf $nv_root/nvidia.${old_lib_version}
					report_log+=($"\t\t\t${gB} old version\t\t${end}> ${y}${old_lib_version} directory cleaned${end}.\n")
					clean_old_version
					report_log+=($"\t\t\t${gB} old source\t\t${end}> ${y}All ${old_lib_version} version cleaned${end}.\n")
					n=$[ $n+2 ]; echo "$n" # 14
				fi
			fi
		fi
	fi
}

## COMPIL & COMPIL CONF TOOLS ###
## check for patch in new version.
nv_build_options(){
	## nvidia build evolve in time, there need to set different options
	## along side versions.
	# define driver file locations
	nv_xorg_dir=$nv_root/nvidia.$(new_version)/xorg
	xorg_def=/usr/$master$ELF_64/xorg
# 	kernel_path=/lib/modules/$KERNEL/$(module_dest_location)
	no_check='--no-check-for-alternate-installs'
	no_net='-N'
	[ $use_indirect = 0 ]|| force_glvnd='--force-libglx-indirect'
	[ $use_glvnd = 0 ]|| add_glvnd='--install-libglvnd'
	## since 515 series, open drivers are available. Default is none.
	extract_open=0
	ask_open_build=0
	[ $(chk_family) -ge 260 ] && {
		compat32='--compat32-libdir='$master$ELF_32
		compat64='--opengl-libdir='$master$ELF_64
		gl_headers='--opengl-headers' ;}
	[ $(chk_family) -ge 390 ] && no_net=''
	[ $(chk_family) -ge 410 ] && gl_headers=''
	[ $(chk_family) -ge 430 ] && nv_xorg_dir=$xorg_def
	[ $(chk_family) -ge 430 ] && wine_special='--wine-prefix='$nv_root'/nvidia.'$(new_version)
	[ $(chk_family) -lt 515 ] && open_drv=0 # ensure open driver will not be checked for lower serie.
	if [ $(chk_family) -ge 515 ]; then extract_open=1; ask_open_build=1; enable_powerd=1; fi
}
nv_cmd_dkms_conf(){ #
	## check if source dir exit
	chk_dirs(){ [ -d /usr/src/$_src-$(new_version) ]||mkdir -p /usr/src/$_src-$(new_version); }
	## special IGNORE_PREEMPT_RT_PRESENCE script install.
	## add a pre install script for further kernel update through dkms.
	chk_RT(){
		if [ $is_RT -eq 1 ]; then
			if [ ! -e /usr/src/$_src-$(new_version)/nvidia.sh ]; then
				cat <<-SCP > /usr/src/$_src-$(new_version)/nvidia.sh
				#! /bin/bash

				if [ \$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$(uname -r)) -gt 0 ]; then
					export IGNORE_PREEMPT_RT_PRESENCE=1
				fi
				SCP
				chown root:root /usr/src/$_src-$(new_version)/nvidia.sh
				chmod 744 /usr/src/$_src-$(new_version)/nvidia.sh
			fi
		fi
	}
	# Create DKMS conf
	echo $"# ${v}${j}($n%)${end} - Create DKMS conf file...${end}"; sleep 1
	## loop between open and private.
	if [ $(chk_family) -le 355 ]; then
		_src='nvidia'
		chk_dirs
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' KERNEL_UNAME=\${kernelver} modules"
		CLEAN="'make' clean"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"
		BUILT_MODULE_NAME[1]="\${PACKAGE_NAME}-uvm"
		BUILT_MODULE_LOCATION[1]="uvm/"
		DEST_MODULE_LOCATION[1]="/$(module_dest_location)"
		EOT
	fi
	if [ $(chk_family) -lt 515 ]; then
		_src='nvidia'
		chk_dirs
		## dkms config part.
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' IGNORE_CC_MISMATCH='$gcc_mismatch' KERNEL_UNAME=\${kernelver} modules"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

		EOT
		o=1
		mods_list+=( "uvm" )
		mods_list+=( "modeset" )
		mods_list+=( "drm" )
		for mods in ${mods_list[@]}; do
			cat <<-EOT >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
			DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"
			EOT
			((o++))
		done
	fi
	## test if version support open driver version.
	if [ $(chk_family) -ge 515 ]; then
		unset drv_src
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
			AUTOINSTALL='AUTOINSTALL="yes"'
		fi
		for _src in ${drv_src[@]}; do
			chk_dirs
			chk_RT
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL=''; else AUTOINSTALL='AUTOINSTALL="yes"'; fi
				else
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL='AUTOINSTALL="yes"'; else AUTOINSTALL=''; fi
				fi
			fi
			unset mods_list
			if [ $is_RT -eq 1 ]; then
				PRE_BUILD='PRE_BUILD="nvidia.sh"'
			fi
			cat <<-EOT > /usr/src/$_src-$(new_version)/dkms.conf
			PACKAGE_NAME="nvidia"
			PACKAGE_VERSION="$(new_version)"
			$PRE_BUILD
			$AUTOINSTALL
			MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' \\
			IGNORE_CC_MISMATCH='$gcc_mismatch' \\
			KERNEL_UNAME=\${kernelver} modules $POST_BUILD"

			BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
			DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

			EOT
			o=1
			mods_list+=( "uvm" )
			mods_list+=( "modeset" )
			mods_list+=( "drm" )
			for mods in ${mods_list[@]}; do
				cat <<-EOT >> /usr/src/$_src-$(new_version)/dkms.conf
				BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
				DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"

				EOT
				((o++))
			done
		done
	fi
}
nv_dkms_mok_key(){ #
	## something can go wrong during module signing, need to figure out.
	# 	/lib/modules/6.1.10-100.fc36.x86_64/build/scripts/sign-file sha512 /var/lib/dkms/mok.key /var/lib/dkms/mok.pub /var/lib/dkms/nvidia/390.157/build/nvidia.ko
	# 	strip -g /var/lib/dkms/nvidia/390.157/build/nvidia.ko

	## for an unknown reason (at least not found) it happens that DKMS MOK keys are not generated.
	## and prevent DKMS compilation to succeed. Then, if not found we're create new self-signed ones.
	mok_signing_key="/var/lib/dkms/mok.key"
	mok_certificate="/var/lib/dkms/mok.pub"
	## this part is more or less taken from dkms script. Thankfully.
	if [ ! "$mok_signing_key" ] || [ ! "${mok_certificate}" ]; then
		echo $"# ${v}${j}($n%)${end} - DKMS MOK key/certificate are missing, generating new one for modules signin process.${end}"
		$d_ssl req -new -x509 -nodes -days 36500 -subj "/CN=DKMS module signing key" \
		-newkey rsa:2048 -keyout "$mok_signing_key" \
		-outform DER -out "$mok_certificate" &>/dev/null
		if [ ! -f "$mok_signing_key" ]; then
			echo $"# ${r}${j}($n%)${end} - MOK $mok_signing_key key not found and/or can't be generated, modules won't be signed${end}"
			## send ERROR if mok gen fail and abort.
			warn_log=$"$( cat <<-ERROR
				${r}MODULES SIGNATURE ERROR${end}.
				$(new_version) compilation can't be done successfully.

				$mok_signing_key and $mok_certificate can't be found
				and attempt to create new ones failed.

				Very sorry about that.
			ERROR
			)"
			warn_image='zen-error'
			qst=0; ok_lbl='' ; cancel_lbl=$"Abort"'!zen-close' ; kill_yad=1
			win_yad_warns
		fi
	fi
}
build_dkms(){ #
	## back_previous driver in case of FAILURE
	back_old_driver
	## test and fix mok keys if needed.
 	nv_dkms_mok_key
	unset drv_src
	## all script here is inserted in xterm for better display of process.
	## known bug : it appears on unknown reason that DKMS script do not install modules.
	## exploring some solutions, but not sure of them.
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	show_dkms=' (dkms)'
	[ -f $tmp_b ] && echo -e "show_dkms=' (dkms)'" >> $tmp_b
		mod_move(){
			## if modules detected in dkms version tree, move.
			if [ -f nvidia.*[ko\|ko.xz] ]; then
				echo -e $"#${j} ${r}ERROR${end} : No $_dkms ${j}$(new_version)${end} modules found in kernel path $kernel_path.${end}"
				sleep 2
				echo -e "# "
				echo -e $"#${v} Workaround : Copying ${y}$_dkms${end} modules in $kernel_path from DKMS repository.${end}"
				#echo -e "# moving"
				echo -e $"# ${ge}* Compressing $_dkms modules if needed."
# 				test $is_RT -eq 0 ||
				{ ## get compression suffix and act as necessary
				mod_suffix=".ko"
				grep -q '\.gz:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && compressed_type=".gz"
				grep -q '\.xz:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && compressed_type=".xz"
				grep -q '\.zst:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && compressed_type=".zst"
				mod_suffix="$mod_suffix$compressed_type"
				if [ "$compressed_type" = ".gz" ]; then
					gzip -9f *
				elif [ "$compressed_type" = ".xz" ]; then
					xz -f -T$proc *
				elif [ "$compressed_type" = ".zst" ]; then
					zstd -q -f -T0 -20 -p$proc --ultra *
				fi
				} | \
				while read -r line; do echo $"#${ge}${sf} ${line}${end}${end}"; done
				cp -vf nvidia$mod_suffix $kernel_path/nvidia$mod_suffix
				if [[ -s nvidia-uvm$mod_suffix ]]; then cp -vf nvidia-uvm$mod_suffix $kernel_path/nvidia-uvm$mod_suffix; fi
				if [[ -s uvm/nvidia-uvm$mod_suffix ]]; then cp -vf uvm/nvidia-uvm$mod_suffix $kernel_path/nvidia-uvm$mod_suffix; fi
				if [[ -s nvidia-modeset$mod_suffix ]]; then cp -vf nvidia-modeset$mod_suffix $kernel_path/nvidia-modeset$mod_suffix; fi
				if [[ -s nvidia-drm$mod_suffix ]]; then cp -vf nvidia-drm$mod_suffix $kernel_path/nvidia-drm$mod_suffix; fi

				if [[ -s $kernel_path/nvidia.*[ko\|ko.xz] ]]; then
					echo -e "# ${ge}* Exec $KERNEL modules depmod"
					sleep 2
					progress_msg(){ echo $" * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
					progress /usr/sbin/depmod -an $KERNEL | \
					while read line; do echo -e $"# ${ge}${sf}${line}${end}${end}"; done
					$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
					pass=$?
				else
					pass=1
				fi
				if [ $pass = 0 ]; then
					vermagic=$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\|ko.xz]| awk '{print $1}')
					echo -e $"# ${y}* All Clear modules loaded ($(new_version) modules moved from dkms dir)${end}."
					echo -e "pass=$pass" >> $tmp_b
				else
					echo -e $"# ${j}* --- ${r}ERROR${end} ---  Driver not found in path --- ${end}"
					echo -e "pass=1" >> $tmp_b
					echo -e $"# ${j}* You can try ${y}Update drivers or modules</b> -> </b>Update driver only (dkms/force)${end} as workaround install${end}"
					echo -e "# "
					with_error=$" - ${r} (ERROR $_dkms, safe modules not copied)${end}"
				fi
			else
				echo -e $"#${r} * --- ${r}ERROR${end} ---  Driver not found in path ---- ${end}"
				echo -e "pass=1" >> $tmp_b
				echo -e $"# ${j}* You can try ${y}Update drivers or modules</b> -> </b>Update driver only (dkms/force)${end} as workaround install${end}"
				echo -e "# "
				with_error=$" - ${r}(ERROR $_dkms, no safe modules found)${end}"
			fi
		}
		mod_check(){
		## when previous driver is higher than in install one's, dkms, even if build and install return succes, doesn't install
		## the drivers. Thus, we install those driver manually with cp.
			if [ -d /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module ]; then
				pushd /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module
				echo -e $"# ${y}* Checking $(new_version) in DKMS $KERNEL path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				mod_move
				popd
			elif [ -d /var/lib/dkms/$_dkms/$(new_version)/build ]; then
				pushd /var/lib/dkms/$_dkms/$(new_version)/build
				echo -e $"# ${y}* Checking $(new_version) in DKMS $KERNEL build path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				mod_move
				popd
			else
				echo -e $"# ${j}* --- ${r}ERROR${end} --- No $_dkms modules found in DKMS build path${end}" #7
				echo $(($n+$o)); o=$(($n+$o))
				echo -e $"# ${r}* You can try ${y}Update Driver${end} menu > ${y}Update from source${end} as workaround install${end}"
				echo -e "# "
				with_error=$" - ${r}(ERROR $_dkms, no modules found)${end}"
			fi
			if [ $pass = 1 ]; then restore__driver "old_kernel"; fi
		}
		remove_add(){
			# ATTENTION Remove driver tree only ? or remove all ?
			remove_seq(){
				#$headings
				echo -e $"#${v} Removing previous ${j}$(old_version)${end} ${y}$_dkms${end} DKMS modules from DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				#echo -e "# remove $_dkms"
				if [ $(nv_old) -gt $(nv_new) ]; then
					#echo -e "# remove seq all"
					$p_dkms remove -m $_dkms/$(old_version) --all | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
				else
					#echo -e "# remove seq kernel"
					$p_dkms remove -m $_dkms/$(old_version) -k $KERNEL | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
				fi
				sleep 2
			}
			add_seq(){
				echo -e $"#${v} Add ${j}$(new_version)${end} ${y}$_dkms${end} modules to DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				#echo -e "# add $_dkms"
				$p_dkms add -m $_dkms/$(new_version) -k $KERNEL | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
			}
			## remove previous known and unknown version if any before installing new one.
			if [ $(nv_old) -gt 0 ] && [ $(nv_old) -ne $(nv_new) ]; then
					#echo -e "# remove seq 1"
					remove_seq
			else
			## if not :
			## is the modules version present in dkms tree ?
				if [ "$(old_inst)" ] && [ $(old_inst) -gt 0 ]; then
					## check its status.
					if [[ $(old_inst) -ne $(nv_new) ]]; then
						if [ $($p_dkms status -m $_dkms/$mod_installed -k $KERNEL| grep -E -c "built|installed") -gt 0 ]; then
							# if build or installed, and not same as new one, check status ans 'remove' it.
							remove_seq
						else
							## if not in the dkms tree, just remove them, and make a depmod to clear things.
								echo -e $"#${ge}* Removing out of DKMS tree $mod_installed $_dkms from kernel modules path.${end}"
								echo $(($n+$o)); o=$(($n+$o)) #3
								sleep 2
								rm -f $kernel_path/*
								echo -e $"# ${ge}* Executing clean depmod before next step.${end}"
								sleep 2
								progress_msg(){ echo $" * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
								progress /usr/sbin/depmod -an $KERNEL | \
								while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
								echo -e $"# ${ge}* Done.${end}"
								sleep 2
						fi
					fi
				else
					echo -e $"# ${ge}* No previous driver found. Installing $(new_version) $_dkms.${end}"
					echo $(($n+$o)); o=$(($n+$o)) #3
					sleep 2
				fi
			fi
			if [ $($p_dkms status -m $_dkms/$(new_version) -k $KERNEL| grep -E -c "added|built|installed") -eq 0 ]; then
				add_seq
			fi
		}
		build_seq(){
			if [ "$(old_version)" ]; then
				if [  $(nv_old) -gt $(nv_new) ]; then force='--force'; fi
			fi
			build_seq_1(){
				echo -e $"#${v} Building ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				#echo -e "# build $_dkms"
				if [ -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module/nvidia.*[ko\|ko.xz] ]; then
					echo -e $"# ${y}* All Clear for $(new_version) $_dkms already build.${end}"
					echo -e "exec_mod_tool=1" >> $tmp_b
				else
					$p_dkms build -m $_dkms/$(new_version) -k $KERNEL $force 2>&1 | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
					echo -e $"# ${y}* All Clear for $(new_version) $_dkms is build.${end}"
				fi
				echo -e "# ${y} ---  $_dkms script ended  --- ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #6
				sleep 2
			}
			build_seq_2(){
				echo -e $"#${v} Build and Install ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				#echo -e "# install classic $_dkms"
				$p_dkms install -m $_dkms/$(new_version) -k $KERNEL $force 2>&1 | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
				$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
				pass=$?
				echo -e "pass=$pass" >> $tmp_b
				echo -e $"#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} modules in $kernel_path ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #6
				if [ $pass = 0 ]; then
					echo -e $"# ${ge}* Check validated (pass=$pass)${end}"
				else
					echo -e $"# ${ge}* Check unvalidated (pass=$pass)${end}"
				fi
				sleep 2
				if [ $pass = 1 ]; then
					mod_check
				else
					vermagic=$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\|ko.xz]| awk '{print $1}')
					echo -e $"# ${y}* All Clear for $(new_version) $_dkms in $KERNEL kernel.${end}"
					echo $(($n+$o)); o=$(($n+$o)) #7
					sleep 2
				fi
				echo -e $"# ${y} ---  $_dkms script ended  --- ${end}"
			}
			if [[ $_dkms =~ ^open ]]; then
				if [ $use_open = 0 ]; then
					build_seq_1
				else
					build_seq_2
				fi
			elif [[ $_dkms =~ ^nvidia ]]; then
				if [ $open_drv = 1 ]; then
					if [ $use_open = 0 ]; then
						build_seq_2
					else
						build_seq_1
					fi
				else
					build_seq_2
				fi
			fi
		}
		post_treatment(){
			echo -e "#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} build log presence${end}"
			echo $(($n+$o)); o=$(($n+$o))
			if [ -s /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log ]; then
				test -d $nvlog/dkms/$_dkms/ || mkdir -p $nvlog/dkms/$_dkms/
				cp -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log $nvlog/dkms/$_dkms/
				#echo -e "# copy log"
				make_log_file=$nvlog/dkms/$_dkms/make.log
				echo -e "make_log_file=$make_log_file" >> $tmp_b
				#echo -e "error_log=0" >> $tmp_b
				echo -e $"# ${ge}* $_dkms $(new_version) log found.${end}"
				echo -e $"# ${ge}* $_dkms make log copied to $make_log_file.${end}"
			else
				echo -e $"# ${ge}* No $(new_version) $_dkms build log found.${end}"
				if [ -f /var/lib/dkms/$_dkms/$(new_version)/build/make.log ]; then
					echo -e $"# ${ge}* $(new_version) ${r}FAILURE log found${end}.${end}"
					make_log_file=/var/lib/dkms/$_dkms/$(new_version)/build/make.log
					echo -e "make_log_file=/var/lib/dkms/$_dkms/$(new_version)/build/make.log" >> $tmp_b
					#echo -e "error_log=1" >> $tmp_b
					echo -e "pass=1" >> $tmp_b
				fi
			fi
			if [[ $_dkms =~ ^open ]]; then sleep 4; else sleep 2; fi
		}
		n=15
		o=0
		test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ]
		#set -x
		for _dkms in ${drv_src[@]} ; do
			echo -e $"#${v}${mf} Compiling ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules ${end}${end}"
			echo $(($n+$o)); o=$(($n+$o)) #1
			echo "# "
			echo -e $"#${y} ---  $_dkms script start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) #2
			sleep 2
			remove_add
			build_seq
			post_treatment
			echo -e "# "
		done
		echo -e $"#${v} Done$with_error${end}"
		echo -e "# "
		echo -e $esc_message
		$x_sleep
		echo 100
}
nv_build_dkms(){
 	if [ $log = 1 ];then
		echo -e $"# ${v}${j}($n%)${end} - Build and install DKMS modules...${end}"; sleep 1
	else
		echo -e $"# Build and install DKMS modules."; sleep 1
	fi
 	pulse=0; log=1; hold=1 ; hide_txt=1 ;[ $hold = 1 ] && win_log_options #; colors=1
 	y_text=$"Installing ${j}$(new_version)${end} driver over ${y}$KERNEL${end} kernel with DKMS"
 	{ build_dkms; } | win_yad_progress
}
build_source(){ #
	# NOTE : Since 545 serie nvidia-installer can install over a loaded driver, but ... it doesn't reallyt works.
	# kept for infos only.
	nv_installer(){
		[ $(chk_version) -ge 545 ] && {
		## nvidia_installer command line.
		# -k kernel_name, -Z disable nouveau, -z no nouveau check, -b no backup, -n no precompiled.
# 		nvidia-installer -s -z -N -K -b --no-x-check --no-check-for-alternate-installs --dkms \
		nvidia-installer -s -z -n -K -b -j12 --no-x-check --dkms --no-rpms \
		--skip-module-unload --no-distro-scripts --allow-installation-with-running-driver \
		--kernel-source-path=$kernel_src --kernel-install-path=$kernel_path \
		--tmpdir=$buildtmp --log-file-name=$driver_logfile
		# -s -z -n -K -b -j12 --no-x-check --dkms --no-rpms --skip-module-unload --no-distro-scripts --allow-installation-with-running-driver
		}
		# nvidia-installer -s -z -n -K -b -j12 --no-x-check --dkms --no-rpms --skip-module-unload --no-distro-scripts --allow-installation-with-running-driver --kernel-source-path=/usr/src/kernels/6.6.6-100.fc38.x86_64/ --kernel-install-path=/usr/lib/modules/6.6.6-100.fc38.x86_64/extra --tmpdir=/tmp --log-file-name=./logfile.txt
	}
	unset drv_src
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	[ -f $tmp_b ]&& echo -e "show_dkms=' (from source)'" > $tmp_b
	## back_previous driver in case of FAILURE
	back_old_driver
	## prepare modules signing (with dmsk mok files)
	nv_dkms_mok_key
	module_signing(){
# 		if [ -f "$(find -L $kernel_src -name "sign-file")" ]; then
		if [ -f "$(find -L $(kernel_src) -name "sign-file")" ]; then # TEST
			## list modules.
			for mod in $(ls -1 *.ko); do
				echo -e $"# ${ge}* Signing $mod ...${end}";
				sleep 1
				## find the sign-file script in kernel source
# 				$(find -L $kernel_src -name "sign-file") sha512 $mok_signing_key $mok_certificate $mod
				$(find -L $(kernel_src) -name "sign-file") sha512 $mok_signing_key $mok_certificate $mod # TEST
				## strip on uncompressed modules only
				strip -g $mod
			done
		fi
	}
	copy_mods(){
		echo -e "#${v} $seq_type ${j}$(new_version)${end} ${y}$module${end} in $install_path:${end}"; echo $(($n+$o)); o=$(($n+$o)) # 5
		sleep 2
		# /lib/modules/$KERNEL/$(module_dest_location)/
		test -d $install_path || mkdir -p $install_path
		echo -e $"# ${ge}* Compressing $module modules${end}" # 7
		{ ## get compression suffix and act as necessary
		mod_suffix=".ko"
		grep -q '\.gz:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && compressed_type=".gz"
		grep -q '\.xz:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && compressed_type=".xz"
		grep -q '\.zst:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && compressed_type=".zst"
		mod_suffix="$mod_suffix$compressed_type"
		if [ "$compressed_type" = ".gz" ]; then
			gzip -9f *
		elif [ "$compressed_type" = ".xz" ]; then
			xz -f -T$proc *
		elif [ "$compressed_type" = ".zst" ]; then
			zstd -q -f -T0 -20 -p$proc --ultra *
		fi
# 			pushd $install_path
# 			test $is_RT -eq 0 ||
# 		xz -T12 *.ko
		} | \
		while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
		echo -e $"# ${ge}* Copying $module modules in $install_path${end}"; echo $(($n+$o)); o=$(($n+$o))
			cp -f nvidia$mod_suffix $install_path/nvidia$mod_suffix
			if [[ -s nvidia-uvm$mod_suffix ]]; then cp -f nvidia-uvm$mod_suffix $install_path/nvidia-uvm$mod_suffix; fi
			if [[ -s uvm/nvidia-uvm$mod_suffix ]]; then cp -f uvm/nvidia-uvm$mod_suffix $install_path/nvidia-uvm$mod_suffix; fi
			if [[ -s nvidia-modeset$mod_suffix ]]; then cp -f nvidia-modeset$mod_suffix $install_path/nvidia-modeset$mod_suffix; fi
			if [[ -s nvidia-drm$mod_suffix ]]; then cp -f nvidia-drm$mod_suffix $install_path/nvidia-drm$mod_suffix; fi
			## compress modules.
			if [ $dep_check = 1 ]; then
				echo -e $"# ${ge}* Executing $module $KERNEL depmod${end}"
				progress_msg(){ echo $" * Exec $KERNEL modules depmod ($m sec.)"; }; m=1; do_slp=1
				progress /usr/sbin/depmod -an $KERNEL | \
				while read line; do echo -e "# ${ge}${sf}${line}${end}${end}"; done
			fi
	}
	mod_check(){
		if [ -e /usr/src/$module-$(new_version)/nvidia.ko ]; then
			echo -e $"#${y} ---  $module Compilation done  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 4
			sleep 2
			echo -e $"#${v} Signing ${j}$(new_version)${end} ${y}$module${end} modules.${end}"
			module_signing; echo $(($n+$o)); o=$(($n+$o))
			if [ $use_open -eq 1 ]; then
				if [[ $module =~ ^open ]]; then
					install_path=$kernel_path
					dep_check=1
					seq_type=$"Installing"
					copy_mods
				else
					echo -e $"#${v} Reserving: Not installing, ${j}$(new_version)${end} ${y}$module${end} is not used.${end}"; echo $(($n*2+$o)); o=$(($n*2+$o)) # 5
					install_path=/usr/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
					dep_check=0
					seq_type=$"Backup"
					copy_mods
				fi
			else
				if [[ $module =~ ^nvidia ]]; then
					install_path=$kernel_path
					dep_check=1
					seq_type=$"Installing"
					copy_mods
				else
					echo -e $"#${v} Reserving: Not installing, ${j}$(new_version)${end} ${y}$module${end} is not used.${end}"; echo $(($n*2+$o)); o=$(($n*2+$o)) # 5
					install_path=/usr/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
					dep_check=0
					seq_type=$"Backup"
					copy_mods
				fi
			fi
		else
			echo -e $"#${j} ---  ${r}ERROR${end}  ---  No modules found in source path  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 4
			with_error=" - ${r}with ERRORs${end}"
		fi
	}
	post_treatment(){
		echo -e $"#${v} Checking ${j}$(new_version)${end} ${y}$module${end} build log presence.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 8
		if [ -s /usr/src/$module-$(new_version)/make.log ]; then
			[ -d $nvlog/source/$module ]|| mkdir -p $nvlog/source/$module
			cp -f /usr/src/$module-$(new_version)/make.log $nvlog/source/$module
			make_log_file=$nvlog/source/$module/make.log
			[ -f $tmp_b ]&& echo -e "make_log_file=$make_log_file" >> $tmp_b
			echo -e $"#${ge} * $module $(new_version) log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
			echo -e $"#${ge} * $module make log copied to $make_log_file.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 10
		else
			echo -e $"#${ge} * No $(new_version) $module build log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
		fi
		if [ $dep_check = 1 ]; then
			$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
			pass=$?
		else
			pass=0
		fi
		if [ $pass = 0 ]; then
			echo -e $"#${ge} * $module control passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
		else
			echo -e $"#${ge} * $module control not passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
			echo -e $"#${j} ---  ${r}ERROR${end}  ---  No modules found in destination path  --- ${end}";
			with_error=$" - ${r}with ERRORs${end}"
		fi
		if [ $pass = 1 ]; then restore__driver "old_kernel"; fi
		[ -f $tmp_b ]&& echo -e "pass=$pass" >> $tmp_b
		if [[ $module =~ ^open ]]; then sleep 4; else sleep 2; fi
	}

	if [ $upgrade_other = 1 ]; then
# 		make_env='env KERNEL_UNAME='$KERNEL' KERNEL_SOURCES='$kernel_src
		make_env='env KERNEL_UNAME='$KERNEL' KERNEL_SOURCES='$kernel_src # TEST
	fi
	if [ $(chk_family) -lt 355 ]; then
		opts_355="cd uvm/; make -j$proc; cd ../"
	fi
	n=10
	o=0
	test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ]
	for module in ${drv_src[@]} ; do
		pushd /usr/src/$module-$(new_version)
		sleep 1
		echo -e $"# ${v}${mf} Compiling ${j}$(new_version)${end} from ${y}$module${end} modules source:${end}${end}"; echo $(($n+$o)); o=$(($n+$o))
		sleep 2
		if [ -d /usr/src/$module-$(new_version) ]; then
			echo -e $"#${y} ---  $module compilation start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 2 20
			sleep 2
			echo -e $"#${ge} Compilation $make_env.${end}" # 3 30
			$make_env make -j$proc | fmt -w 120 | \
			while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; echo "${line}" &>> make.log; done
			$opts_355
			sleep 2
			mod_check
			sleep 2
			post_treatment
		else
			echo -e $"# ${v}Source ${j}$(new_version)${end} ${y}$module${end} unaviable.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 2
			echo -e $"# ${v}Check your kernel source three.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 3
			[ -f $tmp_b ]&& echo -e "pass=1" >> $tmp_b
			with_error=" - ${r}with ERRORs${end}"
		fi
		make clean
		echo -e "# "
		popd
	done
	echo -e $"#${v} Done$with_error.${end}"
	sleep 2
	echo -e "# "
	echo -e $esc_message
	$x_sleep
	echo 100
	. $tmp_b
}
nv_cmd_make_src(){
	echo -e $"# Build & install modules from source..."; sleep 1
 	pulse=0; log=1; hold=1 ; hide_txt=1 ;[ $hold = 1 ] && win_log_options
 	y_text=$"Installing ${y}$KERNEL${end} kernel modules from ${j}$(new_version)${end} source directory"
	{ build_source; } | win_yad_progress
}
nv_cmd_install_driver(){ #
		## we need to give it a chance.
		probe_open=/etc/modprobe.d/open-NVIDIA.conf
		## prevent installer to doing think for 'upgrade an other kernel'.
		upgrade_other=0
		## check driver source presence and copy it to src dir if necessary.
		if [ ! -d /usr/src/nvidia-$(new_version) ]; then
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel /usr/src/nvidia-$(new_version)
			if [ $extract_open = 1 ]; then
				test $ask_open_build -eq 1 && nv_open_modules_set
			fi
		fi
		if [[ $($d_modinfo -F version nvidia) != $(new_version) ]]; then

			if [ $use_dkms = 1 ]; then
				if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel ]; then
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo $"# ${r}${j}($n%)${end} DKMS compilation ERROR !!${end}"; sleep 2
					fi
				fi
			fi
			if [ $use_dkms = 0 ]; then
				echo $"# ${v}${j}($n%)${end} - Nvidia MODULES compilation from source...${end}"; sleep 1
				nv_cmd_make_src
			fi
			if [ $use_open = 1 ]; then
				if [ $(chk_family) -lt 545 ]; then
					echo -e $"# ${v}Set ${y}$drv_on${end} kernel options.${end}"
					cat <<-CONF > $probe_open
						options nvidia NVreg_OpenRmEnableUnsupportedGpus=1
					CONF
				fi
			else
				[ -f $probe_open ] && rm -f $probe_open
			fi
			## backup newly compiled drivers in case of libs install error.
			mkdir -p $nvtmp/new_kernel/
			cp -f $kernel_path/nvidia* $nvtmp/new_kernel/
			## service file patch.
			dm_service_patch
		else
			[ -f $tmp_b ] && echo -e "pass=2" >> $tmp_b
		fi
}
nv_cmd_update(){ # ALERT REVISER #
	driver_logfile=$nvlog/$(new_version)-$KERNEL.log
	tmp_b=$(mktemp --tmpdir zn_vars.XXX)
	rem_tmp+=("rm -f $tmp_b")
	## check for for patch in new version.
	rt_options
	nv_build_options
	if [ $extract_open = 1 ]; then
		if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open/* /usr/src/open-nvidia-$(new_version)
		fi
	fi
	## check for open modules presence.
	test $ask_open_build -eq 1 && nv_open_modules_set
	if [ $use_dkms = 1 ]; then
		[ $from_install = 1 ] && nv_cmd_dkms_conf
		nv_build_dkms
		. $tmp_b
		make_log=$make_log_file
		if [ $pass -eq 1 ]; then
			echo -e $"# DKMS compilation ERROR !!"; sleep 2
		fi
	else
		if [ $use_dkms = 0 ]; then
			echo -e $"# Nvidia MODULES compilation from source..."; sleep 1
			nv_cmd_make_src
			. $tmp_b
			make_log=$make_log_file
		fi
	fi
	if [ $pass -eq 0 ]; then
		## rebuild initramfs in case of trouble booting.
		echo -e $"# Updating $KERNEL modules."; sleep 1
		$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
		if [ $? = 0 ] ; then
			if [ $exec_mod_tool = 1 ]; then
				echo -e $"# Exec $KERNEL modules reload "; sleep 2
				exec_mod_load
			else
# 				if [ $upgrade_other = 1 ]; then
					progress_msg(){ echo -e $"# Rebuilding $KERNEL INITRAMFS ($m sec.)"; echo "$m"; }; m=1; do_slp=1
					exec_initramfs
					[ -e $tmp_c ] && . $tmp_c
# 				else
# 					echo "# - Exec $KERNEL modules reload "; sleep 2
# 					exec_mod_load
# 				fi
			fi
		else
			echo -e $"# ERROR ! $KERNEL modules do not match $(new_version). Abort."; sleep 3; exit 0
		fi
 	fi
 	install_log_messages
 	blacklist_and_grub_set
 	## service file patch.
 	dm_service_patch
}
nv_cmd_install_libs(){ # TODO CHECK REGULARY AT DRIVER UPGRADE #
## INFOS ABOUT NVIDIA-INSTALLER OPTIONS :
#  --opengl-prefix=OPENGL-PREFIX
#      The prefix under which the OpenGL components of the NVIDIA driver will be installed; the default is:
#      '/usr'.  Only under rare circumstances should this option be used.  The Linux OpenGL ABI
#      (http://oss.sgi.com/projects/ogl-sample/ABI/) mandates this default value.
# --opengl-libdir=OPENGL-LIBDIR
#      The path relative to the OpenGL library installation prefix under which the NVIDIA OpenGL components will
#      be installed.  The default is 'lib' on 32bit systems, and 'lib64' or 'lib' on 64bit systems, depending on
#      the installed Linux distribution.  Only under very rare circumstances should this option be used.
#  --wine-prefix=WINE-PREFIX
#      The prefix under which Wine components of the NVIDIA driver will be installed.  The default is '/usr'.
#  --wine-libdir=WINE-LIBDIR
#      The path relative to the Wine installation prefix under which Wine components of the NVIDIA driver will be
#      installed.  The default is '<opengl-libdir>/nvidia/wine', where <opengl-libdir> is the path determined for
#      --opengl-libdir above.
#	-b --no-sigwinch-workaround --no-distro-scripts $no_check \	
#	--x-prefix=$xorg_dir --x-module-path=$xorg_dir/modules --opengl-prefix=$croot_all \
#	sh $run_pkg -a $quiet -z -Z --no-x-check --ui=none $unified \
#	--kernel-source-path=$kernel_src --kernel-install-path=$kernel_path  --no-abi-note \
#	sh $run_pkg -s -z -N --no-x-check \
## EXTRA INFOS
#	$nocheck --no-kernel-module --no-opengl-files --skip-module-unload \
#	--no-recursion --opengl-headers --install-libglvnd --glvnd-glx-client --force-libglx-indirect  --opengl-libdir=$master$ELF_64 \
#	--utility-prefix=$install_dir --utility-libdir=$install_dir/$master$ELF_64 \
# 	temp="--tmpdir=$buildtmp"

	## create base libs install directories
	for d in {$nv_root/$predifined_dir,$nv_root/nvidia.$(new_version)/$master$ELF_32,$nv_root/nvidia.$(new_version)/$master$ELF_64,$nv_xorg_dir}; do
		[ -d $d ] || mkdir -p $d
	done
	# nvidia-installer librairies log file
	lib_logfile=$nvlog/libinstall-$(new_version).log
	## install default libs with nvidia-installer
	echo "# "
	echo $"# ${v}${j}($n%)${end} - ${mf}Install Nvidia default librairies${end}${end}"; sleep 1

	y_text=$"Installing ${j}$(new_version)${end} librairies to $nv_root/nvidia.$(new_version)"
	pulse=1; log=1; hold=1 ; hide_txt=1 ; [ $hold = 1 ] && win_log_options
	pushd $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)
	{ timeout=120 ;{
	echo -e $"# ${j}<b>Librairies installation in background</b>${end}"
	echo -e $"# ${y}Please wait...${end}"
	$install_bin -s -z $no_net --no-x-check --no-distro-scripts \
	$nocheck --no-kernel-module --skip-module-unload --no-recursion \
	$gl_headers $add_glvnd $force_glvnd --install-compat32-libs \
	--compat32-prefix=$nv_root/nvidia.$(new_version) $compat32 $compat64 \
	--x-prefix=/usr --x-library-path=$nv_root/nvidia.$(new_version) --x-module-path=$nv_xorg_dir/modules \
	--opengl-prefix=$nv_root/nvidia.$(new_version) $wine_special --utility-prefix=$install_dir \
	$docs $profile --tmpdir=$buildtmp --log-file-name=$lib_logfile 2>&1 | fmt -w 100 | \
	while read -r line; do echo -e "# ${y}${sf}${line}${end}${end}"; done
	echo -e "# "
	echo -e $esc_message
	}& eval lpid=$!; y_pulse; } | win_yad_progress
	popd
	## report nvidia installer log message
	if [ $(cat $lib_logfile| grep -c "WARNING") -gt 0 ]; then
		if [ $(cat $lib_logfile| grep "WARNING"| grep -c "libGL.so") -gt 0 ]; then
			report_log+=($"${vB}Nvidia-installer:\t${end}${jB} no effect\t\t${end}> ${y}WARNING on missing /usr/lib(32/64)/LibGL.so link,\n\t\t\t\t\t\t    LibGL.so is already link in default nvidia's libraies directory${end}.\n")
		elif [ $(cat $lib_logfile| grep "WARNING"| grep -c "libglvnd") -gt 0 ]; then
			report_log+=($"\t\t\t${jB} no effect\t\t${end}> ${y}WARNING missing libglvnd developpement files.${end}\n")
		fi
	fi
	## control if libraries are properly installed
	ls $nv_root/nvidia.$(new_version)/$master$ELF_64/* &>/dev/null
	if [ $? -ne 0 ]||[ $(ls $nv_root/nvidia.$(new_version)/$master$ELF_64 | wc -l) -lt 40 ]; then
		warn_log=$"${v}${r}LIBS INSTALL CONTROL RETURN ERRORS.${end}.\nCheck $lib_logfile for more details.${end}"
		qst=0; kill_yad=1; warn_image='zen-warning'; cancel_lbl=$"Abort install"'!zen-close'; ok_lbl=''
		win_yad_warns
		lib_pass=1
		kill $YAD_PID
		exit 1
	else
		report_log+=($"${vB}Libraries install:\t${end}${gB} success\t\t${end}> ${y}normal install process${end}.\n")
		lib_pass=0
	fi
}

## ### INSTALL MODULE AND LIBRARIES PROCESS ###
## ### MAIN SECTION ###
## LOGS ###
install_log_messages(){ #
	## install log messages
	if [ $pass -eq 0 ]; then
		if [ "$timeout" != '' ];then
			echo $"# Modules build done."; sleep 2
		else
			echo $"# ${v}${j}($n%)${end} - Modules build done.${end}"; sleep 2
		fi
		report_log+=($"${vB}Driver build$show_dkms:\t${end}${gB} success\t\t${end}> ${y}Installation complete with no error${end}\n")
	elif [ $pass = 1 ]; then
		if [ "$timeout" != '' ];then
			echo $"# Modules build ERROR."; sleep 2
		else
			echo $"# ${r}${j}($n%)${end} - Modules build ERROR.${end}"; sleep 2
		fi
		report_log+=($"${vB}Driver build:\t\t${end}${rB} failure\t\t${end}> ${y}ERROR, 'make' exit with 'failed' state${end}\n")
		warn_log=$"$( cat <<-ERROR
			${r}MODULES BUILD RETURN ERRORS.${end}.
			$(new_version) compilation failed.
			Source make.log has been saved in <i>$make_log_file</i>.

			Do you want to read $make_log_file ?
		ERROR
		)"
		qst=1; ok_lbl=$"Yes"'!zen-ok'; cancel_lbl=$"No thanks, shits happens"'!zen-close'; kill_yad=0
		win_yad_warns
		if [ $_exit = 0 ]; then
			IFS=$(echo -en "\n\b")
			log_txt=$"${j}$(new_version)${end} compilation log text"
			log_brief=$make_log_file
			cancel_lbl=$"Exit"'!gtk-close'; ok_lbl=$"Back to main"'!zen-back'
			w_formatted=1; w_wrap=1; w_width='720'; w_height='400'; all_btn=1; colors=1
			win_yad_text "$log_brief"
			[ $_exit = 1 ] && IFS=$ifs
		fi
		[ $new_process = 0 ] && restore_broken_install
		kill $YAD_PID
		exit 1
	elif [ $pass = 2 ]; then
		if [ "$timeout" != '' ];then
			echo $"# Modules already build and present in $kernel_path."; sleep 2
		else
			echo $"# ${y}${j}($n%)${end} - Modules already build and present in $kernel_path.${end}"; sleep 2
		fi

		warn_log=$"$( cat <<-ERROR
			${r}<b>MODULES ALREADY BUILD</b>${end}.
			$(new_version) is the same as in kernel path.

			If you decide to continue anyway, consider the section
			${j}update driver${end} > ${j}update driver only${end} or
			restoring $(new_version) backup, if you experience any issue.

			What do you want to do ?
		ERROR
		)"
		qst=1; ok_lbl=$"Continue"'!zen-ok'; cancel_lbl=$"Abort installation"'!zen-close'; kill_yad=0
		win_yad_warns
		if [ $_exit = 1 ]; then
			[ $new_process = 0 ] && restore_broken_install
			kill $YAD_PID
			exit 1
		fi
	fi
	## realtime report messages.
	if [ $is_RT -eq 1 ]; then
		report_log+=($"\t\t\t${gB} kernel option\t${end}>${y} Kernel $KERNEL is REALTIME${end}.\n")
	fi
	## open driver install report messages.
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -eq 1 ]; then append=$"open driver loaded"; else append=$"close source loaded"; fi
		report_log+=($"${vB}Open Driver:\t\t${end}$gB compiled\t\t${end}>${y} $append${end}\n")
	fi
}
install_report_log(){ #
	## display final message depends of exit status.
	$d_yad --title="Zenvidia" --window-icon=$img_zen_desktop --width=500 --borders=20 --center \
	--text=$"${j}${bf}Install Report${end}${end}${v}:\n $(cat <<< ${report_log[*]})${end}\n$rep_msg" \
	--button=$"edit later"'!zen-undo:1' --button=$"edit now"'!zen-warning:0'
	log_exit=$?
	xorg_check
	if [ $log_exit = 0 ]; then
		edit_xorg_conf
	fi
}
xorg_check(){
	## prevent user xorg config overwrite.
	if [ -e /etc/X11/xorg.conf ]; then
		[ -f /etc/X11/xorg.conf.nvidia ] && is_nv=$" for Nvidia drivers" || is_nv=""
		warn_log=$"$(
			cat <<-WARN
				${y}<b>Xorg configuration file${is_nv} already exist</b>${end}

				<b>WARNING</b> : Validating will overwrite existing by a fresh one.
				<small><i>A backup of previous will be made in /etc/X11 (xorg.conf.[nvidia]~)</i></small>

				Do you want to overwrite ?
			WARN
		)"
		qst=1; ok_lbl='Overwrite!zen-ok' ; cancel_lbl='Keep!zen-close' ; kill_yad=0
		win_yad_warns
		# if yes overwrite, if no pass.
		if [ $_exit -eq 0 ]; then
			install -bm644 $x_tmp /etc/X11/xorg.conf.nvidia
			ln -sfr /etc/X11/xorg.conf.nvidia /etc/X11/xorg.conf
		fi
	fi
}
## ### INITIAL OR UPGRADE INSTALL PROCESS ### ###
INSTALL_DRIVER(){ #
	## tell script that all POST_INSTALL process came from global install. Needed in some cases.
	from_install=1
	## check for for patch in new version.
	nv_build_options
	rt_options
	## define modules to build at compil/dkms time.
	use_drm=1
	# win_yad_warns
	warn_log=$"$( cat <<-WRN
		$menu_msg
		${v}Installing driver ${j}$(new_version)${end} for hardware : ${j}$install_dev${end}${end}.
	WRN
	)"
	qst=1; ok_lbl=$"Install"'!zen-ok' ; cancel_lbl=$"Back to main"'!zen-close' ; kill_yad=0
	win_yad_warns
	if [ $_exit = 1 ]; then base_menu; fi
	# child process doesn't send back install check result, it need to be
	# set in a temp file.
	tmp_b=$(mktemp --tmpdir zn_vars.XXXX)
	# set a second temp file for old-version backup when new modules installed
	tmp_old=$(mktemp --tmpdir zn_vars.XXXX)
	rem_tmp+=("rm -f $tmp_b")
	rem_tmp+=("rm -f $tmp_old")
	# then push version var in second temp to be used as old-version var during installation.
	echo "$($d_modinfo -F version nvidia -k $KERNEL)" > $tmp_old
	if [[ -s $run_pkg ]] ; then
	y_text=$"Installing ${j}$(new_version)${end} driver version for ${y}$dev_name${end}."

	pulse=0; log=1; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{	## set start count
		YAD_PID=$(pgrep -n yad)
		n=1
		## check compatiblity files before executng anything. (4)
		echo $"# ${v}${j}($n%)${end} - ${mf}Compat check and package extraction${end}${end}"; sleep 2
		n=$[ $n+1 ] ; echo "$n"
		echo $"# ${v}${j}($n%)${end} - Checking compatibility data files${end}"; sleep 1
		# DRV is used by hardware_compat function.
		DRV=$(new_version)
		for e in ${dev_n[@]}; do
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
				$(hardware_compat)
				. $tmp_b
			fi
		done
		echo "$install_msg" ; n=$[ $n+5 ]; echo "$n"; sleep 2 # 1
		#
		## extract .run package for install processes (22)
		extract_build
		test $tmp_c && . $tmp_c
		echo "$n"
		## at install only, nvidia-installer is located in temp rep.
		install_bin="./nvidia-installer"
		echo $"# ${v}${j}($n%)${end} - Backing up old driver version, if any${end}"; sleep 2
		#
		# backup driver repository (shits happens!)
		unset report_log
		if [ -d $nv_root/nvidia.$(old_version) ]; then
			bak_version=$(old_version)
			if [[ -s $nvbackup/nvidia.$bak_version.tar$zip_ex ]]; then
				echo $"# ${y}${j}($n%)${end} - Driver already backed up. Skipped.${end}"; sleep 1
				report_log+=($"${vB}Previous version:\t${end}${gB} passed\t\t${end}> ${y}previously backed up${end}\n")
			else
				y_text=$"Backup : $bak_version backup archive creation"
				pulse=1; log=0; hold=0 ; hide_txt=0
				{ timeout=30; {
				backup_old_version; } & eval lpid=$!; y_pulse; } | win_yad_progress
# 				backup_old_version
				report_log+=($"${vB}Previous version:\t${end}${gB} success\t\t${end}> ${y}$bak_version normal backup process${end}\n")
				log=1
			fi
		else
			report_log+=($"${vB}Previous version:\t${end}${jB} warning\t\t${end}> ${y}no directory to archive.${end}\n")
		fi

		n=$[ $n+5 ] ; echo "$n" # 2 ### ?
		## temp value to n
		p=$n
		echo "# "
		echo $"# ${v}${j}($n%)${end} - ${mf}Starting install${end}${end}"; sleep 1
		#
# 		pushd $nv_root
		cd $nv_root
		# nv_cmd processes (install without X crash )
		echo $"# ${v}${j}($n%)${end} - Package compil and install${end}"; sleep 1

		## backup previous drivers in case of compilation or libs install failure.
		mkdir -p $nvtmp/old_kernel/
		cp -f $kernel_path/nvidia* $nvtmp/old_kernel/
		## ALERT REVERSE PROCESS FOR 396 SERIE AND OLDER.
		if [ $(chk_family) -gt 396 ]; then
			new_process=1
			# install driver first, then control if everything ok
			nv_cmd_install_driver
			. $tmp_b
			n=$[ $n+5 ]; echo "$n" # 3
			install_log_messages
			echo "$n"
			# then install libs.
			nv_cmd_install_libs
			inst_mod_version=$($d_modinfo -F version nvidia -k $KERNEL)
			## in case serie not yet manage by control prrocess,
			## check inst_mod_version and act if necessary.
			## NOTE : Will be removed with complete driver serie idenfication.
			$d_modinfo -F version nvidia -k $KERNEL &>/dev/null
			if [ $? -eq 1 ]; then
				echo $"# ${y}${j}($n%)${end} - Old Nvidia serie BUG - driver install lost.${end}"
				echo $"# ${y}${j}($n%)${end} - Restoringg from backup.${end}"; sleep 1
				restore__driver "new_kernel"
			fi
			## link to sys.
			ln -sfr -T $nv_root/nvidia.$(new_version) $nv_root/nvidia
		else
			new_process=0
			# Older serie remove any driver installed no matter what.
			# so, install lib first, then drivers.
			nv_cmd_install_libs
			# then install drivers
			nv_cmd_install_driver
			. $tmp_b
			n=$[ $n+5 ]; echo "$n" # 3
			install_log_messages
			echo "$n"
			inst_mod_version=$($d_modinfo -F version nvidia -k $KERNEL)
			## link to sys.
			ln -sfr -T $nv_root/nvidia.$(new_version) $nv_root/nvidia
		fi
		n=$[ $n+5 ]; echo "$n" # 4
		if [ $pass -eq 0 ]; then
			echo $"# ${v}${j}($n%)${end} - ${mf}Linking ${y}$(new_version)${end} directory to the system.${end}${end}"; sleep 1
			## link to sys.
			ln -sfr -T $nv_root/nvidia.$(new_version) $nv_root/nvidia
			n=$[ $n+1 ]; echo "$n"
			echo $"# ${v}${j}($n%)${end} - ${mf}Re-create ${j}$KERNEL${end} initramfs.${end}${end}"; sleep 1
			## rebuild initramfs or modprobe reload.
			if [ $exec_mod_tool = 1 ]; then
				echo -e $"# Exec $KERNEL modules reload "; sleep 2
				exec_mod_load
			else
# 				progress_msg(){ echo $"# ${ge}${sf} * ($m%) Exec $KERNEL modules init/reload${end}${end}"; echo "$m"; }
				progress_msg(){ echo $"# ${ge}${sf} * ($m%) Exec $KERNEL modules init/reload${end}${end}"; }
				m=0; do_slp=1; exec_initramfs
			fi
			n=$[ $n+20]; echo "$n"
		fi
		cd $nvtmp
		if [[ -s $nvtmp/$extracted_release/nvidia-installer ]]; then
			echo $"# ${v}${j}($n%)${end} - Backup new Nvidia-Installer to $nvdir${end}"; sleep 2
			#
			cp -f NVIDIA-Linux-$ARCH-$(new_version)/nvidia-installer $nvdir
			n=$[ $n+1 ]; echo "$n" # 5
		fi
		echo $"# ${v}${j}($n%)${end} - Update new driver version file${end}"; sleep 2
		#
		printf "$(new_version)" > $nvdir/version.txt
		printf "$(new_version)" > $(user_CF_DIR)/version.txt
		n=$[ $n+1 ]; echo "$n" # 6
		# Backup installed binary from release to release dir archive
		if [ ! -f $nvdl/nv-update-$(new_version) ] ; then
			cp -f $run_pkg $nvdl/nv-update-$(new_version)
			if [[ -f $nvdl/nv-update-$(new_version) ]] ; then
				echo $"# ${v}${j}($n%)${end} - Driver $(new_version) release package backup success${end}"; sleep 2
			else
				echo $"# ${v}${j}($n%)${end} - Driver ${j}$(new_version)${end} release backup mistake. Not fatal.${end}"; sleep 2
			fi
		else
			echo $"# ${v}${j}($n%)${end} - nv-update-$(new_version) already present in path, skip${end}"; sleep 2
		fi
		n=$[ $n+2 ]; echo "$n" # 7
		# create xorg temp here to take care of further needs in process.
		x_tmp=$(mktemp --tmpdir zn_xorg.XXXX)
		rem_tmp+=("rm -f $x_tmp")
		POST_INSTALL
		echo "99"; sleep 2
		echo "100"
		## Install report display.
		if [[ $pass -eq 0 || $pass -eq 2 && $lib_pass -eq 0 ]]; then
			if [ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| grep -c ".*") -gt 40 ]|| \
			[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| grep -c ".*") -gt 40 ]; then
				rep_msg=$"$( cat <<-RPT
				${v}<b><big><i>Congratulations !</i></big></b>${end}
				<b>${j}$(new_version)${end} ${v}driver is now succefully installed${end}</b>.

				${v}You may now configure your ${j}xorg.conf${end} file to fit with your current default display before restarting
				your computer with the new installed drivers.
				You may also do it later if you like, but it's not really recommanded.

				What do you want to do ?${end}
				RPT
				)"
				install_report_log
			fi
		else
			warn_log=$"$(
			cat <<-RPT
				${r}<b><big>Unexpected ERROR.</big></b>${end}
				${j}<b>$inst_mod_version isn't $(new_version)</b>${end}.
				Really weird. ${jB}O_o${end} !
				Some unknown bug pops up during driver installation.
				Or developper fucked out something ?
				Can't tell.
			RPT
			)"
			qst=0; kill_yad=1; warn_image='zen-error'; cancel_lbl=$"Abort"'!zen-close'; ok_lbl=''
			win_yad_warns
		fi
		} | win_yad_progress
		. $tmp_b
		trap "${rem_tmp[*]}" EXIT
		if [ $pass -eq 0 ]; then
			if [ $(lsmod | grep -c "nouveau") = 0 ]; then
				warn_log_title=$"${j}<big>$(new_version) installed ended</big>${end}"
				restart_dm_warn
			else
			## nouveau is still loaded, reboot to take effect.
				warn_log=$"$(
				cat <<-RPT
					${y}<b><big>Driver installation complete</big></b>${end}

					Because <b>Nouveau driver</b> is still loaded you need
					to reboot the system for change to take effects.

				RPT
				)"
				qst=0; kill_yad=0; warn_image='zen-warning'; cancel_lbl=$"Got it"'!zen-close'; ok_lbl=''
				win_yad_warns
			fi
		fi
		base_menu
	else
		error_log=$"$(
			cat <<-RPT
				${rB}${bf}Ouch!${end}${end}
				${jB}No proper Nvidia package found.${end}

			RPT
			)"
		HTML=$"$(
			cat <<-TXT
				<!DOCTYPE html>
				<html>
				<head>
				<style>
					html { border: 3px solid #F53000; border-radius: 5px; }
					body { background:#3F3E3E; color: ${main}; height=120px; }
					a { color: ${log_msg}; text-decoration: none; }
					a:hover { font-weight:bold;}
				</style>
				</head>
				<body>
				You need to download the right package manually for your ${dev_name}.<br>
				Got to the Nvidia <a href="http://www.nvidia.fr/Download/Find.aspx?lang=en">download center</a> site,
				or directly to the NVIDIA ftp repository <a href="https://download.nvidia.com/XFree86/">here</a>.<br>
				</body>
				</html>
			TXT
			)"
		( echo $HTML ) | $d_yad --html --width=420 --height=240 --title="Zenvidia" --window-icon=$img_zen_desktop \
		--image=zen-error --splash --borders=20 --text="${v}$error_log${end}" --button=$"Back to main"'!zen-close:0'
		trap "${rem_tmp[*]}" EXIT
		base_menu
	fi
}
extract_build(){ #
	pushd $nvtmp
	if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version) ]; then
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo $"# ${v}${j}($n%)${end} - $(new_version) package already extracted${end}"; sleep 2
		n=$[ $n+30 ]
	else
		[ ! -d NVIDIA-Linux-$ARCH-* ]|| rm -Rf NVIDIA-Linux-$ARCH-*
		## save dir name for install and post install process.
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo $"# ${v}${j}($n%)${end} - Primary package extraction${end}"; sleep 2
		progress_msg(){ echo $"# ${j}($m%)${end}${ge}${sf} * ($m%) Extracting $extracted_release${end}${end}"; echo "$m"; }; m=$n; do_slp=1
		progress "$run_pkg -x" #; . $tmp_c; rm -f $tmp_c
		sleep 1
		if [ -d $extracted_release ]; then
			cp -f $nvtmp/$extracted_release/nvidia-installer .
			echo -e "$(new_version)" > $nvdir/new_version.txt
		else
			warn_log=$"${j}${bf}Nvidia repository not found${end}${end}.${v} Extraction failure.${end}"
			warn_image='zen-error'
			qst=0; ok_lbl='' ; cancel_lbl=$"Close"'!zen-back' ; kill_yad=1
			win_yad_warns
			exit 0
		fi
	fi
	popd
}
## temporary download/install directory
tmp_dir(){
	if [ $rem_extract = 1 ]; then
		nvtmp=$(mktemp -d --tmpdir nv_extract.XXXX)
		rem_tmp+=("rm -Rf $nvtmp")
		[ $from_install = 1 ] || trap "${rem_tmp[*]}" EXIT
		mkdir -p $nvtmp/build
		buildtmp=$nvtmp/build
	else
		buildtmp='build'
		[ -d $nvtmp/$buildtmp ]|| mkdir -p $nvtmp/$buildtmp
	fi
}
## BACKUP & PROGRESS COUNT ###
## progress counters.
tar_count(){
	( eval "$1" &>/dev/null ) & \
	( count_msg )
	m=$(($m+1))
}
progress(){
	test $tmp_c || {
	tmp_c=$(mktemp --tmpdir zn_count.XXX)
	rem_tmp+=("rm -f $tmp_c") ; }
	local exitval=0
	local pid progresspid
	if [[ $1 ]]; then
		eval_pid(){
			on_exit(){
				kill $(jobs -p) 2>/dev/null
				wait $(jobs -p) 2>/dev/null
			}
			trap on_exit EXIT
			while [ -d /proc/$pid ]; do
				( progress_msg )
				sleep $do_slp &
				#test $do_slp = 1 && sleep 1 &
				wait $!
				((m++))
			done
			echo -e "n=$m" > $tmp_c
		}
		( eval "$1" &>/dev/null ) & \
		pid=$! eval_pid & \
		progresspid=$!
		wait $pid 2>/dev/null
		exitval=$?
		kill $progresspid 2>/dev/null

		wait $progresspid 2>/dev/null
   fi
   ## line to paste in global progress count
	#	. $tmp_c ; rm -f $tmp_c
	return $exitval
}
y_pulse(){
	while [ -d /proc/$lpid ]; do
		for ((i=1; i<=$timeout; i++)) {
			echo $i 2>/dev/null
			sleep 0.096
			}
		done
	return
}
## previous version backup command.
backup_old_version(){ #
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	if [ -d $nv_root/nvidia.$bak_version ]; then
		pushd $nvbackup
		## make the archive.
		local zip_cmd
		m=1
		do_slp=1
		count_msg(){ echo $"# ($m s) - Backup : $bak_version tar ball creation"; sleep 1; echo "$m"; }
		progress_msg(){ echo $"# ($m s) - Backup : $bak_version $ZIP archive creation"; echo "$m"; }
		tar_count "tar cf nvidia.$bak_version.tar /etc/OpenCL"
		tar_count "tar cf nvidia.$bak_version.tar /etc/default/grub"
		tar_count "tar uf nvidia.$bak_version.tar /etc/ld.so.conf.d/nvidia-*"
		test -f /etc/udev/rules.d/01-nvidia-driver.rules && \
		tar_count "tar uf nvidia.$bak_version.tar /etc/udev/rules.d/01-nvidia-driver.rules"
		## save modules conf if exist.
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/blacklist-nouveau.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/nvidia-blacklist.conf"
		test -f /etc/modprobe.d/nvidia-drm.conf && tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/nvidia-drm.conf"
		test -f /etc/modprobe.d/open-NVIDIA.conf && tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/open-NVIDIA.conf"
		## if backup is create with a use_open var to 1 and the present driver config is different,
		## open-NVIDIA.conf file is not enought to tell the right way of use. User's use_open var must be saved too.
		tar_count "tar uf nvidia.$bak_version.tar /home/$(def_user)/.zenvidia/basic.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf.nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-hibernate.service.wants"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-suspend.service.wants"
		## take care of dkms auto install behaviour upon open source driver installation.
		test -f /etc/dkms/no-autoinstall && tar_count "tar uf nvidia.$bak_version.tar /etc/dkms/no-autoinstall"
		tar_count "tar uf nvidia.$bak_version.tar /lib/modules/$KERNEL/$(module_dest_location)/nvidia*"
		tar_count "tar uf nvidia.$bak_version.tar /lib/firmware/nvidia/$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia.$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar /usr/lib/systemd/system/nvidia-*"
#  		test -d /usr/$master$ELF_32/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
#  		test -d /usr/$master$ELF_64/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
 		[ -d /usr/$master$ELF_32/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
 		[ -d /usr/$master$ELF_64/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*"
		make -C /usr/src/nvidia-$bak_version clean
		tar_count "tar uf nvidia.$bak_version.tar /usr/src/nvidia-$bak_version"
		if [ -d /usr/src/open-nvidia-$bak_version ]; then
			make -C /usr/src/open-nvidia-$bak_version clean
			tar_count "tar uf nvidia.$bak_version.tar /usr/src/open-nvidia-$bak_version"
		fi
		tar_count "tar uf nvidia.$bak_version.tar $install_dir/bin/nvidia-*"
		if [[ $(ls -1 /usr/local/$master$ELF_32/libnvidia-*| grep -c $bak_version) -le 3 ]]; then
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_32/libnvidia-{fbc{.so,.so.1},*.$bak_version}"
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}"
		else
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}"
 		fi
# 		tar_count "tar uf nvidia.$bak_version.tar $install_dir/share/nvidia/nvidia-application-profiles-$bak_version*"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/dkms/nvidia/$bak_version/{source,$KERNEL}"
		[ -d /var/lib/dkms/open-nvidia/$bak_version ] && \
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/dkms/open-nvidia/$bak_version/{source,$KERNEL}"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/nvidia/{dirs,log}"
		tar_count "tar uf nvidia.$bak_version.tar $nvdir/version.txt"
		if [ "$ZIP" = "ZST" ]; then # ZST is not used, but kept for the future.
			## compress in zst zstd -q -f -T0 -20 --ultra *
			zip_cmd='zstd -q -f -T0 -20 --ultra'
		elif [ "$ZIP" = "XZ" ]; then
			zip_cmd='xz -f -T'$proc
		elif [ "$ZIP" = "GZIP" ]; then
			## compress in gz.
			zip_cmd='gzip -fc'
		fi
		progress "${zip_cmd} nvidia.$bak_version.tar > nvidia.$bak_version.tar$zip_ex"
		rm -f $nvbackup/nvidia.$bak_version.tar
		echo $"# Backup: $bak_version $ZIP archive created"; sleep 1
		popd
	fi
}

## UPDATE DRIVER SECTION ###
upgrade_new_kernel(){ #
	unset kern_list
	up_version=$(version)
	ls_kern=$(ls -1 /boot| grep -v "rescue\|$(uname -r)"| grep "vmlinuz"| sed -n 's/^[[:alpha:]]*-//p')
	for linuz in ${ls_kern}; do
		kern_list+=("false")
		kern_list+=("$linuz")
	done
	w_text=$"$( cat <<-MSG
		$menu_msg
		Driver install ${j}$up_version${end} for hardware ${j}${dev_name}${end}.
		Select the kernel to update.
	MSG
	)"
	l_text=$w_text
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b"); NEW_KERNEL=$(win_yad_list "${kern_list[*]}")
	_exit=$?
	#if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; base_menu; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && base_menu
	IFS=$ifs
	KERNEL=$NEW_KERNEL
	kernel_path="/lib/modules/$KERNEL/$(module_dest_location)/"
	upgrade_kernel
}
upgrade_kernel(){ #
	drv_release=$(ls $nvdl/ | grep "$(new_version)")
	warn_log=$"${j}<b>Kernel driver update</b>${end}\n${y}$KERNEL${end} drivers will be update."
	qst=1; ok_lbl=$"Update"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back' ; kill_yad=0
	win_yad_warns
	if [ $_exit = 1 ]; then menu_update; fi
	y_text=$"${v}Kernel ${j}$KERNEL${end} driver update${end}"
	pulse=1; log=0; hold=0 ; hide_txt=0
	## tell yad that basic pusle win is pulse
	{ timeout=30 ;{
	YAD_PID=$(pgrep -n yad)
	echo -e $"# Kernel update $KERNEL ..."
	cd $nvdl/
	nv_cmd_update
	if [ $pass -gt 0 ]||[ ! -e $kernel_path/nvidia.*[ko\|ko.xz] ]; then
		warn_log=$"${j}INSTALL ABORT ABNORMALY, check $(echo "$logfile" | sed -n 's/^.*=//p')${end}."
		qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-back' ; kill_yad=0
		win_yad_warns
	fi
	new_version=$(version)
	}& eval lpid=$!; y_pulse; } | win_yad_progress
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/update-$KERNEL.log; fi
	trap "${rem_tmp[*]}" EXIT
	base_menu
}

## FROM A REMOTE/USER DIRECTORY ###
net_version_selector(){ #
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP

		${v}<b>Select the driver version type to install</b>${end}
		${sf}
		   - <b>Look up for latest</b>:
		   Look for the last available packges from Nvidia repos site.
		   - <b>Look up for older version</b>:
		   Look for a previous packeges available in Nvidia repos site.
		${end}
		HLP
		)"
	else
		hlp_tip=$"\n${v}<b>Select the driver version type to install</b>${end}"
	fi
	unset list_array
	IFS=$(echo -en "\n\b")
	list_array=( true 1 $"Look for latest version" false 2 $"Look for older version" )
	l_text=$"${j}${bf}Driver version type to install${end}\n${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	menu_select=$( win_yad_list "${list_array[*]}" )
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs ;base_menu; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && base_menu
	IFS=$ifs
	case $menu_select in
		"1") check_for_newer ;;
		"2") check_for_older ;;
		*) base_menu ;;
	esac
	check_update
}
check_dl_command(){
	y_text=$"NVIDIA Download center data check"
	pulse=1; log=0; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{	timeout=30
	{	$p_wget -q -O $upcompat/last_update https://$nvidia_ftp-$ARCH/latest.txt
	}& eval lpid=$! ; y_pulse ;} | win_yad_progress
}
check_for_older(){
	check_dl_command
	LAST_OFFI=$(cat $upcompat/last_update | awk '{ print $1 }')
	unset rem_packages_list old_pack_list
	rem_packages_list=( $(tac $(rem_drv_list)) )
	for pack_list in "${rem_packages_list[@]}"; do
		old_pack_list+=("false")
		old_pack_list+=("$pack_list")
		n=$[ $n+1 ]
	done

	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	older_pack=$( win_yad_list "${old_pack_list[*]}" )
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs ;base_menu; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && base_menu
	IFS=$ifs
	LAST_DRV=$older_pack
	legacy_drv=1
}
check_for_newer(){
	check_dl_command
	LAST_DRV=$(cat $upcompat/last_update | awk '{ print $1 }')
	legacy_drv=0
}
## UPDATED RELEASE CHECK ###
hardware_compat(){ #
	y_text=$"NVIDIA Download center compatibility check (${j}$DRV${end})..."
	pulse=1; log=0; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{	timeout=30
	{	$p_wget -q -O $upcompat/upt_compat https://$nvidia_ftp-$ARCH/$DRV/README/supportedchips.html
	}& eval lpid=$!; y_pulse; } | win_yad_progress

	cat $upcompat/upt_compat | sed -n "/<h3>/,/Below are the legacy/{;/<tr\|<td\|<\/tr>/p}"| \
	perl -n -pe "s|(<(/\|)t[r,d](>\| id=\"))||,s|(\">\|</td>)\n|,|p" > $nvcompat/compat.$DRV

	## build a genaral compatibility list for series drivers classes.
	upt_compat_list=$(user_CF_DIR)/updates/upt_compat_list
	upt_local_conf=$(rem_drv_list)

	cat $upcompat/upt_compat | sed -n "/<h3>/,/name=\"subsys/p"| \
	perl -n -pe "s|(<(/)?t[r,d,a,b](ble\|ody)?(>\| id=\")?)||;s|(\">\|</td>)\n|,|; \
	s|.*legacy_(.*.xx)\">.*|* \1|;s|.*<[/]?[dtpc].*$||p"| \
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p" > $upt_compat_list
	## add a separator at the end.
	echo -e "------" >> $upt_compat_list

	## here start the compatibility tool.
	unset COMPAT class_list sed_output
	[ -d $nvcompat ]|| mkdir -p $nvcompat/series
	IFS=$(echo -en "\n\b")
	## define the separation chapter series section.
# 	COMPAT+=("Current NVIDIA GPUs")
	COMPAT+=("<h3>")
	COMPAT+=("$(grep -E "\* *[0-9]{2,4}((.xx)|(\.*[0-9]{2,3}.xx))" $upt_compat_list)")
	if [ $(ls -1 $nvcompat/series/ | grep -E -c "^[0-9]*\.[0-9]*\.[0-9]*$") -gt 0 ]; then
		rm -f $nvcompat/series/* | grep -E "^[0-9]*\.[0-9]*\.[0-9]*$"
	fi
	for line in ${COMPAT[@]}; do
		if [[ $line =~ ".xx" ]]; then
			drv_class=$(echo -e "$line"| sed -En "s/\* (.*).xx$/\1/p")
			line=$(cut -d' ' -f2 <<< $line)
		else
			drv_class=$(echo "$DRV"| cut -d. -f1)
		fi
		drv_end=$(cat <<< ${COMPAT[*]}| grep -A1 "$line"| sed -En "s/^\* (.*).xx$/\1/g;\$p")
		test "$drv_end" = "$drv_class" && drv_end='-----'
		## send result in separate compat files.
		sed_output=( $( sed -En "/$line/,/$drv_end.xx/p" $upt_compat_list) )
		sed -En "/$line/,/$drv_end.xx/p" $upt_compat_list | grep -E "^devid" > $nvcompat/series/$drv_class
	done
	IFS=$ifs
	## build compat file list from created.
	class_list=("$(ls -1 $nvcompat/series/| sort -n)")
	## dig for device id and usual name.
	pci_class=${dev[$e]}
	pci_brand=${slot_id[$e]}
	## check compat.
	if [ $(grep -ic "devid$pci_brand" $nvcompat/series/$(echo "$DRV"| cut -d. -f1)) -gt 0 ]; then
		## send message for the INSTALL_DRIVER section.
		if [ $from_install = 1 ]; then
			echo -e $"install_msg='# ${v}${j}($n%)${end} - Compatiblity found in ${y}$(echo "$DRV"| cut -d. -f1)${end} serie, proceed to install${end}'" > $tmp_b
		fi
# 		dev_compat=1
	else
		for comp_file in ${class_list[@]}; do
			if [ $(grep -ic "devid$pci_brand" $nvcompat/series/$comp_file) -gt 0 ]; then
				## message for INSTALL_DRIVER section.
				if [ $from_install = 1 ]; then
					warn_log=$"$(cat <<-ERR
						${rB}${bf}<i>UNCOMPATIBLE DRIVER</i>${end}${end}
						${v}The ${j}$pci_class${end} is not compatible with ${j}$DRV${end} driver.
						Check in ${j}$comp_file${end} serie or greater instead.
						Abort.${end}
					ERR
					)"
					qst=0; warn_image=zen-error; cancel_lbl=$"Got it"'!zen-ok'; kill_yad=1
					win_yad_warns
					export family=$comp_file
					exit 1
				fi
				## serie driver class for the update/install section.
				family=$comp_file
			fi
		done
		## define vars for the update/install section.
		if [ $family ]; then
			# family is consantly greater that 0
			if [ $(chk_family) = 0 ]||[ $family -le $(chk_family) ]; then
				# if not (no driver installed) or at least lower or equal to installed version (if any),
				# looks for compatible driver in drv list.
				family_last=$(cat $upt_local_conf | grep "$family" | sed -n '$p')
				legacy_drv=1
				((legacy_display_indicator++))
			else
				# in other case driver is not legacy anymore, proceed as usual.
				legacy_drv=0
			fi
			# mark compat family as found.
			family_compat=1
		else
			## send fatal if no driver support.
			if [ $from_install = 1 ]; then
				warn_log=$"$(cat <<-ERR
					${rB}${bf}<i>UNCOMPATIBILITY ISSUE</i>${end}${end}
					${v}The ${j}$pci_class${end} is not supported by ${j}NIVDIA${end} driver.
					and there's no solution here except reverse to ${j}Nouveau${end} driver.
					Abort.${end}
				ERR
				)"
				qst=0; warn_image='zen-error'; cancel_lbl=$"Got it"'!zen-ok'; ok_lbl=''; kill_yad=1
				win_yad_warns
			fi
			# mark compat family as not found. driver uncompatible.
			family_compat=0
		fi
		echo -e "family_last=$family_last" >> $upt_comp_tmp # use by legacy check.
		echo -e "family=$family" >> $upt_comp_tmp # use by legacy check.
		echo -e "legacy_result=$legacy_drv" >> $upt_comp_tmp
		echo -e "family_compat=$family_compat" >> $upt_comp_tmp # use by legacy check.
		echo -e "legacy_display_indicator=$legacy_display_indicator" >> $upt_comp_tmp
	fi
}
check_update(){ #
	unset DIFF_list LOCAL_DRV
	LAST_IN=$(version)
	LAST_BETA=$(tac $(rem_drv_list) | sed -n 1p)
	upt_comp_tmp=$(mktemp --tmpdir zn_vars.XXXX )
	rem_tmp+=("rm -f $upt_comp_tmp")
	## COMPATIBILTY SECTION
	# first chack if alpha = beta or not.
	if [[ $LAST_DRV == $LAST_BETA ]] ; then
			DIFF_list=$LAST_DRV
	else
			DIFF_list="$LAST_DRV $LAST_BETA"
	fi
	## reset old compatibilty sets.
	family_check=0
	legacy=0
	family_compat=0
	legacy_display_indicator=0

	## desktop could have more than one device managed. So check.
	for e in ${dev_n[@]}; do # ALERT TODO CHECK
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			for DRV in $DIFF_list; do
				## test existence of the new driver version in remote tree and compatibilities.
# 				unset legacy_display_indicator comp_result
				$(hardware_compat)
				. $upt_comp_tmp
				## and prepare optional messages to display.
				if [ $(cat $(rem_drv_list)| grep -c $DRV) -gt 0 ]; then
					dl_allow=1
				else
					dl_allow=0
				fi
				# mark driver stocked in local repos.
				in_pack=$(ls -1 $nvdl/ | grep -c "$DRV")
				test "$DRV" == "$LAST_IN" && _installed=1 || _installed=0
				if [ "$LAST_BETA" ]&&[ "$LAST_BETA" != "$LAST_DRV" ]; then
					if [ $legacy_drv = 1 ]; then
						test "$DRV" == "$LAST_BETA" && _is_beta=0 || _is_beta=1
					else
						test "$DRV" == "$LAST_BETA" && _is_beta=1 || _is_beta=0
					fi
					test $legacy_drv -gt 0 && _is_beta=0
				else
					_is_beta=0
				fi
				# comp_result in upt_comp_tmp
				DEV_filter=$(cat $nvcompat/compat.$DRV| grep -E -wi "devid${slot_id[$e]}")
 				dev_compat=$( [ $(cat $nvcompat/compat.$DRV| grep -E -ic "devid${slot_id[$e]}") -gt 0 ] && echo 1 || echo 0 )
				VDPAU_class=$(printf "$DEV_filter"|cut -d"," -f4) # J
				LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow,$legacy_result")
			done
		fi
	done
	## write it in default script directory for further use.
	echo -e "${COMP_I[@]}" > $nvcompat/compat.update
	sed -i "/^[[:space:]]*$/d;s/^\ //g" $nvcompat/compat.update
	win_update
}
win_update(){ #
	unset DOWN_list main_msg more_msg COMP_L in_installed in_compat_list un_compat_list compat_msg
	## define window messages and display compatibilities.
	in_local_repos=0
	in_dl_repos=0
	in_installed=0
	un_compat_list=0
	in_compat_list=0

	## get driver list from check_update to define local presence and what to display.
	# LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow,legacy_result")
	# '364.12,0,0,0,"0",GeForce RTX 2060,,1'
	# '525.85.05,1,0,0,"1",GeForce RTX 2060,J,1'
	IFS=$(echo -en "\n\b")
	for local_drv in ${LOCAL_DRV[@]}; do
		_drive=$(echo "$local_drv"|cut -d',' -f1)
		_exist=$(echo "$local_drv"|cut -d',' -f2)
		_insta=$(echo "$local_drv"|cut -d',' -f3)
		_beta=$(echo "$local_drv"|cut -d',' -f4)
		_dev_comp=$(echo "$local_drv"|cut -d',' -f5)
		_name=$(echo "$local_drv"|cut -d',' -f6)
		_vclass=$(echo "$local_drv"|cut -d',' -f7)
		_dl_ok=$(echo "$local_drv"|cut -d',' -f8)
		## messageries
		end_msg=$"What do you want to do ?"

		case $_insta in
			0) set_in='' ;;
			1) set_in=$" (installed)"; ((in_installed++)) ;;
		esac
		if [ "$_vclass" ]; then comp_v=$"(VDPAU class $_vclass)"; fi
		case $_dl_ok in
			0) dl_warn=$"\n${y}but is not downloadable yet (wont be list)${end}" ;;
			1) dl_warn='' ;;
		esac

		case $_dev_comp in
			0) comp_a=$"${vB}uncompatible${end}"
				comp_b=$"${y}$_drive${end} ${rB} driver doesn't manage your hardware${end}\n"
				((un_compat_list++))
			;;
			1) comp_a=$"compatible"
# 				comp_b="compatible. $comp_v"
				comp_b=$"${j}$_drive${end} ${v} driver fit your hardware${end} ${y}$(echo -e '\u2764')${end}\n" # or 2714
				((in_compat_list++))
			;;
		esac
		case $_beta in
			0)
			if [ $legacy_drv = 0 ]; then
				set_beta=$"official"; _drv_title=$"official"; tab=''
			else
				if [ "$_drive" == "$LAST_BETA" ]; then
					if [ $LAST_OFFI != '' ]; then
					set_beta=$"beta"; _drv_title=$"beta"; tab='- -'
					else
					set_beta=$"official"; _drv_title=$"last release"; tab=''
					fi
				else
					set_beta=$"legacy" ; _drv_title=$"legacy"; tab=''
				fi
			fi
			;;
			1) set_beta=$"beta"; _drv_title=$"beta"; tab='- -';;
		esac
		case $_exist in
			0) in_repos=$"is not in your repository"
				DOWN_list+=("false"); DOWN_list+=("$_drive"); DOWN_list+=("($_drv_title)"); ((in_dl_repos++))
			;;
			1) in_repos=$"is in your repository"; ((in_local_repos++))
			;;
		esac

		COMP_L+=($"${j}$_name${end} ${v}($_drive), $comp_a${end}")
		COMP_L+=("$comp_b")
		main_msg+=($"\n${v}The $set_beta version is :${end}${ge} ${tab} - - - - - - ${end}${y}$_drive${end}")
		more_msg+=($"\n${j}$_drive${end}${vB} $in_repos.${end}${v}$set_in${end}$dl_warn")
		## define the appropriate UI.
		case $in_local_repos in
			0|1) ui_mod=1		# dl/inst selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg=$"Nothing to do." ;;
					1) if [ $un_compat_list -ge 1 ]; then
							ui_mod=2
						elif [ $in_dl_repos -eq 0 ]; then
								ui_mod=2
						fi
						if [ $in_installed -eq 1 ]&&[ ${#DOWN_list[*]} -eq 0 ]; then
							ui_mod=0; end_msg=$"Nothing to do."
						fi
					;;
				esac
			;;
			2|3) ui_mod=2		# inst local selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg=$"Nothing to do." ;;
					1) if [ $in_dl_repos -gt 0 ]; then
							ui_mod=1
						fi
					;;
				esac
			;;
		esac
	done
	## this section is for lagacy driver part and has to be display only once.
	if [ $legacy_display_indicator -ge 1 ]; then
		if [ $family_compat -gt 0 ]; then
			case $family_compat in
				0) comp_c=$"${y}this driver is not supported anymore${end}"
					test $legacy_result -gt 0 && comp_d='\n'
				;;
				1) # be sure that driver is not already downloaded.
					if [ $family_last != $(new_version) ]; then
						# if exist in path, do nothing.
						if [ $(ls -1 $nvdl/ | grep -c "$family_last") = 1 ]; then
							in_repos=$"is in your repository"
							ui_mod=2
							comp_d=''
						else
							# if doesn't exist in path add it to the download list.
							in_repos=$"is not in your repository"
							DOWN_list+=("false")
							DOWN_list+=("$family_last")
							DOWN_list+=($"(last legacy)")
							comp_d=$"\n${v}Last ${y}$family_last${end} will be list.${end}"
						fi
						comp_c=$"\n${v}Devices compatibility found in ${y}$family${end} serie${end}$comp_d"
					else
						comp_c=$"\n${v}Compatible driver for ${y}$family${end} serie already installed.${end}"
						in_repos=$"is in your repository"
						ui_mod=2
					fi
					more_msg+=($"\n${j}$family_last${end}${vB} $in_repos.${end}")
					end_msg=$"What do you want to do ?"
			esac
			COMP_L+=("$comp_c")
		fi
	fi
	compat_msg=$(cat <<< ${COMP_L[*]})
	IFS=$ifs
	extra_msg="\n${more_msg[@]}\n\n${v}$end_msg${end}"
	ok_lbl=$"Select"; cancel_lbl=$"Abort"
	case $ui_mod in
		0)	zen_opts="--image=zen-warning --borders=15 --button=Abort!zen-back:1"
			table_opts=''
			list_opts=''
			;;
		1)	zen_opts="--list --radiolist --no-headers --borders=15 --button=$cancel_lbl!zen-back:1 --button=$ok_lbl!zen-ok:0"
			table_opts='--column set --column 2 --column action --separator= --hide-column=2 --print-column=2'
			list_opts="true 1 Install false 2 Download ";;
		2)	zen_opts="--image=zen-question --borders=15 --button=$cancel_lbl!zen-back:1 --button=$ok_lbl!zen-ok:0"
			table_opts=''
			list_opts=''
			;;
	esac
	case $ui_mod in
		0|2) w_height='--height=100' ;;
		1)   w_height='--height=200' ;;
	esac
	w_text=$"$(cat <<-MSG
		${jB}${bf}Available drivers${end}${end}

		${v}Driver version installed :${end}${ge} - - - - - ${end}${j}$(drv_installed)${end}
		$(cat <<< ${main_msg[@]})

		$compat_msg
		$extra_msg
	MSG
	)"
	# Don't use yad window function for this.
	sel_cmd=$($d_yad --width=300 $w_height --window-icon=$img_zen_desktop --title="Zenvidia" --center \
	$zen_opts --text="$w_text" $table_opts $list_opts )
	if [ $? = 0 ]; then
		case $ui_mod in
			0) [ $task_opt -gt 0 ] && exit 0 || base_menu ;;
			1) case $sel_cmd in
					"1") ok_label=$"Install"; from_net ;;
					"2") ok_label=$"Download"; download_only ;;
				esac ;;
			2) from_directory ;;
			*) [ $task_opt -gt 0 ] && exit 0 || menu_install ;;
		esac
	else
		trap "${rem_tmp[*]}" EXIT; [ $task_opt -gt 0 ] && exit 0 || base_menu
	fi
}
from_directory(){ #
	nv_dir(){
		unset list_drv
		cd $nvdl; n=1
		for local_drv in ${nvdl_list[@]}; do
			if [ $_drive ]&&[[ "$local_drv" =~ "$_drive" ]]; then
				list_drv+=("true")
			else
				list_drv+=("false")
			fi
			list_drv+=("$local_drv")
		done
		l_text=$"$(
		cat <<-INFO
			${j}${bf}Install from stock${end}${end}

			Driver list in $nvdl

			$loaded
		INFO
		)"
		IFS=$(echo -en "\n\b")
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
		ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		drv_pick=$( win_yad_list "${list_drv[*]}" )

		if [ $? = 0 ]; then
			IFS=$ifs
			if [ "$drv_pick" != '' ]; then
				run_pkg=$nvdl/$drv_pick
			else
				from_directory
			fi
		else
			IFS=$ifs
			if [ $_drive ]; then
				[ $task_opt -gt 0 ] && exit 0 || menu_install # base_menu
			else
				[ $task_opt -gt 0 ] && exit 0 || from_directory # menu_install
			fi
		fi
	}
	home_dir(){
		unset list_drv
		for local_drv in ${home_list[@]}; do
			list_drv+=("false")
			list_drv+=("$local_drv")
			list_drv+=("$(sed -En "s|^.*\/||g;p" <<< $local_drv)")
		done
		l_text=$"$(
		cat <<-INFO
			${j}${bf}Install from user directory${end}${end}

			Select a driver from ${j}$(def_user)${end} download directory

			$loaded
		INFO
		)"

		IFS=$(echo -en "\n\b")
		cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		drv_pick=$( win_yad_list "${list_drv[*]}" )

		if [ $? = 0 ]; then
			IFS=$ifs
			if [ "$drv_pick" != '' ]; then
				chmod a+x $drv_pick
				run_pkg=$drv_pick
			else
				from_directory
			fi
		else
			IFS=$ifs; [ $task_opt -gt 0 ] && exit 0 || from_directory # menu_install
		fi
	}
	test $(version) && loaded=$"${v}<i>${y}$(version)${end} actually installed and loaded.</i>${end}"
	nvdl_list=( $(ls -1 $nvdl| grep -v ".sum"| tac) )
	home_list=( "$(find $(user_DL_DIR)/ -regextype sed -regex "^.*NVIDIA-Linux-.*\.run"| tac)" )
	if [ $ui_mod = 1 ]; then
		unset list_array
		list_array=( false 1 $"Use Zenvidia stock directory" false 2 $"Use a user local directory" )
		l_text=$"$(
		cat <<-INFO
			${j}<b>Local NVIDIA drivers STOCK</b>${end}

			Zenvidia release stock :	${j}<b>${#nvdl_list[*]}</b>${end} object(s) found.
			User home directory :		${j}<b>${#home_list[*]}</b>${end} object(s) found.

			${v}<b>Select the directory to install from.</b>${end}
		INFO
		)"

		IFS=$(echo -en "\n\b")
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
		ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		from_cmd=$( win_yad_list "${list_array[*]}" )
		_exit=$?
# 		if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; [ $task_opt -gt 0 ] && exit 0 || base_menu; fi
		if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then [ $task_opt -gt 0 ] && exit 0 || base_menu; fi
		IFS=$ifs
		case $from_cmd in
			"1") nv_dir ;;
			"2") home_dir ;;
			*) [ $task_opt -gt 0 ] && exit 0 || menu_install ;;
		esac
	elif [ $ui_mod = 2 ]; then
		nv_dir
	fi
	new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
	INSTALL_DRIVER
}
from_net(){ #
# download functions
		cd $buildtmp
		download_menu
		run_pkg=$nvdl/nv-update-$LAST_PACK
		if [ -f $buildtmp/$run_pack ]; then
			warn_log=$"${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
			warn_image='zen-emblem'
			qst=0; cancel_lbl=$"Close"'!gtk-close' ; kill_yad=0
			win_yad_warns

			mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
			chmod 755 $nvdl/nv-update-$LAST_PACK
		fi
		new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
		INSTALL_DRIVER
}
download_menu(){ #
		l_text=$"$( cat <<-INFO
			${jB}${bf}Downloads${end}${end}
			Select the drivers version you wish to $ok_label.
			in the list below
		INFO
		)"
		output_type=1
	if [ ${#DOWN_list[*]} -gt 3 ]; then
		IFS=$(echo -en "\n\b")
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
		ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='300'; w_height='0'
		dl_cmd=$( win_yad_list "${DOWN_list[*]}" )
	else
		dl_cmd=${DOWN_list[1]}
		warn_log=$"$( cat <<-MSG
			${jB}${bf}Downloads${end}${end}
			NVIDIA ${y}$dl_cmd${end} driver is going to be $ok_label.

			${v}Are you sure ?${end}
		MSG
		)"
		qst=1; ok_lbl=$"Ok"'!zen-ok'; cancel_lbl=$"Back to main"'!zen-back' ; kill_yad=0
		win_yad_warns
	fi
	_exit=$?
	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then
# 		IFS=$ifs
		[ $task_opt -gt 0 ] && exit 0 || base_menu
	else
		if [ "$dl_cmd" ]; then
			LAST_PACK=$dl_cmd
		else
			warn_log=$"${r}Driver download failure${end}\nOutput is empty."
			[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
			qst=0; ok_lbl=$"Ok"'!zen-ok'; kill_yad=0
			win_yad_warns
			[ $task_opt -gt 0 ] && exit 0 || base_menu
		fi
	fi
	IFS=$ifs
	last_pack
}
download_only(){ #
	cd $buildtmp
	download_menu
	if [ -f $buildtmp/$run_pack ]; then
		warn_log=$"${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
		warn_image='zen-emblem'
		qst=0; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
		win_yad_warns

		[ $rem_extract = 0 ] || test -f $buildtmp/$run_pack.sha256sum && rm -f $buildtmp/$run_pack.sha256sum
		mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
		chmod 755 $nvdl/nv-update-$LAST_PACK
		trap "${rem_tmp[*]}" EXIT; [ $task_opt -gt 0 ] && exit 0 || base_menu
	else
		warn_log=$"${v}Driver download ${j}$LAST_PACK${end} failure.\n The package ${j}$run_pack${end} doesn't exist.${end}"
		warn_image='zen-emblem'
		qst=0; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
		win_yad_warns

		trap "${rem_tmp[*]}" EXIT ;[ $task_opt -gt 0 ] && exit 0 || base_menu
	fi
}
last_pack(){ #
	track(){
    # picked up & inspired by winetricks download progress commande:
    # Parse a percentage, a size, and a time into $1, $2 and $3
    # then use them to create the output line.
   	perl -p -e "$| = 1; s|^.* +([0-9]+%) +([0-9,.]+[GMKB]) +([0-9hms,.]+).*$|\1\n# $run_pack\t(\1): time left \3\t\2\/s|"
	}
	download_cmd(){
		$p_wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack $buildtmp/ 2>&1
	}
	download_error(){
		warn_log="$w_text"
		qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-undo' ; kill_yad=0; warn_image='zen-error'
		win_yad_warns
		if [ $_exit = 1 ]; then [ $task_opt -gt 0 ] && exit 0 || base_menu; fi
	}
	y_text=$"${v}Remote content control...${end}"
	pulse=1; log=0; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options
	{ timeout=30
	{	$p_wget -q -O $nvtmp/bug_list https://$nvidia_ftp-$ARCH/$LAST_PACK/
		cat $nvtmp/bug_list | grep -E -o "href='NVIDIA.*[0-9]+.*'"| perl -pe "s/^.*\'(.*)\'/\1/p" \
		> $nvtmp/selector
	} & eval lpid=$!; y_pulse; } | win_yad_progress

	if [ -s $nvtmp/bug_list ]; then
		if [ $(cat $nvtmp/selector | grep -c "$LAST_PACK") -gt 0 ] ; then
			RUN_PACK=$(cat $nvtmp/selector)
		fi

		unset drv_list
		for line in $RUN_PACK; do
			drv_list+=("false")
			drv_list+=("$line")
		done

		IFS=$(echo -en "\n\b")
		l_text=$"${v}Choose the version to install${end}"
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
		ok_lbl=$"Select"'!zen-ok'; l_tail=0; w_head=0
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='500'; w_height='300'
		run_pack=$(win_yad_list "${drv_list[*]}")
		_exit=$?
		if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then
# 			IFS=$ifs
			[ $task_opt -gt 0 ] && exit 0 || base_menu
		fi
		IFS=$ifs
		## from there, look into 'selector' file for sha256sum file.
		if [ -e $nvtmp/selector ]; then
			if [ $(cat $nvtmp/selector| grep -c "sha256sum") -gt 0 ]; then
				run_pack_sha=$run_pack.sha256sum
			fi
		fi

		y_text=$"<b>Downlaoding ${j}$LAST_PACK${end} driver from ${y}$nvidia_ftp${end}</b>"
		pulse=0; log=0; hold=0 ; hide_txt=0; [ $hold = 1 ] && win_log_options
		{	test $run_pack_sha && $p_wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack_sha $buildtmp/ &>/dev/null
			download_cmd | track
		} | win_yad_progress
		err=$?
		if test $err -gt 128; then
			if pid=`ps -A | grep ."wget" | awk '{print $1}'`; then
					echo User aborted download, killing wget
					kill $pid
			fi
		fi
		# get weight of the pack in ko.
		_local=$(du -h $buildtmp/$run_pack | awk '{print $1}'| grep -o "[0-9]*")
		_remote=$(cat $nvtmp/bug_list | grep -A1 "$run_pack<"|sed -En "s/^.*>(.*)<\/.*>.*$/\1/g;2p"| grep -o "[0-9]*")
		if [ -f $buildtmp/$run_pack.sha256sum ]; then
			local_sha=$buildtmp/$run_pack.sha256sum
			sha256sum $run_pack
			sha256sum --status -c $local_sha
			if [ $? = 1 ]; then
				w_text=$"${j}<b>Download check sum error</b>${end}.\nTransaction aborted\nTry to restart driver download from <b>Update menu</b>"
				download_error
			fi
		fi
		if [ $_remote -ne $_local ]; then
			w_text=$"${j}<b>Download unexpected end</b>${end}.\nPlease restart driver download from <b>Update menu</b>"
			download_error
		fi
		return $err
   else
		warn_log=$"$( cat <<-WRN
			${r}<b>$fatal_dev Remote directory is empty.</b>${end}
			Nvidia devs have probably forgoten to upload data.
			Feel free to try at a later time.
		WRN
		)"
		qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!gtk-close' ; kill_yad=0; warn_image='zen-error'
		win_yad_warns
		if [ $_exit -eq 1 ]; then trap "${rem_tmp[*]}" EXIT; [ $task_opt -gt 0 ] && exit 0 || base_menu; fi
	fi
}

## TOOLS ###

## common windows.
## available icons.
#	zen-back			red ltr arrow		|	zen-preferences	zenvidia config		|	zen-emblem		swiss_knife
#	zen-close		dialog-close		|	zen-xorg				xorg config				|	zen-emblem-gr	swiss_knife green
# 	zen-ok			dialog-apply		|	zen-swap				driver switch			|	zen-kill			xkill
# 	zen-undo			yellow ltr arrow	|	zen-refresh			driver update			|	zen-docs			gtk-Documentation
#	zen-stop			gtk-quit				|	zen-question		nvidia docs				|	zen-restore		gtk-restore
# 	zen-warning		dialog-warning		|	zen-info				nvidia changelog		|	zen-settings	nvidia-settings
#  zen-question	dialog-question	|	zen-warning			zenvidia changelog
#	zen-error		gtk-error			|	zen-stop				menu quit
# 	zen-info			gtk-info				|	zen-color			yad color config

win_log_options(){
	x_sleep=''
	if [ $xt_hold = 1 ]; then
		esc_message=$"# ${nr}*****  Close window to escape *****${end}"
		x_hold=''
		if [ $xt_delay -gt 0 ]; then
			esc_message=$"# ${nr}*****  Window will auto-close in $xt_delay seconds *****${end}"
			x_sleep="sleep $xt_delay"
			x_hold='--auto-close'
		fi
	else
		esc_message=''
		x_hold='--auto-close'
	fi
}
win_yad_warns(){
	# warn_log="[warn message string]"
	# qst=1/0 < is dialog a question ?
	# ok_lbl='[string]!icon'
	# cancel_lbl='[string]!icon'
	# warn_image='[image]' #> specific image
	# kill_yad=0/1 < do we need to kill parent window ?
	#
	# ex :
	#	warn, one button, no kill		>> qst=0; ok_lbl='' ; cancel_lbl='Close!zen-close' ; kill_yad=0
	#	question, no kill on error	>> qst=1; ok_lbl='Ok!zen-ok' ; cancel_lbl='Close!zen-close' ; kill_yad=0
	#	question, yad kill on error	>> qst=1; ok_lbl='Ok!zen-ok' ; cancel_lbl='Close!zen-close' ; kill_yad=1
	# y_output replace $?

	## grab parent YAD pid.
	[ $YAD_PID ] || YAD_PID=$(pgrep -n yad)
	IFS=$(echo -en "\n\b")
	if [ $qst = 1 ]; then
		cancel_btn="--button=$cancel_lbl:1"
		ok_btn="--button=$ok_lbl:0"
		[ "$warn_image" != '' ] || warn_image=zen-question
	else
		cancel_btn="--button=$cancel_lbl:1"
		ok_btn=''
		[ "$warn_image" != '' ] || warn_image=zen-warning
	fi
	$d_yad --width=420 --height=100 --title="Zenvidia" --window-icon=$img_zen_desktop --center \
	--image=$warn_image --borders=20 --text="$warn_log" $cancel_btn $ok_btn $kill_parent
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then _exit=1; else _exit=$_exit; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && _exit=1 || _exit=$_exit
	[ $kill_yad = 0 ] || if [ $YAD_PID -gt 0 ]; then kill $YAD_PID; fi
	IFS=$ifs

}
win_yad_progress(){
	# syntax :
	# with pulse :	{ timeout=xx ;{ [script] ;}& eval lpid=$!; y_pulse; } | win_yad_progress
	# progress :	{ [script] } | win_yad_progress
	# options :
	# [ $hold = 1 ] && win_log_options
	# y_text="[string]"
	# pulse=0/1		#> do pulse or not
	# log=0/1		#> display log window or not
	# hold=0/1		#> Hold window or not
	# hide_txt=0/1	#> Hide progress bar txt or not
	# extra options : hold options need other strings and depend of base script predefine option.
	# >> [ $hold = 1 ] && win_log_options	#> display hold message or not.
	# >> echo -e $esc_message" (without '' arround text var) inside script string shell '{...}'
	#
	# ex : with hold >> pulse=1; log=1; hold=1 ; hide_txt=1 ;[ $hold = 1 ] && win_log_options
	#		 autoclose with no progress bar text	>> pulse=1; log=1; hold=0 ; hide_txt=1
	#		 autoclose with progres bar text			>> pulse=1; log=0; hold=0 ; hide_txt=0

	[ $log = 1 ] && do_log="--height=300 --hide-text --enable-log='' --log-expanded --log-height=300 $x_hold"
	autoclose='--auto-close'; nobutton='--no-buttons'
	if [ $hold = 1 ]&&[ "$xt_hold" = 1 ]; then autoclose=''; nobutton=''; fi
	[ $hide_txt = 1 ] && hide_txt='--hide-text' || hide_txt=''
	[ $pulse = 1 ] && do_pulse='--pulsate '$autoclose || do_pulse=$autoclose
#  	[ $colors = 1 ] && w_colors='--fore='$fg_xterm' --background='$bg_xterm # ALERT on test
	[ "$YAD_PID" ] || YAD_PID=0
	$d_yad --width=500 --window-icon=$img_zen_desktop --title="Zenvidia" --center \
	--progress $nobutton $do_pulse $hide_txt --borders=15 --text="${v}$y_text${end}" $do_log $w_colors
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then _exit=1; else _exit=$_exit; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && _exit=1 || _exit=$_exit
}
win_yad_list(){
	# 	synbtax : IFS=$(echo -en "\n\b"); win_yad_list "${[list_array][*]}"; IFS=$ifs
	# 	options :
	#	l_text="[string]"
	# 	cancel_lbl="[string]"
	# 	ok_lbl="[string]"
	#	list_type='radiolist/checklist'
	# 	columns='1/2/3/etc'
	# 	col_name=( "[string]" "[string]" "etc") 	#> may not be filled.
	# 	sep=',/;/etc'
	# 	sel_col='0/1/2/etc' 		#> wich columns in the output
	# 	hid_col='0/1/2/1,2' 		#> unvisible columns
	# 	edit_col='0/1/2/1,2' 	#> editable columns
	# 	col_tip='0/1/2/etc' 		#> wich column to be used as tool tip text, must be set in hid_col var.
	#  l_tail='0/1'				#> tail at the end of the list.
	#
	# ex : col_name=( "[string]" "[string]")
	#  cancel_lbl='Back to main!zen-back'; ok_lbl='Select!zen-ok'; l_tail=0
	# 	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='600'; w_height='420'
	# or : list_type='checklist'; columns=5; col_name=( 'Set' 'Definition' 'Conf Set' 'Extra' '5' );
	# 	sel_col='0'; sep=';' ;hid_col='3,5'; edit_col=0; col_tip=3; w_width='550'; w_height='400'; l_tail=0

	unset col_list w_dim #buttons
	[ $w_head = 0 ] && unset col_name
	for ((i=0; i<=$(($columns-1)); i++)) {
		if [ ${#col_name[*]} -gt 0 ]; then id=${col_name[$i]}; no_head=''; else id=$i; no_head='--no-headers'; fi
		[[ "$hid_col" =~ $(($i+1)) ]] && EXTRA=':HD' || EXTRA=''
		col_list+=("--column=$id$EXTRA");
	}
	[ $w_width -gt 0 ] && w_dim+=( '--width='$w_width )
	[ $w_height -gt 0 ] && w_dim+=( '--height='$w_height )
	[ "$edit_col" != 0 ] && { edit_col='--editable-cols='$edit_col; editable='--editable'; } || edit_col=''
	[ $col_tip -gt 0 ] && tip_col='--tooltip-column='$col_tip || col_tip=''
	[ $sel_col -gt 0 ] && sel_col='--print-column='$sel_col || sel_col=''
	[ $l_tail -gt 0 ] && l_tail='--tail' || l_tail=''
	[[ "$list_type" =~ "checklist" ]] && list_type=( --checklist --multiple $editable ) || list_type='--radiolist'
	buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" )
	# an additional option could be pass in $2.
	$d_yad ${w_dim[*]} --window-icon=$img_zen_desktop --title="Zenvidia" --borders=15 --center \
	--list ${list_type[*]} $no_head --separator=$sep $tip_col $sel_col $edit_col $l_tail \
	${col_list[*]} --text="$l_text" ${buttons[*]} ${1} ${2}
}
win_yad_text(){
	## NOTE: if yad text output is send in a variable, the EXIT value stay in this variable and cant be check by next test.
	## It is needed in this case to test the content of variable output : empty/full.
	## Here 'wc' is the helper: [ $(wc -l <<< $var_output) -gt 1 ] # wc will count 1 if data doesn't come from a file.
	# 	log_brief="[output]"
	# 	syntax : win_yad_text "$log_brief"
	# 	options :
	# 	log_txt="[string]"
	# 	cancel_lbl="[string]"
	# 	ok_lbl="[string]"
	# 	w_formatted=0/1	#> dispkay markup formats.
	# 	w_wrap=0/1			#> wrap text to window.
	# 	w_width='bool'		#> window width.
	# 	w_height='bool'	#> window height.
	# 	all_btn=0/1			#> display cancel button only (0) or both (1).
	#  colors=0/1			#> set foreground, background colours.
	# 	ex : w_formatted=1; w_wrap=0; _width='600'; w_height='400'; all_btn=0
	#
	#  log_txt="[string]"; cancel_lbl="Exit!gtk-close"; ok_lbl="Back!zen-undo"
	#	w_formatted=1; w_wrap=1; w_width='600'; w_height='400'; all_btn=1; colors=1
	#	win_yad_text "$log_brief"

	unset w_dim buttons
	if [ -f "$1" ]; then
		input_way=$(< "${1}")
	else
		input_way=$(cat <<< "${1}")
	fi
	fore_c='#000'
	back_c='#B6AB99'
	[ $w_wrap = 1 ] && w_wrap='--wrap' || w_wrap=''
	[ $w_formatted = 1 ] && w_formatted='--formatted' || w_formatted=''
	[ $w_width -gt 0 ] && w_dim+=( '--width='$w_width )
	[ $w_height -gt 0 ] && w_dim+=( '--height='$w_height )
	[ $all_btn = 1 ] && buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" ) || buttons="--button=$cancel_lbl:1"
	[ $colors = 1 ] && w_colors=( "--fore=$fg_xterm" "--back=$bg_xterm" )
	$d_yad ${w_dim[*]} --title="Zenvidia" --window-icon=$img_zen_desktop --text="$log_txt" --borders=15 --center "${2}" \
	--text-info $w_formatted --margins=10 $w_wrap --hscroll-policy=never ${w_colors[*]} ${buttons[*]} \
	<<< "$input_way"
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then _exit=1; else _exit=$_exit; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && _exit=1 || _exit=$_exit
}
win_open_switch(){ #
	if [ $open_drv -gt 0 ]; then
		if [ $task_opt = 1 ]&&[ -s $(user_CF_DIR)/old_basic.conf ]; then
			. $(user_CF_DIR)/old_basic.conf
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					drv_swt_message=$"${y}<b>Open Source driver</b>${end} will apply."
				else
					drv_swt_message=$"${y}<b>Closed Source driver</b>${end} will apply."
				fi
			else
				drv_swt_message=$"${j}<b>Open Source Driver</b>${end} will be removed."
			fi
			warn_log=$"$( cat <<-SPW
				${j}${bf}Task bar Driver switch${end}${end}

				<b>Nvidia Open driver configuration sets has been change</b>.
				$drv_swt_message
				${sf}<i>(driver license $($d_modinfo -F license nvidia -k $KERNEL) actualy loaded)</i>${end}

				Press button to apply.
				Confirmation window will be displayed.
			SPW
			)"
			qst=0; ok_lbl=''; cancel_lbl=$"Apply"'!zen-ok'; kill_yad=0
			win_yad_warns
			nv_open_switch
			rm -f $(user_CF_DIR)/old_basic.conf
			exit 0
		else
			old_open_drv=$open_drv
			old_use_open=$use_open
			if [ $use_open -gt 0 ]; then OPEN='TRUE'; PROP='FALSE'; else OPEN='FALSE'; PROP='TRUE'; fi
			l_text=$"$( cat <<-MSG
				${v}${j}${bf}Driver switch${end}${end}

				<b>Driver type selection (open source / proprietary)</b>.

				<i>( ${y}driver with license $($d_modinfo -F license nvidia -k $KERNEL) actualy loaded${end} )</i>${end}
			MSG
			)"

			unset list_array
			list_array=( $PROP "0" $"Load proprietary drivers" $OPEN "1" $"Load Open Source Drivers" )
			cancel_lbl=$"Cancel"'!zen-back'; ok_lbl=$"Select"'!zen-ok'; l_tail=0; w_head=0
			list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='500'; w_height='0'
			IFS=$(echo -en "\n\b")
			driver_swt=$(win_yad_list "${list_array[*]}")
			_exit=$?
			IFS=$ifs
			if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then [ $task_opt -gt 0 ] && exit 0 || menu_modif; fi
			use_open=$driver_swt
			if [ $use_open -ne $old_use_open ]; then
				nv_open_switch
				[ $task_opt -gt 0 ] && exit 0 || menu_modif
			fi
		fi
	fi
}

## PACKAGE MANAGING ###
manage_pcks(){ #
	hlp_tip=''
	w_text=$"$( cat <<-MSG


		${v}<u>Note</u>${end} : <i>In case of issue after restoration (ex: driver not loading),
		try command line tools in first place after reboot.
		Many distro auto reload desktop manager at boot. If you meet this issue,
		you have to disable the desktop manager with systemcl before operating
		with "zenvidia rebuild [version]" command line</i>.
		MSG
	)"
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(cat <<-HLP

		${sf}
		- <b>Remove downloaded packages</b>:
			Manage downloaded packages in Zenvidia directory.
		- <b>Backup tools</b>:
			Make a drivers and librairies backup of the current version.
		- <b>Restore tool</b>:
			Make a restoration of previously backed up drivers installation.
		- <b>Remove Nvidia and restore to default</b>:
			Remove completly Nvidia Drivers installation and restore default Nouveau drivers.
		${end}
		HLP
		)"
	fi
	unset list_array
	l_text=$"${j}${bf}Manage drivers packages${end}${end}$w_text$hlp_tip"
	list_array=( false 1 $"Remove downloaded package" false 2 $"Backup tools" false 3 $"Restore a backup" false 4 $"Remove Nvidia and restore to default" )
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b"); menu_packs=$(win_yad_list "${list_array[*]}")
	_exit=$?
	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; menu_modif; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && menu_modif
# 	IFS=$ifs
	case $menu_packs in
		"1") remove_pcks ;;
		"2") backup_tools ;;
		"3") restore_pcks ;;
		"4") remove_nvidia ;;
		*) menu_modif ;;
	esac
}
remove_pcks(){ #
	# list package in release directory
	unset rm_packs packs_list
	for pack in $(ls -1 $nvdl); do
		packs_list+=("false")
		packs_list+=("$pack")
	done
	w_text=$"$( cat <<-MSG
		${j}<b>Remove downloaded package</b>${end}
		Select on or more packages to be removed.
	MSG
	)"
	# win_yad_list
	l_text=$w_text
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='checklist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	IFS=$(echo -en "\n\b"); rm_packs=$( win_yad_list "${packs_list[*]}" )
	_exit=$?
	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; manage_pcks; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && manage_pcks
# 	IFS=$ifs
	# check that list not empty before proceed.
	if [ ${#rm_packs[*]} -gt 0 ]; then
		w_text=$"$( cat <<-MSG
			Selected to be removed:
			${j}${rm_packs[*]}${end} driver(s).

			Please, confirm.
		MSG
		)"
		# win_yad_warns
		warn_log="$w_text"
		qst=1; ok_lbl=$"Yes"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back' ; kill_yad=0
		win_yad_warns
		if [ $_exit = 0 ]; then
			for vers in ${rm_packs[@]}; do
				pack_version=$(printf "$vers"|sed -n "s/^.*-//g;p")
# 				vers_ref=$(printf "$pack_version"|sed -n "s/\.//p")
				ls -d /var/lib/dkms/nvidia/$pack_version &>/dev/null
				if [ $? = 0 ]; then
					w_text=$"$(cat <<-INFO
						${j}<b>$pack_version still exist in DKMS tree</b>.${end}

						Remove all associated package and directory ?
						<i>(All reference in $nv_root will be also removed if found)</i>

						Please, confirm.
					INFO
					)"
					# win_yad_warns
					warn_log="$w_text"
					qst=1; ok_lbl=$"Yes"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back' ; kill_yad=0
					win_yad_warns
					if [ $_exit = 0 ]; then
						if [ "$pack_version" = "$(version)" ]; then
							w_text=$"$( cat <<-WRN
							<b>WARNING</b>
							The associated directory you're about to remove is the same as the actually running.

							This action will fataly break ${j}$pack_version${end} installation
							You don't want to do this.

							Action skipped.
							WRN
							)"
							# win_yad_warns
							warn_log="$w_text"
							qst=0; ok_lbl='' ; cancel_lbl=$"I understand my mistake"'!zen-ok' ; kill_yad=0
							win_yad_warns
							manage_pcks
						else
							test -d $nv_root/nvidia.$pack_version && rm -Rf $nv_root/nvidia.$pack_version
# 							echo -e "$nv_root/nvidia.$pack_version DKMS REMOVE"
							rm -f $nvdl/nv-update-$pack_version
							$p_dkms remove nvidia/$pack_version --all
							test -d /var/lib/dkms/open-nvidia/$pack_version && $p_dkms remove open-nvidia/$pack_version --all
						fi
					fi
				else
					test -d $nv_root/nvidia.$pack_version && rm -Rf $nv_root/nvidia.$pack_version
					test -f $nvdl/nv-update-$pack_version && rm -f $nvdl/nv-update-$pack_version
# 					echo -e "$nv_root/nvidia.$pack_version REMOVE"
# 					echo -e "$nv_root/nvidia.$pack_version REMOVE"
				fi
			done
			# win_yad_warns
			warn_log=$"$( cat <<-MSG
				${v}<b>Driver(s)</b>:${end}
				${j}${rm_packs[*]}${end} package(s) removed.
			MSG
			)"
			qst=0; ok_lbl='' ; cancel_lbl=$"Ok"'!zen-ok' ; kill_yad=0
			win_yad_warns
			manage_pcks
		else
			manage_pcks
		fi
	else
		manage_pcks
	fi
}
remove_baks(){ #
	# list package in release directory
	unset rm_bak bak_list
	for back in $(ls -1 $nvbackup); do
		bak_list+=("false")
		bak_list+=("$back")
	done
	w_text=$"$( cat <<-MSG
		${j}<b>Remove backed up package</b>${end}
		Select on or more archives to be removed.
	MSG
	)"
	# win_yad_list
	l_text=$w_text
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='checklist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	IFS=$(echo -en "\n\b"); rm_bak=$( win_yad_list "${bak_list[*]}" )
	_exit=$?
	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; manage_pcks; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && manage_pcks
# 	IFS=$ifs
	# check that list not empty before proceed.
	if [ ${#rm_bak[*]} -gt 0 ]; then
		w_text=$"$( cat <<-MSG
			Selected driver(s) to be removed:
			${j}${rm_bak[*]}${end}

			Please, confirm.
		MSG
		)"
		# win_yad_warns
		warn_log="$w_text"
		qst=1; ok_lbl=$"Got it"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back' ; kill_yad=0
		win_yad_warns
		if [ $_exit = 1 ]; then
			manage_pcks
		else
			for vers in ${rm_bak[@]}; do
				test -f $nvbackup/$vers && rm -f $nvbackup/$vers
# 				echo -e "$nvbackup/$vers REMOVE"
			done
			warn_log$"${vB}Driver(s) Archive(s) removed.${end}"
			qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-ok' ; kill_yad=0
			manage_pcks
		fi
	else
		manage_pcks
	fi
}
remove_nvidia(){ #
## clean remove of nvidia packeges and nouveau restoration.
	## display warn before process. Zenity hare.
	w_text=$"$( cat <<-MSG
		${j}<b>NVIDIA driver installation will be completaly removed.</b>${end}
		Only Nouveau driver will usable after reboot.

		${y}Please, confirm.${end}
	MSG
	)"
	# win_yad_warns
	warn_log="$w_text"
	warn_image='zen-error'
	qst=1; ok_lbl=$"Got it"'!zen-ok' ; cancel_lbl=$"Panic Button"'!zen-back' ; kill_yad=0
	win_yad_warns
	if [ $_exit = 1 ]; then manage_pcks; fi

	y_text=$"${j}<b>Nvidia drivers complete removal</b>${end}"
	pulse=1; log=0; hold=0 ; hide_txt=0
	{ timeout=30 ;{
# 	echo -e "# Nvidia Removing ..."; sleep 2
	## nvidia version backup.
	if [ ! -f $nvbackup/nvidia.$(version).tar$zip_ex ]; then
		echo -e $"# Making security $(version) backup."; sleep 2
		y_text=$"Backup : ${j}$bak_version${end} backup archive creation"
		pulse=1; log=0; hold=0 ; hide_txt=0
		{ timeout=60;
		{ backup_old_version; } & eval lpid=$!; y_pulse; } | win_yad_progress
	fi
	echo -e $"# Nvidia Installation removal ..."; sleep 2
	systemd_dir=/usr/lib/systemd/system
	## then remove nvidia files.
		rm -f /etc/OpenCL/vendors/nvidia.icd
		rm -f /etc/ld.so.conf.d/nvidia-*
		test -f /etc/modprobe.d/open-NVIDIA.conf && rm -f /etc/modprobe.d/open-NVIDIA.conf
		test -f /etc/udev.d/rules.d/01-nvidia-driver.rules && rm -f /etc/udev.d/rules.d/01-nvidia-driver.rules
		rm -f /etc/modprobe.d/blacklist-nouveau.conf
		test -f /etc/modprobe.d/nvidia-drm.conf && rm -f /etc/modprobe.d/nvidia-drm.conf
		test -f /etc/modprobe.d/nvidia-blacklist.conf && rm -f /etc/modprobe.d/nvidia-blacklist.conf
		#rm -f /home/$(def_user)/.zenvidia/basic.conf
		rm -f /etc/X11/xorg.conf
		rm -f /etc/X11/xorg.conf.nvidia
		rm -f /etc/systemd/system/systemd-hibernate.service.wants
		rm -f /etc/systemd/system/systemd-suspend.service.wants
		rm -f /lib/modules/$KERNEL/$(module_dest_location)/nvidia*
		rm -f /lib/firmware/nvidia/$(version)
		rm -f $nv_root/nvidia
		rm -Rf $nv_root/nvidia.$(version)
		rm -f /usr/lib/systemd/system/nvidia-*
		test -f $systemd_dir/$(dm_serv).service.bak && cp -f $systemd_dir/$(dm_serv).service.bak $systemd_dir/$(dm_serv).service
 		[ -d /usr/$master$ELF_32/nvidia ]&& rm -Rf /usr/$master$ELF_32/nvidia
 		[ -d /usr/$master$ELF_64/nvidia ]&& rm -Rf /usr/$master$ELF_64/nvidia
		rm -f /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so
		rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*
		rm -Rf /usr/src/nvidia-$(version)
		if [ -d /usr/src/open-nvidia-$(version) ]; then
			rm -Rf /usr/src/open-nvidia-$(version)
		fi
		rm -f $install_dir/bin/nvidia-*
		if [[ $(ls -1 /usr/local/$master$ELF_32/libnvidia-*| grep -c $(version)) -gt 0 ]]; then
			rm -f $install_dir/$master$ELF_32/libnvidia-*
			rm -f $install_dir/$master$ELF_64/libnvidia-*
		else
			rm -f $install_dir/$master$ELF_64/libnvidia-*
 		fi
 		rm -Rf $install_dir/share/nvidia
 		rm -f /usr/share/nvidia
		rm -Rf /var/lib/dkms/nvidia
		[ -d /var/lib/dkms/open-nvidia ] && rm -Rf /var/lib/dkms/open-nvidia
		rm -Rf /var/lib/nvidia*
		rm -f $nvdir/version.txt

	echo -e $"# Libraries registry update."; sleep 2
	## retore library path to default.
	ldconfig
	echo -e $"# Grub update."; sleep 2
	test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='rhgb quiet'
	sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$grub_orig\"/" $grub_def
	$d_grub-mkconfig -o $grub_cfg
	echo -e $"# Perform modules dependencies and initramfs update."; sleep 2
	## restore kernel sys link to default.
	#exec_depmod : depmod -a
	progress_msg(){ echo -e $"# Depmod $KERNEL modules ($m sec.)"; }; m=0; do_slp=1
	progress "( exec_depmod "$KERNEL" )" #; rm -f $tmp_c
# 	progress_msg(){ echo -e $"# Exec $KERNEL modules init/reload ($m sec.)"; }; m=0; do_slp=1
# 	exec_initramfs
	echo -e $"# Exec $KERNEL modules reload "; sleep 2
	exec_mod_load
	}& eval lpid=$!; y_pulse; } | win_yad_progress
	w_text=$"$( cat <<-MSG
		${j}<b>NVIDIA driver installation is now completaly removed</b>${end}.

		Restart the computer for change to take effect.

	MSG
	)"
	# win_yad_warns
	warn_log="$w_text"
	#warn_image='zen-error'
	qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-undo' ; kill_yad=0
	win_yad_warns
	base_menu
}
backup_tools(){ #
	hlp_tip=''
	w_text=$"$( cat <<-MSG

		${v}Select the driver tool to use.${end}
	MSG
	)"
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-INFO

			${sf}
			<b>Make a backup</b> :
			- Back up the current isntalled driver installation.
			<b>Remove a backup</b> :
			- Remove archived installation driver packages.
			${end}
		INFO
		)"
	fi
	unset list_array
	l_text=$"${j}${bf}Backup manager${end}${end}$hlp_tip$w_text"
	list_array=( false 1 $"Make a backup" false 2 $"Remove a backup" )
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b"); menu_backup=$(win_yad_list "${list_array[*]}")
	_exit=$?
	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; manage_pcks; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && manage_pcks
# 	IFS=$ifs
	case $menu_backup in
		"1") backup_pcks ;;
		"2") remove_baks ;;
		*) manage_pcks ;;
	esac
}
backup_pcks(){ #
	bak_version=$(version)
	if [ -f $nvbackup/nvidia.$bak_version.tar$zip_ex ]; then
		warn_log=$"$(cat <<-MSG
			${j}$bak_version${end} is already backed up.
			No reason to do it again.

			Do you want to overwrite ?
		MSG
		)"
		qst=1; ok_lbl=$"Overwrite"'!zen-ok' ; cancel_lbl=$"No"'!zen-close' ; kill_yad=0
		win_yad_warns
		if [ $_exit = 1 ]; then menu_modif; fi
	else
		warn_log=$"$( cat <<-WRN
			You are going to backup ${j}$bak_version${end} driver installation

			Please, confirm.
		WRN
		)"
		qst=1; ok_lbl=$"Ok"'!zen-ok' ; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
		win_yad_warns
		if [ $_exit = 1 ]; then menu_modif; fi
	fi
	if [ $? = 0 ]; then
		y_text=$"Backup : ${j}$bak_version${end} backup archive creation"
		pulse=1; log=0; hold=0 ; hide_txt=0
		{ timeout=60;
		{ backup_old_version; } & eval lpid=$!; y_pulse; } | win_yad_progress
		manage_pcks
	else
		manage_pcks
	fi
}
restore_pcks(){ #
	alert_message(){
	# current version overwrite ALERT message
		warn_log=$"$( cat <<-WRN
			${jB}Driver install overwrite${end}

			${v}The backup you are going to restore is the same as the one used by the system.

			In previous driver version before <b>libglxserver_nvidia.so</b> usage, overwrite
			libGL.so crash the X server.
			To prevent data loss when restoring and others ugly deasagrements, Zenvidia wont
			replace the actual install by overwriting ${j}$res_version${end} over itself.

			If you really wish to overwrite, use the command line tool with desktop manager
			service disabled, closed the actual desktop session and press ctrl+alt+F[1-4].
			And type : <i>zenvidia restore [version]</i> (help will display)

			(<i>Desktop Manager, ex: systemctl disable $(dm_serv).service</i>)${end}
		WRN
		)"
		qst=0; ok_lbl='' ; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
		win_yad_warns
		base_menu
	}
	nv_build_options
	# list package in release directory
	from_install=0
	unset drive_list
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	nv_root_repo=$(ls -1 $nvbackup | grep "nvidia."| sed -n "s/.tar.*//p")
	nv_root_repo=$(ls -1 $nvbackup)
	for drive in $nv_root_repo; do
		drive_list+=("false")
		drive_list+=("$drive")
	done
	l_text=$"$( cat <<-MSG
		${j}<b>Restoration tool</b>${end}

		Driver actually loaded $(drv_installed).

		${v}Select the driver you want to restore.${end}
	MSG
	)"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	IFS=$(echo -en "\n\b"); drive_packs=$(win_yad_list "${drive_list[*]}")
	_exit=$?
	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; manage_pcks; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && manage_pcks
	# check that list not empty before proceed.
	if [[ $drive_packs ]]; then
		res_version=$(printf "$drive_packs"|sed -n "s/nvidia.\(.*[0-9]*\).tar.*$/\1/p")
		res_suffix=$(printf "$drive_packs"|sed -n "s/.*\.//p")
		ls /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so &>/dev/null
		if [ $? -eq 0 ]||[ ! -d $nv_root/$drive_packs ]; then
			## win_yad_warns
			warn_log=$"${v}Restoring ${j}$res_version${end} will replace actual${end} ${j}$(version)${end}."
			qst=1; ok_lbl=$"Yes, restore and replace"'!zen-ok' ; cancel_lbl=$"Abort"'!zen-back' ; kill_yad=0
			win_yad_warns
			if [ $_exit = 1 ]; then manage_pcks; fi
			## win yad options
			y_text=$"${v}Restore driver ${j}$res_version${end} and missing modules, if any.${end}"
			pulse=1; log=0; hold=0 ; hide_txt=0
			## win_yad_progress
			{ timeout=30 ;{
			echo -e $"# Restoring from nvidia.$res_version.tar$zip_ex..."; sleep 2
			if [ "$res_version" != "$(version)" ]; then
				## many libs are not overwriten, then remove previous before restore.
				rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$(version)
				rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$(version)
				rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$(version)
			fi
			restore_pcks_cmd
			progress_msg(){ echo -e $"# ($m sec.) - Rebuild modules dependencies (depmod)"; echo "$m"; }
			m=1; do_slp=1 ; progress "( exec_depmod "$KERNEL" )"
			## restore or rebuild drivers.
			$d_modinfo -F version nvidia -k $KERNEL | grep "$res_version" &>/dev/null
			if [ $? -eq 1 ]; then
				echo -e $"# Rebuilding missing $res_version drivers for $KERNEL kernel.."
				sleep 2
				rt_options
				if [ -d /usr/src/nvidia-$res_version ]||[ -d /usr/src/open-nvidia-$res_version ]; then
					restore_msg=$" (restored)"
					driver_logfile=$nvlog/$(version)-$KERNEL.log
					tmp_b=$(mktemp --tmpdir zn_vars.XXX)
					rem_tmp+=("rm -f $tmp_b")
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo -e $"# FAILURE : DKMS compilation ERROR !!"; sleep 2
						echo -e $"# FAILURE : See 'Update drivers or modules' > 'Update driver only (dkms/force)' to force build."; sleep 2
						trap "${rem_tmp[*]}" EXIT
						manage_pcks
					fi
				else
					echo -e $"# FAILURE : No source directory found for $res_version"; sleep 2
					trap "${rem_tmp[*]}" EXIT
					exit 1
					manage_pcks
				fi
				## exec_mod_load is useless here, a modprobe reload all doesn't catch change on kernel init.
				progress_msg=$"Rebuilding INITRAMFS (required)\t\t\t"
				progress_msg(){ echo $"# ($m sec.) - Rebuilding INITRAMFS"; echo "$m"; }; m=1; do_slp=1
				exec_initramfs
			else
				echo -e $"# Clear : $res_version modules checked in $KERNEL kernel."
				sleep 2
				echo -e $"# Restore $res_version modules system symlinks."
				# exec_mod_load seems to work here when archive modules are already build for active kernel.
				exec_mod_load
				## when it want, so fallback to initramfs.
# 				progress_msg(){ echo "# ($m sec.) - Rebuilding INITRAMFS"; echo "$m"; }; m=1; do_slp=1
# 				exec_initramfs
			fi
			## validate grub
			echo $"# Create GRUB conf for nouveau driver blacklisting and other options."; sleep 2
			$d_grub-mkconfig -o $grub_cfg 2>&1 | while read -r line; do echo "# * ${line}"; done
			## remove /opt/nvidia.prev_version for compatibility restore purpose
			## old_version var is use for compatibility with clean_old_version command.
			if [ "$res_version" != "$(version)" ]; then
				if [ -d $nv_root/nvidia.$(old_version) ]; then
					rm -Rf $nv_root/nvidia.$(old_version)
					clean_old_version
				fi
			fi
			} & eval lpid=$!; y_pulse; } | win_yad_progress
			restart_dm_warn
		else
			# current version overwrite ALERT message
			alert_message
		fi
	else
		manage_pcks
	fi
	trap "${rem_tmp[*]}" EXIT
	manage_pcks
}

## EDITION TOOLS ###
edit_script_conf(){
	## build list
	unset conf_list orig_conf cnf_list conf_base conf_chg
	old_conf=$(user_CF_DIR)/old_basic.conf
	IFS=$(echo -en "\n\b")
	conf_list=( $(cat $basic_conf | sed -En "s/^# (.*):.*/\1/p") )

	test -s $old_conf && rm -f $old_conf
	for conf_set in "${conf_list[@]}"; do
		cnf_text="$conf_set"
		setted=$(grep -A1 "$cnf_text" $basic_conf | sed -n "2p")
		set_id=$(echo "$setted"|sed -En "s/(.*)=(.*)/\1/p")
		set_val=$(echo "$setted"|sed -En "s/(.*)=(.*)$/\2/p"| sed -n "s/\"//g;p")
		if [[ "$set_val" =~ [0-9] ]]; then
			if [ $set_val -gt 0 ]; then setted='TRUE'; else setted='FALSE'; fi
			if [ $set_val -gt 1 ]; then set_val=$set_val; else set_val='none'; fi
		elif [[ "$set_val" =~ [Aa-Zz] ]]; then
			 setted='TRUE'
		fi
		cnf_list+=("$setted")
		cnf_list+=("$cnf_text")
		cnf_list+=("$set_id")
		cnf_list+=("$set_val")
		orig_conf+=("$setted;$set_id;$set_val")
	done
	help_tip=$"${v}\nDefine options and functions you would like to use of change\n${end}"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'
	ok_lbl=$"Apply"'!zen-ok'; list_type='checklist'; columns=4; col_name=( 'Set' 'Definition' 'Conf Set' 'Extra' )
	sel_col='0'; sep=';'; hid_col='3'; edit_col=4; col_tip=3; w_width='580'; w_height='500'; l_tail=0; w_head=1
	l_text=$"${j}${bf}Zenvidia Configuration${end}$help_tip${end}"

	conf_base=$( win_yad_list "${cnf_list[*]}" )

	## output : use help tip;hlp_txt;0;cairo;1;28 etc
	_exit=$?
	IFS=$ifs
	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then
# 		IFS=$ifs
		[ $task_opt -gt 0 ] && exit 0 || menu_modif
	fi
	## split ouput in readable list
	## and remove blank lines.
	conf_orig=( $orig_conf )

	## some previous set have to be saved before read and change.
	old_drm_modset=$drm_modset
	old_open_drv=$open_drv
	old_use_open=$use_open
	## modify new set value.
	for output in ${conf_base[@]}; do
			set=$(echo "$output"| cut -d';' -f3)
			value=$(echo "$output"| cut -d';' -f1)
			bis_value=$(echo "$output"| cut -d';' -f4)
			a=''
			# below filter is not necesary, but add for better reading understanding.
			if [[ "$value" =~ "TRUE" ]]; then value=1; else value=0; fi
			if [[ "$bis_value" ]]; then
				if [[ "$bis_value" != 'none' ]]; then
					[[ "$bis_value" =~ [Aa-Zz] ]] && a='\"'
					value=$bis_value
				else
					# lock special value to its list.
					set_list='xt_delay|render'
					if [[ "$set" =~ $set_list ]]; then
						# preset special bis_value below.
						[ "$set" = "xt_delay" ] && { [ $value = 1 ] && value=4 ;}
					fi
				fi
			fi
			if [ $(grep -E -c "$set=[\"]?$value[\"]?" $basic_conf) -eq 0 ];then
				sed -Ei "s/^($set)=.*$/\1=${a}$value${a}/" $basic_conf
				if [[ $set == "use_open" ]]; then export use_open=$value; fi
				eval $set=$value
			fi
	done
	## modifiy unset value.
	for input in ${orig_conf[@]}; do
		value=$(echo "$input"| cut -d';' -f1)
		set=$(echo "$input"| cut -d';' -f2)
		#extra=$(echo "$input"| cut -d';' -f3)
		if [ $(grep -c "$value.*$set" <<< ${conf_base[@]}) -eq 0 ]; then
			if [[ ! "$value" = "FALSE" ]]; then
				bis_value=$(echo "$input"| cut -d';' -f3)
				[[ "$bis_value" ]] && [[ "$bis_value" =~ [Aa-Zz] ]] && [[ "$bis_value" != 'none' ]] && a='\"' || a=''
				value=0
				# add special set below.
				[ "$set" = "render" ] && value='NONE'
				if [ $(grep -E -c "$set=[\"]?$value[\"]?" $basic_conf) -eq 0 ];then
					sed -Ei "s/^($set)=.*$/\1=${a}$value${a}/" $basic_conf
					if [[ $set == "use_open" ]]; then export use_open=$value; fi
					eval $set=$value
				fi
			fi
		fi
	done
	IFS=$ifs
	if [ $UID = 0 ]||[ $task_opt = 0 ]; then
		## if drm_modset is change nivdia modprobe options has to be change accordingly.
		if [ $drm_modset -ne $old_drm_modset ]; then
			y_text=$"Reconfigure grub and/or modules options sets"
			pulse=1; log=1; hold=0 ; hide_txt=1; [ $hold = 1 ] && win_log_options

			{ timeout=30; { blacklist_and_grub_set; } & eval lpid=$!; y_pulse; } | win_yad_progress
		fi
		if [ $use_open -ne $old_use_open ]; then
			qst=1; ok_lbl=$"Yes, apply"'!zen-ok'; cancel_lbl=$"No, I'll apply later"'!gtk-close'; kill_yad=0
			warn_log=$"$( cat <<-WRN
				${jB}Open Driver Switch${end}
				${v}<b>Open driver settings have been change</b>.

				Do you want to apply now ?${end}
			WRN
			)"
			win_yad_warns
			if [ $_exit = 0 ]; then
				## if open_drv is change, DKMS autoinstall boot time command has to be change by adding the blank file
				## 'no-autoinstall' in /etc/dkms directory. Method seems to work without issue except for package manager
				## udpate program that apprently need 'autoinstall all' to be set (fedora here).
				if [ $open_drv -ne $old_open_drv ]; then
					if [ $open_drv = 1 ]; then
						touch /etc/dkms/no-autoinstall
					else
						test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
					fi
				fi
				## if use_open is change, then apply open/close source switch.
				nv_open_switch
			fi
		fi
	else
		echo -e "old_drm_modset=$old_drm_modset" > $old_conf
		echo -e "old_open_drv=$old_open_drv" >> $old_conf
		echo -e "old_use_open=$old_use_open" >> $old_conf
		echo -e "drm_modset=$drm_modset" >> $old_conf
		echo -e "open_drv=$open_drv" >> $old_conf
		echo -e "use_open=$use_open" >> $old_conf
		if [ $old_open_drv -ne $open_drv ]||[ $old_use_open -ne $use_open ]; then
			qst=0; ok_lbl=''; cancel_lbl=$"Got it"'!zen-ok'; kill_yad=0
			warn_log=$"$( cat <<-WRN
				${jB}Driver Switch${end}
				${v}<b>Open driver settings have been change.</b>

				${j}You don't have superuser priviledges${end}.
				Please launch ${y}Open Driver switch${end} task bar menu entry to apply.${end}
			WRN
			)"
			win_yad_warns
		else
			rm -f $old_conf
		fi
		exit 0
	fi
	## then go back to Section Menu.
	[ $task_opt -gt 0 ] && exit 0 || menu_modif
}
edit_color_conf(){ #
	## color tmep file test preview
	if ! [ "$color_TMP" ]; then
	color_TMP=$(mktemp --tmpdir nv_color.XXXX)
	cat $color_conf > $color_TMP
	rem_tmp+=("rm -f $color_TMP")
	fi
	edit_color_gui(){
		test_text=$"$(
		cat <<-SPL
			DISPLAY PREVIEW :
			${rBB}TITLE${end}
			${j}${bf}Sub TTILE${end}${end}
			TEXT, comment and sub comment :
			Main is desktop default text color
			${v}Once upon a time in south west ? I don't care !${end}.
			${y}But I can alternate between East and West,
			but I still don't care ...${end}
			LOGS :
			${vB}Command cleared${end}		${gB}passed${end}		> ${y}log message values.${end}
			${vB}Command issue warning${end}	${jB}warning${end}	> ${y}log message values.${end}
			${vB}Command non fatal error${end} ${rB}error${end}		> ${y}log message values.${end}
		SPL
		)"
		w_text=$"$(
		cat <<-TXT
			${j}${bf}Basic font colors and style${end}${end}
			${v}Change GUI font colors to fit your desktop theme.${end}
		TXT
		)"
		sample=$"$(
		cat <<-SPL
			${rBB}TITLE${end}\t${j}${bf}Sub TTILE${end}${end}
			${v}main text${end} ${y}Log messages${end}
			${gB}Log cleared${end} ${jB}Log warnings${end} ${rB}Log Errors${end}
		SPL
		)"
		w_tip=$"$(
		cat <<-TIP
			${j}* NOTICE *${end}
			${sf}Colors will apply immediatly after validation.
			Do not forget Xterm only support a limited type of colors.
			${y}Xterm colors are also applied to Yad's text logging windows.${end}${end}
		TIP
		)"
		style1=$(grep -E -io "[a-z]*$" <<< $font1)
		style0=$(grep -E -io "[a-z]*$" <<< $font0)
# 		IFS=$(echo -en "\n\b")
		font_color=$(
		$d_yad --width=500 --height=600 --title "Zenvidia" --center \
			--scroll --vscroll-policy=auto --hscroll_policy=none \
			--window-icon=$img_zen_desktop --text "$w_text" \
			--form --separator="|" --item-separator=";" --borders=15 --field="":LBL '' \
			--field=$" Title and warning messages font color":CLR "$title" \
			--field=$" Sub window title font color":CLR "$sub" \
			--field=$" Comment font color\t\t":CLR "$main" \
			--field=$" Sub comment font color\t\t":CLR "$log_msg" \
			--field=$" Log clear font color\t\t":CLR "$log_grn" \
			--field=$" Log warning font color\t\t":CLR "$log_warn" \
			--field=$" Log error font color\t\t":CLR "$log_err" \
			--field=$" Sub Titles font type":FN "$font1 $style1 $size1" \
			--field=$" Normal font type":FN "$font0 $style0 $size0" \
			--field="":LBL '' \
			--field=$" Xterm and log forground color":CLR "$fg_xterm" \
			--field=$" Xterm and log background color":CLR "$bg_xterm" \
			--field="":LBL '' \
			--field="$w_tip":LBL '' \
			--field="":LBL '' \
			--field="$test_text":LBL '' \
			--button=$"Preview"';zen-refresh;'$"Reload with newly setted values"':2' \
			--button=$"Abort"';zen-close:1' --button=$"Done"';zen-ok:0'
		)
		out=$?
		color_temp=$color_conf
		case $out in
			0) trap "${rem_tmp[*]}" EXIT; menu=menu_modif ;;
			1|252) trap "${rem_tmp[*]}" EXIT; base_menu ;;
			2) menu="$@ edit_color_gui" ; color_temp=$color_TMP ;;
		esac
# 		if [ $out = 0 ]; then
# 			menu=menu_modif
# 		elif [ $out = 1 ]; then
# 			base_menu
# 		elif [ $out = 2 ]; then
# 			menu="$@ edit_color_gui"
# 		fi
# 		if [ $out -eq 2 ]; then
# 			color_temp=$color_TMP
# 		else
# 			color_temp=$color_conf
# 		fi
		IFS=$(echo -en "\n\b")
		unset input_colors output_colors output_conf
		input_colors=$(cat $color_temp | cut -d'=' -f1)
		output_colors=( $(echo -e "$font_color"| sed -En "s/^\||[\|]{3}$//g;s/\|/\n/g;p") )
		C=0
		for type in ${input_colors[@]}; do
			if [[ $type =~ font* ]]; then
				font_n=$(echo "$type"| grep -o "[0-9]")
				eval style=\$'style'$font_n
				new_font=$(echo "${output_colors[$C]}"|grep -E -io ".*[a-z]")
				new_style=$(echo "$new_font"|awk '{print $3}')
				if [[ $new_style == '' ]]; then stylish=' '$style; else stylish=''; fi
				output_conf+=("$type;$new_font$stylish")
				shift 0
			elif [[ $type =~ size* ]]; then
				output_conf+=("$type;$(echo "${output_colors[$C]}"|grep -E -o "[0-9].*$")")
				((C++))
			else
				output_conf+=("$type;${output_colors[$C]}")
				((C++))
			fi
		done
		for sets in ${output_conf[@]}; do
			setting=$(printf "$sets"| cut -d';' -f1)
			value=$(printf "$sets"| cut -d';' -f2)
			if [ $(grep -c "$setting='$value'" $color_temp) -eq 0 ]; then
				sed -Ei "s/^($setting)=.*$/\1='$value'/g" $color_temp
			fi
		done
		IFS=$ifs
		if [ $out -eq 2 ]; then
			. $color_temp
			zen_colors
		fi
		${menu}
	}
	edit_color_gui
}
## This section is dedicated to Xorg config edition.
# Here the full xorg editor GUI with specific functions.
x_check_nv_doc(){
	doc_brief=$( cat <<-TIP
		<b>NVIDIA $section TIP</b> :
		${y}$(sed -n "s/<dt>/\n*start*/;s/<\/dd>/*end*\n/g;/*start*/,/*end*/{;s/<[a>]*>//;/<a.*[title]?/,/[title=]?\".*\">/d;\
		/<div.*/,/<\/div>/d;s/<[^>]*\(>\|$\)//g;/Option.*\"${1}\"/,/*end*/{s/^.*>\|&[a-z]*;/ /g;p}}" $docs \
		| sed '1,2d;/\".*\"/d;/*end*/,/$/d')${end}
	TIP
	)
	if [ $(echo $doc_brief | wc -w) -gt 6 ]; then
		echo "$doc_brief"
	fi
# 	echo "*1* ${vendor_id} $DEV TIP -- $(echo $doc_brief | wc -w)" >> /home/mike/wc.txt
}
x_check_man(){ #
	# -D efface les variables d'environement de bases.
	if [[ "$option_type" =~ 'Option' ]]; then
		doc_brief=$(cat <<-TIP
			<b>$DEV TIP</b> :

			${y}$(man --nh --nj -P cat ${1} | col -b | sed -En "s/(\t)/ /g;s/([\ ]{2,10})/ /g;p" | grep -A${3} "${4}" | \
			sed -n "/^ Option ${5}${2}${5}.*$/,/^ [A-Z]\w* ${5}.*${5}.*$/p"|sed '1d;$d' | tr -d '\n')${end}
			TIP
		)
	else
		doc_brief=$(cat <<-TIP
			<b>$DEV TIP</b> :

			${y}$(man --nh --nj -P cat ${1} | col -b | sed -En "s/(\t)/ /g;s/([\ ]{2,10})/ /g;p" | grep -A${3} "${4}" | \
			sed -En "/^ ${2} ${5}.*${5}.*$/,/^ [A-Z]\w* ${5}.*${5}.*$/p"| sed '1d;$d' | tr -d '\n')${end}
			TIP
		)
	fi
	if [ $(echo $doc_brief | wc -w) -le 6 ]; then
		echo -e $"${r}$DEV TIP not found, undocumented or obsolete option.${end}"
	else
		echo "$doc_brief"
	fi
# 	echo -e "*2* ${vendor_id} $DEV TIP -- $(echo $doc_brief | wc -w)" >> /home/mike/wc.txt # TEST
}
x_yad_extract(){
	xorg_cfg_mod=$xorg_cfg
	cp -f $xorg_cfg $xorg_cfg~
	[ -f $xorg_conf_log ] || touch $xorg_conf_log && echo '' > $xorg_conf_log #rm -f $xorg_conf_log
	for d in ${device_section_list[@]}; do
	unset device_section_orig
	device_c=$(cut -d'|' -f1 <<< $d)
	section_c=$(cut -d'|' -f2 <<< $d)
 	device_section_orig=$(grep "$d" $tmp_orig)
 	device_section_file=$xorg_tmp_dir/$device_c.$section_c.*
		for c in ${device_section_orig[@]}; do
			device=$device_c
			section=$section_c
			## study one line in orig config
			options=$(cut -d';' -f2 <<< $c)
			option_def=$(awk -F '|' '{print $2"|"$3}' <<< $options)
			setted=$(cut -d'|' -f1 <<< $options)
			option_type=$(cut -d'|' -f2 <<< $options)
			option=$(cut -d'|' -f3 <<< $options)
			value=$(cut -d'|' -f4 <<< $options)
			# define if value exist and is quoted. Then set quote.
			[ "$value" != '' ] && a='"' || a=''
			if	[[ "$value" =~ [0-9]{2}$|[0-9]\ [0-9]$ ]]; then
				a=''
			fi
			# for log only
			[[ "$option_type" =~ Option|Screen|Inactive ]] && b='"' || b=''
			## config output is always TRUE.
			## does the section been modified ? FALSE/TRUE has changed.
			line_c=$(grep "$option_def" $device_section_file)
# 			setted_c=$(cut -d'|' -f1 <<< $line_c
			option_type_c=$(cut -d'|' -f2 <<< $line_c)
			option_c=$(cut -d'|' -f3 <<< $line_c)
			value_c=$(cut -d'|' -f4 <<< $line_c)
			if [ $(grep -c "$option_type_c.*$option_c.*$value_c" $xorg_cfg_mod ) -gt 0 ]; then
# 			if [ $(grep "$d" $tmp_orig | grep -c "$options") -eq 1 ]; then
				if [ $(grep -c "$options" $device_section_file) -eq 0 ]; then
					if [ $(grep -c "$option_def" $device_section_file) -gt 0 ]; then
						# TRUE
# 						line_c=$(grep "$option_def" $device_section_file)
# 	# 						setted_c=$(cut -d'|' -f1 <<< $line_c
# 						option_type_c=$(cut -d'|' -f2 <<< $line_c)
# 						option_c=$(cut -d'|' -f3 <<< $line_c)
# 						value_c=$(cut -d'|' -f4 <<< $line_c)
						# does the line have "Option" ?


						if [[ "$option_type_c" =~ Option|Screen|Inactive ]]; then
# 						if [[ "$option_type_c" =~ "Option" ]]; then
							# write default 3 argument option line.
							option_line_c="   $option_type_c\t\"$option_c\" ${a}$value_c${a}"
						else
							# write 2 or 1 arguments line.
							option_line_c="   $option_c\t${a}$value_c${a}"
						fi
						log_on='FALSE to TRUE' # we write
						sed -Ei "s|^[#]?.*${option_type}.*${b}${option}${b}.*$|${option_line_c}|" $xorg_cfg_mod
					else
						# FALSE
						if [ "$setted" == "FALSE" ]; then
							# write '#' at the beginnig of the line.
							option_line_c="#   $option_type ${b}$option${b} ${a}$value${a}"
							log_on='ALREADY FALSE' # we don't write, log only.
						else
							if [ "$option_type" ]&&[[ "$option_type" =~ Option|Screen|Inactive ]]; then
							option_line_c="#   $option_type\t${b}$option${b} ${a}$value${a}"
							else
							option_line_c="#   $option\t${a}$value${a}"
							b=''
							fi
							log_on='TRUE to FALSE' # we write
							sed -Ei "s|^.*${option_type}.*${b}${option}${b}.*$|${option_line_c}|" $xorg_cfg_mod
						fi
					fi
					## study per line in new config from the one line orig config.
					echo -e "$log_on $device_c $section_c :\t$option_line_c" >> $xorg_conf_log # log only.
				else
					# log only
					if [ "$setted" == "FALSE" ]; then prefix='#'; else prefix=''; fi
					option_line="$prefix   $option_type ${b}$option${b} ${a}$value${a}"
					echo -e "ALREADY TRUE $device $section :\t$option_line" >> $xorg_conf_log # we don't write, log only.
				fi
# 			else
# 				echo -e "LINE DOESN'T EXIST, ADDING"
			fi
		done
	done
}
x_yad_tab(){ #
	## tab window
		for para in ${device_options[@]}; do
			unset section_list options_list
			section=$(cut -d';' -f1 <<< $para)
			section_names=$(cut -d';' -f2 <<< $para)
			track=$(cut -d';' -f3 <<<$para)
			if [ $(grep -c "$section" $xorg_cfg) -gt 0 ]; then
			# create and trap tmp files.
# 			tmp=$(mktemp --tmpdir $xorg_tmp_dir/$device.$section.$n.XXXX)
			tmp=$(mktemp $xorg_tmp_dir/$device.$section.$n.XXXX)
# 			rem_tmp+=("rm -f $tmp")
# 			trap "rm -f $tmp" EXIT
				# catch Xorg Section containing 'word' or without.
				if [ $track -gt 0 ]; then
					section_block=$(sed -n -e '/Section "'$section'"/,/EndSection/{H;$!d;}' \
					-e 'x;/Identifier.*Device'$e'/!d;/Section/,/EndSection/p' $xorg_cfg)
				else
					section_block=$(sed -En '/Section "'$section'"/,/EndSection/p' $xorg_cfg)
				fi
				section_list=( $(tr ',' '\n' <<< $section_names) )
				## catch array vnd_id variable
				vendor_id=${5}
				for section_line in ${section_list[@]}; do
# 					if [ $(grep -c "$section_line" <<< $section_block) -gt 0 ]; then
					if [ $(grep -wc "$section_line" <<< $section_block) -gt 0 ]; then
						unset option_line # options_list
# 						option_line=( $(grep "$section_line" <<< $section_block) )
						option_line=( $(grep -w "$section_line" <<< $section_block) )
						for line in ${option_line[@]}; do
							if [[ $line =~ \#{1}.*$ ]]; then setted='FALSE'; else setted='TRUE'; fi
							option_type=$section_line
							option_reg="^.*$section_line.*(\".*\") (\".*\")$"
							screen_reg="^.*$section_line [0-9].*(\".*\") (.*)$"
							option_bis_reg="^.*$section_line.*(\".*\")$"

							if [[ "$line" =~ $option_reg ]]; then
								option=$(echo "$line"| sed -En "s/$option_reg/\1/p"|sed -n "s/\"//g;p")
								value=$(echo "$line"| sed -En "s/$option_reg/\2/p"|sed -n "s/\"//g;p")
							else
								if [[ "$line" =~ $screen_reg ]]; then
									option_type=$(echo "$line"| sed -En "s/^.*(Screen [0-9]).*$/\1/p")
									option=$(echo "$line"| sed -En "s/$screen_reg/\1/p"|sed -n "s/\"//g;p")
									value=$(echo "$line"| sed -En "s/$screen_reg/\2/p"|sed -n "s/\"//g;p")
								elif [[ "$line" =~ $option_bis_reg ]]; then
									option=$(echo "$line"| sed -En "s/$option_bis_reg/\1/p"|sed -n "s/\"//g;p")
									value=''
								else
									option_type=''
									option=$section_line
									value=$(echo "$line"| awk '{print $2}'|sed -n "s/\"//g;p")
								fi
							fi
# 							if [[ $line =~ \#{1}.*$ ]]; then setted='FALSE'; else setted='TRUE'; fi
# 							option_type=$section_line
# 							[[ "$setted" =~ 'FALSE' ]] && word_count=$(printf "$line"|wc -w ) || word_count=$(printf "$line"|wc -w)
# 							option_reg="^.*$section_line.*(\".*\") (\".*\")$"
# 							screen_reg="^.*$section_line [0-9].*(\".*\") (.*)$"
# 							option_bis_reg="^.*$section_line.*(\".*\")$"
#
# 							if [[ "$line" =~ $option_reg ]]; then
# 								option=$(echo "$line"| sed -En "s/$option_reg/\1/p"|sed -n "s/\"//g;p")
# 								value=$(echo "$line"| sed -En "s/$option_reg/\2/p"|sed -n "s/\"//g;p")
# 							else
# 								if [[ "$line" =~ $screen_reg ]]; then
# 									option_type=$(echo "$line"| sed -En "s/^.*(Screen [0-9]).*$/\1/p")
# 									option=$(echo "$line"| sed -En "s/$screen_reg/\1/p"|sed -n "s/\"//g;p")
# 									value=$(echo "$line"| sed -En "s/$screen_reg/\2/p"|sed -n "s/\"//g;p")
# 								elif [[ "$line" =~ $option_bis_reg ]]; then
# 									option=$(echo "$line"| sed -En "s/$option_bis_reg/\1/p"|sed -n "s/\"//g;p")
# 									value=''
# 								else
# 									option_type=''
# 									option=$section_line
# 									value=$(echo "$line"| awk '{print $2}'|sed -n "s/\"//g;p")
# 								fi
# 							fi
							options_list+=("$setted")
							options_list+=("$option_type")
							options_list+=("$option")
							options_list+=("$value")

							## look for tip in Nvidia html file (vnd_id set)
							if [[ "8086" =~ ${vendor_id} ]]; then
								key="The following driver Options are supported"; lines='230'
							elif [[ "1002|1022" =~ ${vendor_id} ]]; then
								key="The following driver Options are supported"; lines='80'
							elif [[ "layout" =~ ${vendor_id} ]]; then
								if [[ "$section" =~ "ServerLayout" ]]; then
									key="SERVERFLAGS SECTION"; lines='160'
								elif [[ "$section" =~ "InputDevice" ]]; then
									key="INPUTDEVICE SECTION"; lines='140'
								elif [[ "$section" =~ "Files" ]]; then
									key="FILES SECTION"; lines='80'
								fi
							fi
							if [[ "$section" =~ "Screen" ]]; then
								key="SCREEN SECTION"; lines='105'
							fi
							if [[ "10de|layout" =~ "${vendor_id}" ]]; then
								#multi_sec=${5}
								DEV='NVIDIA '$section
								o_tip=$(x_check_nv_doc "$option")
								if [ $(echo $o_tip | wc -w) -le 6 ]; then
									o_tip=$"$(
										cat <<-TIP
											${r}$DEV TIP not found, undocumented or obsolete option.${end}
										TIP
									)"
									if [[ "${5}" =~ "layout" ]]; then
										DEV='XORG '$section
										o_tip=$(x_check_man "xorg.conf" "$option" "$lines" "$key" '"')
									fi
									if [[ "$section" =~ "Screen" ]]; then
										DEV='NVIDIA '$section
										o_tip=$(x_check_man "xorg.conf" "$option" "$lines" "$key" '')
									fi
								fi
							fi
							if [[ "8086|1002|1022" =~ "${vendor_id}" ]]; then
								if [ $opti_preset = 1 ]; then
									if [[ "8086|1002|1022" =~ "${vendor_id}" ]]; then
										DEV='OPTIMUS '$section
										o_tip=$(x_check_man "modesetting" "$option" "$lines" "$key" '"')
									fi
								else
									if [[ "${5}" =~ "8086" ]]; then
										DEV='INTEL '$section
										o_tip=$(x_check_man "intel" "$option" "$lines" "$key" '"')
									elif [[ "1002|1022" =~ "${vendor_id}" ]]; then
										DEV='AMD '$section
										o_tip=$(x_check_man "amdgpu" "$option" "$lines" "$key" '"')
									fi
								fi
								if [ $(wc -l <<< $o_tip) -le 1 ]; then
									if [[ "$section" =~ "Screen" ]]; then
										DEV='iGPU '$section
										o_tip=$(x_check_man "xorg.conf" "$option" "$lines" "$key" '')
									fi
								fi
							fi
							options_list+=("$o_tip")
							echo -e "$device|$section;$setted|$option_type|$option|$value" >> $tmp_orig
							[[ "${device_section_list[*]}" =~ "$device|$section" ]] || device_section_list+=("$device|$section")
						done
					fi
				done
				if [ ${#options_list[*]} -gt 0 ]; then
					eval t=\$${4}
					tab_text=$"<b>${3} :</b> ${c}${2}${end} - Section \"$section\""
					## create tab.
					yad --plug=${1} --tabnum="$t" --list --checklist --editable --editable-cols=4 --text="$tab_text" \
					--column=1 --column=2 --column=3 --column=4 --column=5 --no-headers \
					--tooltip-column=5 --hide-column=5 "${options_list[@]}" > $tmp &
					((${4}++))
					[ "${4}" == 'n' ] && tab_names+=(--tab="${sf}${c}$(echo -e "${2}\n$section")${end}${end}")
				fi
			fi
		done
# 		trap "${rem_tmp[*]}" EXIT
}
x_yad_block(){ #
	docs=$nvi_docs/html/xconfigoptions.html
	xorg_conf_log=$(user_CF_DIR)/xorg_cfg.log
	unset device_options tab_names rem_tmp device_section_list
	## create a temp dir to remove at the end of the porcess.
	xorg_tmp_dir=$(mktemp -d --tmpdir xorg.conf.XXXX)
	## main window
	server_sections="ServerLayout;Screen,Inactive,Option;0|Files;ModulePath;0|InputDevice;Option;0"
	device_sections="Device;Option;1|Screen;Option,DefaultDepth;1"
	IFS=$(echo -en "\n\b")
	w_text=$"$( cat <<-DEVICE
		${j}${bf}Graphic Display Configuration${end}${end}
		<i>From Xorg configuration file ($xorg_cfg)</i>
		${sf}
		<b>Full documentation can be found in</b> :
		> ${j}Help and Documentation${end} > ${j}Documentation Manual${end} - Appendic B. <i>X Config Options</i>
		${end}
		Device(s) detected :
		${y}${dev_name[*]}${end}
	DEVICE
	)"
	unset tab_names
	KEY=$RANDOM
	n=1
	device_options=($(tr '|' '\n' <<< $server_sections ))
	## xorg server part analyse.
	# create and trap temp file.
# 	tmp_orig=$(mktemp --tmpdir $xorg_tmp_dir/xorgconf.orig.XXXX)
	tmp_orig=$(mktemp $xorg_tmp_dir/xorgconf.orig.XXXX)
#  rem_tmp+=("rm -f $tmp_orig")
	trap "rm -Rf $xorg_tmp_dir" EXIT
	c='<span color="#16BBC1">' # BLUE
	device='Xorg'
# 	logfile=$(mktemp --tmpdir brief.logfile.XXXX) # DEBUG
# 	{
	x_yad_tab "$KEY" "Xorg" $"Xorg Server" "n" "layout"
# 	} >$logfile 2>&1
	unset device_options options_orig
	device_options=($(tr '|' '\n' <<< $device_sections ))
	## device part analyses.
	for e in ${dev_n[@]}; do
# 		[ $e = 0 ] && c='<span color="#DE8400">' # YELLOW #FF9800
# 		[ $e = 1 ] && c='<span color="#2CA900">' # LIGHTGREEN #2CA900
# 		[ $e = 2 ] && c='<span color="#006BDE">' # LIGHTBLUE
		[ $e = 0 ] && c=${j} # YELLOW #FF9800
		[ $e = 1 ] && c=${v} # LIGHTGREEN #2CA900
		[ $e = 2 ] && c=${y} # LIGHTBLUE
		device='Device'$e
		x_yad_tab "$KEY" "${dev_name[$e]}" "${vnd[$e]}" "n" "${vnd_id[$e]}"
	done
	cancel_lbl=$"Cancel"'!zen-close' ; ok_lbl=$"Ok"'!zen-ok'
	buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" )
	yad --key=$KEY --notebook --tab-pos=top --width=500 --height=400 --title="Zenvidia" --window-icon=$img_zen_desktop \
	"${tab_names[@]}" --center --borders=15 --text="$w_text" ${buttons[*]}
	if [ $? = 0 ]; then
		x_yad_extract
	fi
	if [ $from_install = 0 ]; then
 		rm -Rf $xorg_tmp_dir
#  		trap "${rem_tmp[*]}" EXIT
		edit_xorg_conf
	fi
}
# Here simple xorg editor and menu.
edit_xorg_full_text(){
	IFS=$(echo -en "\n\b")
	log_txt="${j}Edit Xorg config file${end}\nThe <b>Save</b> button will overwrite the existing file."
	log_brief=$xorg_cfg
	cancel_lbl="Exit!zen-back"; ok_lbl="Save!zen-ok"
	w_formatted=1; w_wrap=1; w_width='620'; w_height='400'; all_btn=1; colors=1
	edit_xorg=$(win_yad_text "$log_brief" "--editable")
	IFS=$ifs
	if [ $( wc -l <<< $edit_xorg) -gt 1 ]; then
		echo -e "$edit_xorg\n" > $xorg_cfg
	fi
	[ $task_opt -gt 0 ] && exit 0 || edit_xorg_conf
}
edit_xorg_conf(){ #
	xorg_cfg=/etc/X11/xorg.conf.nvidia
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP
		${sf}
		- <b>Edit full Xorg (GUI)</b>
			Edit all non sensitives Xorg option and sets in tabed GUI.
		- <b>Edit full Xorg (text)</b>
			Edit Xorg configuration file in a text editor.
		- <b>Manage NVIDIA Options only</b>
			Edit NVIDIA device only options in a GUI.
		- <b>Execute Xorg auto config</b>
			Re-create Zenvidia Xorg configuration file creation automation.
		${end}

		HLP
		)"
	fi
	unset list_array
	list_array=( TRUE 1 $"Edit full Xorg (GUI)" FALSE 2 $"Edit full Xorg (text)" FALSE 3 $"Execute Xorg auto config" )
	l_text=$"${j}${bf}Edit Xorg Config File${end}${end}\n${v}Edit or manage Xorg config and options.${end}\n$hlp_tip"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'
	ok_lbl=$"Select"'!zen-ok'; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b"); menu_xorg=$(win_yad_list "${list_array[*]}")
 	_exit=$?
 	IFS=$ifs
	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then
# 		IFS=$ifs
		if [ $from_install = 0 ]; then
			[ $task_opt -gt 0 ] && exit 0 || menu_modif
		fi
	fi
# 	IFS=$ifs
	case $menu_xorg in
		"1") x_yad_block ;;
		"2") edit_xorg_full_text;;
		"3") x_tmp=$(mktemp --tmpdir zn_xorg.XXXX); rem_tmp+=("rm -f $x_tmp"); xorg_conf;
			  xorg_check; trap "${rem_tmp[*]}" EXIT; edit_xorg_conf
			;;
	esac
}
edit_distro_conf(){ #
	## warn about no config file
	warn_log=$"$(cat <<-WRN
	${j}<b>You are going to modify $plug_version configuration file</b>${end}

	Variables and datas from this file are very sensitives and could potentialy
	breaks Zenvidia.

	${r}<i>Are you sure about what you are doing ?</i>${end}

	WRN
	)"
	# warn
	qst=1; ok_lbl=$"I live dangerously"'!zen-ok' ; cancel_lbl=$"Well, I'm finally a coward"'!zen-back' ; kill_yad=0
	win_yad_warns
	if [ $_exit = 1 ]; then menu_modif; fi
	## edit config file.
	log_brief="$(user_CF_DIR)/$plug_conf"
	IFS=$(echo -en "\n\b")
	log_txt=$"${j}<b>$plug_version configuration file</b>${end}"
	cancel_lbl=$"Abort (panic button)"'!zen-back'; ok_lbl=$"Write"'!zen-ok'
	w_formatted=1; w_wrap=1; w_width='640'; w_height='400'; all_btn=1; colors=0
	edit_plug_conf=$(win_yad_text "$log_brief" "--editable")
	IFS=$ifs
	if [ $( wc -l <<< $edit_plug_conf) -gt 1 ]; then
		echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf
	fi
	menu_modif
}
read_help(){ # trad doc ?
	IFS=$(echo -en "\n\b")
	log_brief="$zen_docs/HELP.txt"
	log_txt=$"${j}<b>Zenvidia help text</b>${end}"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=''
	w_formatted=1; w_wrap=1; w_width='720'; w_height='400'; all_btn=0; colors=1
	win_yad_text "$log_brief"
	IFS=$ifs
	[ $task_opt -gt 0 ] && exit 0 || menu_manage
}
read_about(){ #
	log_txt=$"$(cat <<-ABOUT
		${v}${j}${bf}About Zenvidia${end}${end}
		Version :	${y}$(cat $(user_CF_DIR)/zen_version)${end}
		License :	${y}LGPLv3${end}
		Author :	${y}@PirateProd - 2020-2023${end}
		website :	${y}$zenvidia_git${end}
		contact :	${y}wildtruc@noneltd.net${end}
		${end}
	ABOUT
	)"
	IFS=$(echo -en "\n\b")
	log_brief="$zen_docs/ABOUT.txt"
	log_txt="$log_txt"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=''
	w_formatted=1; w_wrap=1; w_width='700'; w_height='400'; all_btn=0; colors=1
	win_yad_text "$log_brief" "--image=$img_zen_bar"
	IFS=$ifs
	[ $task_opt -gt 0 ] && exit 0 || menu_manage
}
read_nv_help(){ #
	IFS=$(echo -en "\n\b")
	if [[ ${#chapter_index[@]} -le 1 ]]; then
		unset chapter_index chapters_list
		chapters_list=$(sed -En "/TABLE OF.*$/,/1A. ABOUT.*$/p" $nvi_docs/README.txt | sed -n "/^___.*$/,/^___.*$/p"| grep -E "^Chapter|^Appendix")
		for chapter in ${chapters_list[@]}; do
			chapter_index+=("FALSE")
			chapter_index+=("$chapter")
		done
	fi
	## display index first
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
	ok_lbl=$"Select"!'zen-ok'; l_tail=0; w_head=0
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='600'; w_height='420'
	l_text=$"${j}${bf}Nvidia Documentation ${end}$help_tip${end}"

	index=$( win_yad_list "${chapter_index[*]}" )
	_exit=$?
	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then [ $task_opt -gt 0 ] && exit 0 || base_menu; fi
	if [ "$index" != '' ]; then
		chap_start=$(printf "$index"| sed -n "s/(.*)//g;p")
		## then if chapter tag is not empty, dispaly chapter.
		chap_end=$(grep -E -A1 "$chap_start" <<< $chapters_list | sed -n 2p | sed -n "s/(.*)//g;p")
		chap_brief="$chap_start : "$(sed -En "/^$chap_start/,/^$chap_end/p" $nvi_docs/README.txt | sed -En "/^____/,/^____/p")

		log_txt=$"${j}Nvidia $(version) Documentation - ${y}$chap_start${end}${end}"
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'
		ok_lbl=$"Back to index"'!zen-undo'
		w_formatted=0; w_wrap=1; w_width='620'; w_height='400'; all_btn=1; colors=1

		win_yad_text "$chap_brief"
		if [ $_exit -eq 1 ]; then
			IFS=$ifs
			[ $task_opt -gt 0 ] && exit 0 || menu_manage
		else
			IFS=$ifs; read_nv_help
		fi
 	else
		IFS=$ifs
		[ $task_opt -gt 0 ] && exit 0 || menu_manage
 	fi
}
read_changelog(){ #
	unset entry_list entrylog_list
	IFS=$(echo -en "\n\b")
	relist_title=''; catch_title=''; txt_val=0
	brief(){
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$( cat <<-BRIEF
			$log_brief
			BRIEF
			)
		else
			log_brief=$(echo -e $"\n\nNothing to display here.\n\nLog file empty.")
		fi
		log_txt=$"${bf}${j}Changelog : ${y}$entrylog${end}${end}${end}"
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
		ok_lbl=$"Back to index"'!zen-undo'
		w_formatted=0; w_wrap=1; w_width='600'; w_height='400'; all_btn=1; colors=1
		win_yad_text "$log_brief"
		if [ $_exit -eq 1 ]; then
			IFS=$ifs
			[ $task_opt -gt 0 ] && exit 0 || menu_manage
		else
			if [[ $relist_title != '' ]]; then
				relist
			else
				relist_title=''
				IFS=$ifs ; read_changelog
			fi
		fi
	}
	relist(){
		if [[ $relist_title != '' ]]; then
			cancel_lbl=$"Back to list"'!zen-undo'
			ok_lbl=$"Read"'!zen-ok'
		else
			[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
			ok_lbl=$"Select"'!zen-ok'
		fi
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			for log_line in ${entry_list[@]}; do
				entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
			done
		fi
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; l_tail=0; w_head=0
		w_width='550'; w_height='420'
		l_text=$"${j}${bf}Nvidia Change Logs list $relist_title${end}${end}"
		entrylog=$( win_yad_list "${entrylog_list[*]}" )
		_exit=$?
		if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then
			IFS=$ifs
			if [[ $relist_title != '' ]]; then
				read_changelog
			else
				[ $task_opt -gt 0 ] && exit 0 || menu_manage
			fi
		else
			if [[ $entrylog != '' ]]; then
				if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
					log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
					log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
					sed -n "s/^===.*$//g;p")
				else
					log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
					[ "$log_end" != "" ] || log_end="====.*$"
					log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
					sed -n "s/^===.*$//g;p")
				fi

				if [[ $relist_title != '' ]]; then
					if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
						log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
						sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
					else
						log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
						sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
					fi
					brief
				else
					log_brief=$(cat <<< $log_list | sed -En "s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}" )
				fi
			else
				IFS=$ifs
				[ $task_opt -gt 0 ] && exit 0 || menu_manage
			fi
		fi
	}
	entry_list=$(grep -E -e "=====" $zen_docs/NVIDIA_Changelog | sed -En "s/[ ]?={8}[ ]?//g;p")
	relist
	if [[ $log_list =~ .*[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
		unset entry_list entrylog_list entry_catch
		if [ $(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$") -gt 0 ]; then
			txt_key="$(cat <<< $log_brief | sed -n '1p' | grep "\* [A-Z].*$"|sed -n "s/\* //g;p")"
			txt_val=$(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$")
			entry_list+=("First $entrylog Log")
		fi
		entry_catch=$(cat <<< $log_list | grep -E ".*[0-9]{4}-[0-9]{2}-[0-9]{2}"|sed -En "s/ ([0-9]{4})/\1/g;p")
		for catch in ${entry_catch[*]}; do
			entry_list+=("$catch")
		done
		relist_title=": ${y}$entrylog${end}"; catch_title=$entrylog
		relist
	else
		relist_title=''; catch_title=''
		brief
	fi
	IFS=$ifs
}
read_zen_changelog(){ #
	unset entry_list entrylog_list
# 	IFS=$(echo -en "\n\b")
	if [[ "$notif_desk_opt" =~ 'z' ]]; then log_from_local=1; else log_from_local=0; fi
	if [ $log_from_local = 1 ]; then
		log_pages=$(user_CF_DIR)/src/zen_git.log # from user dir
	else
		log_pages=$zen_docs/Changelog.txt # from install dir
	fi
	IFS=$(echo -en "\n\b")
	brief(){
# 		IFS=$(echo -en "\n\b")
		log_version=$(echo "$entrylog"| grep -E -o "v[0-9].[0-9](.[0-9]{1,2})?")
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$"$( cat <<-BRIEF
			Zenvidia changelog : ( $log_version )

			$log_brief
			BRIEF
			)"
		else
			log_brief=$(echo -e $"Zenvidia changelog ( $log_verion ) :\n\nNothing to display here.\nLog file empty.")
		fi

		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!gtk-close' || cancel_lbl=$"Back to menu"'!zen-back'
		log_txt=$"${v}<b>Zenvidia changelog : ${y}$log_version${end}</b>${end}"
		w_formatted=1; w_wrap=1; w_width='600'; w_height='300'; all_btn=1; colors=1; ok_lbl=$"Back to list"'!zen-undo'
		win_yad_text "$log_brief"
		_exit=$?
		IFS=$ifs
		if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then
# 			IFS=$ifs
			[ $task_opt -gt 0 ] && exit 0 || menu_manage
		else
# 			IFS=$ifs
			read_zen_changelog
		fi
	}
	relist(){
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			for log_line in ${entry_list[@]}; do
				entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
			done
		fi
# 		IFS=$(echo -en "\n\b")
		l_text=$"${j}${bf}Zenvidia Change Logs list${end}${end}"
		col_name=( "" "Version")
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'
		list_type='radiolist'; columns=2; sel_col=2; sep=''; l_tail=1; w_head=1; ok_lbl='Read!zen-ok'
		hid_col=0; edit_col=0; col_tip=0; w_width='500'; w_height='300'
		entrylog=$( win_yad_list "${entrylog_list[*]}" )
		_exit=$?
		if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then
			IFS=$ifs
			[ $task_opt -gt 0 ] && exit 0 || menu_manage
		else
			if [[ $entrylog != '' ]]; then
				if [ $log_from_local = 1 ]; then
					entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
				else
					entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
				fi
				log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
				if [ "$log_end" != '' ]; then
					if [ $log_from_local = 1 ]; then
						log_end=$(echo -e "$log_end"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
					else
						log_end=$(echo -e "$log_end"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
					fi
				else
					log_end='^     $'
				fi
				log_list=$(cat $log_pages | sed -En "/$entrylog/,/$log_end/p"	)
				if [ $log_from_local = 1 ]; then
					log_brief=$(grep -E "^.*-" <<< $log_list) # from user dir
				else
					log_brief=$(grep -E "^[ ]{,3}-" <<< $log_list) # from install dir
				fi
			else
				IFS=$ifs
				[ $task_opt -gt 0 ] && exit 0 || menu_manage
			fi
		fi
	}
	if [ $log_from_local = 1 ]; then
		entry_list=$(grep -E -e "^[Aa-Zz]{3} [0-9]{1,2} [0-9]{4} :" $log_pages) # from user dir
	else
		entry_list=$(grep -E -e "^* [0-9]{4}-[0-9]{1,2}-[0-9]{2} -" $log_pages | sed -n "s/^* //p") # from install dir
	fi
	relist
	brief
	IFS=$ifs
}
nv_config(){
	[ -x $d_nv_settings ] && \
	gpu_set=$($d_nv_settings -q gpus | grep -i "nvidia" | sed -En "s/^.*\[gpu:([0-9])\].*(\(.*\)).*$/GPU \1 - \2/g;p")
	$(su_cmd) "$(def_user)" $d_nv_settings -p "$gpu_set"
	menu_modif
}
zen_notif_setup(){ #
	setup_validation(){
		warn_log=$"${vB}Autostart launcher will be set to :\n<b>></b>${end} ${j}$_notif${end}"
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
		qst=1; ok_lbl=$"Ok"'!zen-ok' ; kill_yad=0
		win_yad_warns
		if [ $_exit = 0 ]; then
			sed -Ei "s/(Exec=zen_notify) -[a-z]/\1 $_set/" $notif_desk_file
		fi
		[ $task_opt -gt 0 ] && exit 0 || menu_modif
	}
	unset setup_list setup_option c_set_list
	setup_option=(
	$"Check driver update only;driver check only;n"
	$"Check zenvidia and driver update;driver and zenvidia check;z"
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP

		<i>You can leave it as it is or choose between
		one of the sets below</i>.
		HLP
		)"
	else
		hlp_tip=''
	fi
	st=1
# 	c_set_opt=$(cat $notif_desk_file |grep "Exec"| perl -p -e "s|^.*-+([a-z])|\1|")
	notif_desk_opt
	for n_set in "${setup_option[@]}"; do
		m_set=$(printf "$n_set"|cut -d';' -f1)
		c_set=$(printf "$n_set"|cut -d';' -f2)
		o_set=$(printf "$n_set"|cut -d';' -f3)
		if [[ $o_set == $notif_desk_opt ]]; then
			c_set_cnf=$c_set
			set_state='true'
		else
			set_state='false'
		fi
		setup_list+=("$set_state")
		setup_list+=("$st")
		setup_list+=("$m_set")
		((st++))
	done
	l_text=$"$(cat <<-MSG
		${j}${bf}Notifications config${end}${end}

		Notification is currently set to: ${y}$c_set_cnf${end}

	MSG
	)"

	IFS=$(echo -en "\n\b")
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
	ok_lbl='Select!zen-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='0'

	menu_notif=$( win_yad_list "${setup_list[*]}" )
	_exit=$?
	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; [ $task_opt -gt 0 ] && exit 0 || menu_modif; fi
	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then [ $task_opt -gt 0 ] && exit 0 || menu_modif; fi
# 	IFS=$ifs
	case $menu_notif in
		"1") _set='-n'; _notif=$"driver check only" ;;
		"2") _set='-z'; _notif=$"driver and zenvidia check" ;;
		*) [ $task_opt -gt 0 ] && exit 0 || menu_modif ;;
	esac
	setup_validation
}

### SUB MENU ###
menu_install(){ #
	unset install_list ins_cmd ins_list
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP

		${v}Select here the install type${end}
		${sf}
		- <b>From a local package</b>:
		   Install a new driver from a user directory local package
		   or a listed already downloaded with zenvidia.
		- <b>From Nvidia server</b>:
		   Will display the full drivers list from the Nvidia server.
		   Install and download will be executed in the next step.
		${end}
		HLP
		)"
	else
		hlp_tip=$"\n${v}Select here the install type${end}"
	fi
	install_list=($"From a local package" $"From NVIDIA server")
	n=1
	for ins_cmd in "${install_list[@]}"; do
		ins_list+=("false")
		ins_list+=("$n")
		ins_list+=("$ins_cmd")
		n=$[ $n+1 ]
	done 
	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Install new drivers${end}\n${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_inst=$( win_yad_list "${ins_list[*]}" )
	_exit=$?
	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; base_menu; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && base_menu || {
# 	IFS=$ifs
	ui_mod=1
	tmp_dir
	case $menu_inst in
		"1") menu_msg=$"${vB}NVIDIA package update from local dir. ${end}"; from_install=1; from_directory ;;
		"2") menu_msg=$"${vB}NVIDIA package update from NVIDIA server.${end}"; from_install=0;net_version_selector ;;
		*) base_menu ;;
	esac
	}
}
menu_update(){ #
	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(cat <<-HLP

		${v}Select here the element to update or install${end}
		${sf}
		- <b>Driver upgrade</b>
		   Check for new driver update.
		   You can select during the process to download only or install directly.
		   If <i>download only</i> is chosen, for installation afterward
		   go back to : » ${j}main${end} menu » ${j}Install Drivers${end}
		   <u>Note</u> : All download are stored.
		- <b>Update driver only (dkms)</b>
		   Install nvidia dkms modules for a new running kernel.
		- <b>Update driver only (force)</b>
		   Optional command to force install from driver sources in case of
		   DKMS failure.
		- <b>Update driver for an other kernel (dkms)</b>
		   Optional command to update nvidia modules for an other kernel.
	${end}
		HLP
		)"
	else
		hlp_tip=''
	fi
	nu=1
	if [ $hlp_txt = 0 ]; then hlp_tip=$"\n${v}Select here the element to update or install${end}"; fi
		if [ $use_dkms = 1 ]; then
			up_cmd_list=($"Driver upgrade" $"Update driver only (dkms)" $"Update driver only (force)" $"Update driver for an other kernel (dkms)")
		else
			up_cmd_list=($"Driver upgrade" $"Update driver only" $"Update driver for an other kernel")
		fi
	unset up_list
	for up_cmd in "${up_cmd_list[@]}"; do
		up_list+=("false")
		up_list+=("$nu")
		up_list+=("$up_cmd")
		nu=$[ $nu+1 ]
	done 
	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Update Drivers or kernel modules${end}${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_upd=$( win_yad_list "${up_list[*]}" )
	_exit=$?
# 	IFS=$ifs
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; base_menu; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && base_menu || {
	IFS=$ifs
	home=/home/$(def_user)
	tmp_dir
	force=''
	if [ $use_dkms = 1 ]; then
		case $menu_upd in
			"1")	menu_msg=$"${v}Check driver updates list${end}"; legacy_drv=0; check_for_newer; check_update ;;
			"2")	menu_msg=$"${v}Build module for current kernel (dkms)${end}"
					upgrade_other=0; force='--force'
					upgrade_kernel ;;
			"3")	menu_msg=$"${v}Build module for current kernel (force)${end}"
					upgrade_other=0; use_dkms=0;
					upgrade_kernel ;;
			"4")	menu_msg=$"${v}Build module for the selected kernel (dkms)${end}"
					upgrade_other=1;
					upgrade_new_kernel ;;
			*) base_menu ;;
		esac
	fi
	}
}
menu_modif(){
	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(cat <<-HLP

		${v}Select here the element to modify or edit:${end}
		${sf}
		- <b>Edit Xorg config file</b>:
			Edit the current xorg configuration file in /etc/X11.
		- <b>Edit script config</b>:
			Edit Zenvidia basic user conf script to set or unset mostly everything.
		- <b>Edit GUI font colors</b>:
			Change defaults font colors.
		- <b>Nvidia settings</b>:
			Start Nvidia-setting graphic UI tool.
		- <b>Edit distro config</b>:
			Modify the distribution configation file.
			<u>Notice</u> : You can add here the very specifics distro's variables.
		- <b>Manage drivers packages</b>:
			This tool is to backup, restore and remove old or current driver install.
			It also manage dowloaded nvidia's .run pack.
			<u>Note</u> : if old installation is found during driver update,
			it is automatically backed up prior to new version installation.
		- <b>Notication settings</b>:
			Configuration tool for Zen_notify daily update checker.
		- <b>Open driver switch tool</b> (optional):
			When available, this tool allow to switch between
			open and proprietary source drivers.
		${end}
		HLP
		)"
	else
		hlp_tip=$"\n${v}Select here the element to modify or edit${end}"
	fi
	unset m_menu_list mod_list case_line menu_mod
	nd=1
	open_switch(){ if [ $UID = 0 ]; then win_open_switch; else  is_SU; base_menu; fi;}
	prime_display(){ if [ $UID = 0 ]; then prime_setup; else  is_SU; base_menu; fi;}
	edit_distro(){ if [ $UID = 0 ]; then edit_distro_conf; else is_SU; base_menu; fi;}
 	#edit_xorg(){ from_install=0; if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; base_menu; fi;}
 	edit_xorg(){ if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; base_menu; fi;}
	manage_drivers(){ if [ $UID = 0 ]; then manage_pcks; else is_SU; base_menu; fi;}
	m_menu_list+=( $"Edit xorg config file","edit_xorg" )
	m_menu_list+=( $"Edit Zenvidia config","edit_script_conf" )
	m_menu_list+=( $"Edit GUI Colors","edit_color_conf" )
	m_menu_list+=( $"Nvidia-settings","nv_config" )
	m_menu_list+=( $"Edit Distro config","edit_distro" )
	m_menu_list+=( $"Manage drivers packages","manage_drivers" )
	m_menu_list+=( $"Zenvidia notification config","zen_notif_setup" )
# 	m_menu_list+=(  )
	IFS=$(echo -en "\n\b")
	if [ $open_drv -gt 0 ]; then
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=($"Open driver switch tool")
		((nd++))
		case_line+=("open_switch")
	fi
	if [ $opti_preset -gt 0 ]; then
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=($"PRIME Display config")
		((nd++))
		case_line+=("prime_display")
	fi
	for mod_cmd in "${m_menu_list[@]}" ; do
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("$(printf $mod_cmd| cut -d',' -f1)")
		((nd++))
		case_line+=("$(printf $mod_cmd| cut -d',' -f2)")
	done
	l_text=$"${j}${bf}Configuration and Tools${end}${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_mod=$( win_yad_list "${mod_list[*]}" )
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then base_menu; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && base_menu || {
	IFS=$ifs
	case ${menu_mod} in
		1) ${case_line[0]};;
		2) ${case_line[1]};;
		3) ${case_line[2]};;
		4) ${case_line[3]};;
		5) ${case_line[4]};;
		6) ${case_line[5]};;
		7) ${case_line[6]};;
		8) ${case_line[7]};;
		9) ${case_line[8]};;
		10) ${case_line[9]};;
		*) base_menu ;;
	esac
	}
}
menu_manage(){ #
# 	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(
		cat <<-TIP

			${v}README and Help file from Nvidia $(version) and other.${end}
			${sf}
			- <b>Documanetation</b>:	Read the current Nvidia help file.
			- <b>Change Logs</b>:		Read the current Nvidia changelog file.
			- <b>Zenvidia Logs</b>:		Read the Zenvidia changelog file.
			- <b>Zenvidia Help</b>:		Read Zenvidia doc file.
			- <b>About Zenvidia</b>:	Read current Zenvidia README file.
			${end}
		TIP
		)"
	else
		hlp_tip=$"\n${v}README and Help file from Nvidia $(version) and other.${end}"
		w_height='--height=300'
	fi
	nm=1
	unset mng_list
	for mng_cmd in $"Documention manual ($(version))" $"Change Logs ($(version))" $"Zenvidia Logs" $"Zenvidia Help" $"About Zenvidia"; do
		mng_list+=("false")
		mng_list+=("$nm")
		mng_list+=("$mng_cmd")
		nm=$[ $nm+1 ]
	done
	IFS=$(echo -en "\n\b")
# 	l_text=$"${j}${bf}Help and Documentation${end}${end}""${v}$hlp_tip${end}"
	l_text=$"${j}${bf}Help and Documentation${end}${end}""$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_mng=$( win_yad_list "${mng_list[*]}" )
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then IFS=$ifs; base_menu; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && base_menu || {
	IFS=$ifs
	case $menu_mng in
		"1") unset chapter_index chapters_list; read_nv_help ;;
		"2") read_changelog ;;
		"3") read_zen_changelog ;;
		"4") read_help ;;
		"5") read_about ;;
		*) base_menu ;;
	esac
	}
}

### RESCUE COMMAND LINE ###
dm_serv_restore(){
	if [ $no_mod=0 ]; then
		if [ "$dkms_ins" == "$cmd_ver" ]; then
			for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
				if [ $(grep -owc "$drv" /etc/modprobe.d/nvidia-blacklist.conf) -eq 0 ]; then
				drv_list+=("$drv")
				fi
			done
			test $echec = 0 && ( echo -e "${nc}# ${yel}DM and $dkms_ins drivers re-init :${nc}" )
			echo -e "${nc}# ${yel}Unload $dkms_ins drivers if any${nc}."; sleep 2
			modprobe -r -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Load $cmd_ver drivers${nc}."; sleep 2
			command -v restorecon &>/dev/null || modprobe -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Exec $KERNEL modules reload."; sleep 2
			exec_mod_load
			echo -e "${nc}# ${yel}Exec $KERNEL modules init."; sleep 2
			progress_msg(){ echo -en "\r${nc}#${blu} ($m sec.) Exec $KERNEL modules initramfs."; }; m=1; do_slp=1
			exec_initramfs
			echo -e "\n${nc}# ${yel}Done.${nc}"
			echo -e "# ${yel}License is $license ${nc}."
			## catch console pid here
			if [ "$(dm_serv)" != "" ]; then
				test $($d_sys status $(dm_serv) | grep -c "disabled") -gt 0 && (
				echo -e "${nc}# ${yel}Restore $(dm_serv) service to 'enable'${nc}."; sleep 2; )
				$d_sys enable $(dm_serv).service
				echo -e "${nc}# ${yel}Start $(dm_serv) service${nc}."; sleep 2
				echo -e "${blu}(Press ENTER to start, CTRL-C to cancel)${nc}"; read
				$d_sys start $(dm_serv).service
			else
				echo -e "${nc}# ${yel}You can 'enable' and 'start' your Display Manager now.${nc}."
			fi
			## trying to kill console root's tty.
			if [ $(w | grep -c "root.*tty") -gt 0 ]; then
				sleep 40
				pkill -9 -t $(w | grep "root.*tty" | awk '{print $2}')
			fi
		else
			echo -e "${nc}# ${red} WARNING${yel}: $cmd_ver differ from installed driver ($dkms_ins); <rebuild> first.\nAbort.${nc}."
		fi
	else
		echo -e "${nc}# ${red} WARNING${yel}: No modules found for $KERNEL, install $cmd_ver first with <rebuild> option.\nAbort.${nc}."
	fi
}
restore_cmdline(){
	echec=0
	echo -e "# ${yel}Restoring $cmd_ver driver for $KERNEL${nc} :\n"
	sleep 2
	## clean old librairies
	if [ "$dkms_ins" != "" ]; then
		if [[ $cmd_ver != $dkms_ins ]]; then
			echo -e "# ${blu}Cleaning $dkms_ins old installation${nc} ..."
			sleep 2
			rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$dkms_ins
			rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$dkms_ins
			rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$dkms_ins
			test -d /var/lib/dkms/nvidia/$dkms_ins && $p_dkms remove nvidia/$dkms_ins --all
			test -d /var/lib/dkms/open-nvidia/$dkms_ins && $p_dkms remove open-nvidia/$dkms_ins --all
			rm -Rf /usr/src/nvidia-$dkms_ins
			test -d /usr/src/open-nvidia-$dkms_ins && rm -Rf /usr/src/open-nvidia-$dkms_ins
			sleep 2
		fi
	fi
# 	echo -e "# ${yel}Uncompressing $cmd_ver archive for $KERNEL${nc} :\n"
# 	tar -zvxf $nvbackup/nvidia.$cmd_ver.tar$zip_ex -C /
# 	res_version=$nvbackup/nvidia.$cmd_ver.tar.*
	restore_pcks_cmd
	echo -e "\n# ${blu}- Registering $cmd_ver librairies (ldconfig)${nc} ..."
	ldconfig
	echo -e "# ${blu}- Depmod $cmd_ver modules ..."
	progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
	m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"
	## check modules
	echo -e "\n${nc}# ${blu}- Testing $cmd_ver modules availbility${nc} ..."
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	test $vermagic && echo -e "# ${yel}Initramfs update${nc}." || \
	( echo -e "# ${red}Test failed${nc}."; echec=1; rebuild_cmdline )
	sleep 2
	if [ $echec = 0 ]; then
		echo -e "\n${nc}# ${yel}Done.${nc}"
		echo -e "# ${yel}License is $license ${nc}.\n"
		dm_serv_restore
	fi
}
rebuild_cmdline(){
	if [ $echec = 1 ]; then
		echo -e "# ${red}WARNING ${yel}: No $cmd_ver modules set in the backup${nc}.\n"; sleep 2
	fi
	clear
	echo -e "# ${yel}Build & Install $cmd_ver DKMS $KERNEL modules ($license) :${blu}"; sleep 2
	if [ $($p_dkms status -m $module/$cmd_ver -k $KERNEL| grep -cv "added") -gt 0 ]; then
		$p_dkms remove -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms add -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	else
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	fi
	## recheck modules
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [[ $vermagic ]]; then
		echo -e "\n${nc}# ${yel}Initramfs update aand other routines.${blu}"; sleep 2
		dm_serv_restore
	else
		echo -e "\n# ${red}Failed${nc}."
	fi
}
rescue_cmdline(){
	## modinfo will display error if modules is not found, just add comments.
	clear
	echo -e "# ${yel}Compling $module $cmd_ver sources${nc} :\n" ; sleep 2
	kernel_module_src=/usr/src/$module-$cmd_ver
	cd $kernel_module_src; make -j12
	## check again
	vermagic=$($d_modinfo -F vermagic $kernel_module_src/nvidia.*[ko\|ko.xz]| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [ $vermagic ]; then
		if [[ $vermagic == $KERNEL ]]; then
			cp -f *.ko $libmod/
			## compress modules.
			clear
			echo -e "# ${blu}- Compressing modules if needed${nc}."; sleep 2
			is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
			[ $is_RT = 0 ]|| xz -T12 $libmod/*.ko
			echo -e "# ${blu}- Depmod $cmd_ver modules ..."
			progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
			m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"
			## rebuild initramfs in case of trouble booting.
			clear
			dm_serv_restore
		fi
	else
		echo -e "${nc}#${red} *** Something went wrong ! ***\n${nc}#${yel} Restoration script can't proceed, exit${nc}."
	fi
}
## root warning
is_SU(){
	warn_log=$"$(cat <<-WRN
	${y}${bf}Your are not superuser${end}${end}
	This command can't be executed without ${j}<b>administrator</b>${end} priviledge.
	See ${j}<b>Zenvidia task bar</b>${end} to run as admin or
	${j}<i>Zenvidia (administrator)</i> desktop entry${end} instead.
	WRN
	)"
	qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-close' ; kill_yad=0
	win_yad_warns
}

### MAIN MENUS ###
base_menu(){ #
	devices(){
	e=0
	until [ $e -eq ${#dev_n[*]} ]; do
# 		printf "${vB}Card $((${dev_n[$e]}+1)) :${end}${ge} - - - - - - - - - ${end}${j}${dev[$e]} ($(printf ${vnd[$e]}|awk '{print $1}'))${end}\n"
		echo $"${vB}Card $((${dev_n[$e]}+1)) :${end}${ge}			${end}${j}${dev[$e]} ($(echo ${vnd[$e]}|awk '{print $1}'))${end}"
		((e++))
	done
	}
	open_check(){
	if [ $open_drv ]&&[ $open_drv = 1 ]; then
		if [ $use_open ]; then
			if [ $use_open = 1 ]; then open_used=$" and in use"; else open_used=$", but unused"; fi
		else
			open_used=$", closed source used"
		fi
		echo -e $"${vB}Open Source modules :${end}${ge}	${end}${j}installed$open_used${end}"
		echo -e $"${vB}Modules license :${end}${ge}		${end}${j}$($d_modinfo -F license nvidia)\n${end}"
	fi
	}
	right_check(){
		if [ $UID = 0 ]; then
			echo "superadmin"
		else
			echo $"$USER\n(system write priviledge not allowed)$scan_alert"
		fi
	}
	# remove deplist list in case of relaunching first because an update asking to
	unset deplist
	hlp_tip_txt=$"$( cat <<-HLP
		${v}Help tips text is currently set${end}
		${sf}You can unset it at any moment in:
		${j}Configuration and Tools${end} menu » ${j}Edit script config${end}.
		${end}
	HLP
	)"
	[ $hlp_txt = 0 ]|| { hlp_wrn="$hlp_tip_txt"; }
	unset wt_sub
	l_text=$"$( cat <<-MSG
		${r}<big><b>A Free Nvidia drivers manager</b></big>${end}
		${y}Close and Open Source versions support${end}

		${vB}System :${end}${ge}			${end}${j}$(distro_name)${end}
		${vB}Processor type :${end}${ge}		${end}${j}$ARCH${end}
		$(devices)

		${vB}Driver version installed :${end} ${j}$(drv_installed)${end}$restore_msg
		${vB}Kernel version :${end}${ge}		${end}${j}$KERNEL${end}
		${vB}GCC version :${end}${ge}		${end}${j}$GCC${end}
		${vB}NVIDIA binary version :${end}${ge}	${end}${j}$NV_bin_ver${end}$restore_msg
		$(open_check)
		${v}Network connection :${end} ${j}$cnx_msg${end}
		${v}Rights :${end} ${j}$(right_check)${end}

		${hlp_wrn}
		${v}What do you want to do ?${end}
	MSG
	)"
	IFS=$(echo -en "\n\b")
	unset col_name; cancel_lbl=$"Exit"'!zen-stop'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0
	w_width='300'; w_height='300'; l_tail=0; w_head=0
	menu_list=( false 1 $"Install drivers" false 2 $"Update drivers or modules" false 3 $"Configuration and Tools" false 4 $"Help and Documentation" )
	menu_cmd=$( win_yad_list "${menu_list[*]}" )
	_exit=$?
# 	if [[ $_exit -eq 1 || $_exit -eq 252 ]]; then exit 0; fi
	[[ $_exit -eq 1 || $_exit -eq 252 ]] && exit 0 || {
	case $menu_cmd in
		"1") if_update=0; if [ $UID = 0 ]; then menu_install; else is_SU; base_menu; fi;;
		"2") if_update=1; if [ $UID = 0 ]; then menu_update; else is_SU; base_menu; fi;;
		"3") if_update=1; menu_modif ;;
		"4") if_update=1; menu_manage ;;
		*) exit 0 ;;
	esac
	}
}
install_controls(){ #
	# check nvidia dir presence
	if [ -d $install_dir/zenvidia ] ; then
		dir_msg="${j} OK${end}"
	else		
		warn_log=$"${j}ERROR\n${y}Zenvidia repository is missing${end}${end}"
		warn_image='zen-error'
		qst=0; ok_lbl='' ; cancel_lbl=$"Close"'!zen-close' ; kill_yad=0
		win_yad_warns
	fi
	# check/change run packages permission
	nvdl_last=$(ls -1 $nvdl/|sed -n '$p')
	if [[ -s $nvdl/$nvdl_last ]] ; then
		for changes in $(ls -1 $nvdl ); do
			if [[ $(stat -c "%a" $nvdl/$changes) != 755 ]]; then
				chmod 755 $nvdl/$changes
			fi
		done
	fi
}
start_cmd(){
## this for function testing only in "$1"
# 	if [[ $cmd_opt != '' ]]; then
# 			$($cmd_opt)
# 	fi
	## check if X server is off before lauching cmd line tools.
# 	xprop -root &>/dev/null
# 	if [ $? -gt 0 ]; then
	gcc_and_proc_options
	if [ $x_alive -gt 0 ]; then
		help_text(){
			cat <<-HT
				Command line option : $(basename $0 ) [option] [driver version]
				Options :
				   restore	-> restore driver backup.
				   rebuild	-> rebuild driver.
				   rescue	-> force driver build from sources.
				   reinit	-> Rebuild initramfs and start DM.
			HT
			if [ $(ls -1 $nvbackup | grep -c .) -gt 0 ]; then
				echo -e "Driver version backups :"
				ls -1 $nvbackup | sed -En "s/^nvidia.([0-9]*.*).tar$zip_ex/ - \1/p"
			fi
			file -E $libmod/nvidia.*[ko\|ko.xz] &>/dev/null
			if [ $? -eq 0 ]; then
				echo -e "Installed driver version : $dkms_ins"
				no_mod=0
			else
				echo -e "Found dkms driver version : $module » $dkms_ver"
				no_mod=1
			fi
			echo -e "Display Manager : $(dm_serv)"
		}
		libmod='/lib/modules/'$KERNEL'/'$(module_dest_location)
		echo -e "** ${red}X server not runing${nc} **"
		echo -e "${yel}"
		if [ -f /etc/modprobe.d/open-NVIDIA.conf ]; then
			module='open-nvidia'
			license='Dual MIT/GPL'
		else
			module='nvidia'
			license='NVIDIA'
		fi
		## check realtime kernel.
		is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
		if [ $is_RT = 1 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		fi
		## check dkms mods list.
		dkms_mod=$($p_dkms status -m $module | grep -v "added"| cut -d, -f1)
		dkms_ver=$(echo -e "$dkms_mod"| cut -d"/" -f2)
		dkms_ins=$($d_modinfo -F version $libmod/nvidia.*[ko\|ko.xz])
		echec=0
		if [[ $cmd_ver != '' ]]; then
			case $cmd_opt in
				restore) restore_cmdline ;;
				rebuild) rebuild_cmdline ;;
				rescue) rescue_cmdline ;;
				reinit) dm_serv_restore;;
				*) help_text ;;
			esac
		else
			 help_text
		fi
		echo -e "${nc}"
		exit 0
	else
		#dep_control
		test -x "$d_yad" || exit 0
		install_controls
		connection_control
		# test initramfs distro's tool.
		initramfs_warn
		base_menu
	fi
}

## BASICS CHECK ###
default_sets(){
	## default main set value.
	use_drm=${use_drm:-1}
	drm_modset=${drm_modset:-1}
	opti_preset=${opti_preset:-0}
	from_install=${from_install:-0}
	rem_extract=${rem_extract:-1}
	use_dkms=${use_dkms:-1}
	open_drv=${open_drv:-0}
	use_open=${use_open:-0}
	use_persistenced=${use_persistenced:-0}
	fix_profiles=${fix_profiles:-0}
	use_gzip=${use_gzip:-0}
	exec_mod_tool=${exec_mod_tool:-0}
	ARCH=${ARCH:-$HOSTTYPE}
	xt_hold=${xt_hold:-0}
	xt_delay=${xt_delay:-4}
	## default PRIME values.
	opti_auto_set=${opti_auto_set:-0}
	opti_preset_off=${opti_preset_off:-0}
	offload=${offload:-0}
	render=${render:-'NONE'}
	enable_powerd=${enable_powerd:-0}
	## define if task bar menu entry are used
	task_opt=${task_opt:-0}
	## default warn display set is null.
	open_wrn=${open_wrn:-1}
	first_open=${first_open:-0}
	hlp_txt=${hlp_txt:-1}
}
default_zen_dir(){
	test -d $(user_CF_DIR) || {
		mkdir -p $(user_CF_DIR)
		mkdir -p $(user_CF_DIR)/{compats/series,updates,release}
		chown -R $(def_user):$(def_user) $(user_CF_DIR)
	}
}
# ### SCRIPT INTRO ###
## check user config dirs priviledges.
if [ "$(def_user)" != "root" ]; then default_zen_dir; fi
# NOTE : distro function was used to get particular env vars attached to specific distro from a config file.
# This is replace by auto checks inside the script. Distro config is kept to load specific config if any.
# It will be removed in a near future if it'll become useless.
distro
## config distro elf type
libclass
## check dependies executables
p_xterm=$(command -v xterm) || (
	echo -e "${red}XTERM missing, installing ...${nc}"; $PKG_INSTALLER $pkg_opts$pkg_cmd xterm;
	export p_xterm=$(command -v xterm)
	)
## system place bin control and depencies list building if any.
dep_exec_check
## check/install dependies
dep_control
## LD_LIBRARY_PATH definition (useless in Fedora).
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$install_dir/$master$ELF_32:$install_dir/$master$ELF_64
PCI_ID
# cmdline tool doesn't need to read config, so skip the step if in console only.
if [[ $(def_user) != "root" ]]; then
# check if default user has conf file to load, or create it from shipped.
	for conf in {basic,color}; do
		if [ "$nvdir/$conf.conf" -nt "$(user_CF_DIR)/$conf.conf" ]; then
			install -bCm644 -o $(def_user) -g $(def_user) -t $(user_CF_DIR) $nvdir/$conf.conf
		fi
		eval ${conf}_conf=$(user_CF_DIR)/$conf.conf
	done
## define necessary dirs in user config dir.
	nvcompat="$(user_CF_DIR)/compats"
	upcompat="$(user_CF_DIR)/updates"
	nvdl="$(user_CF_DIR)/release"
	test -d $nvdl || mkdir -p $nvdl
	[ $(chk_family) -gt 0 ] || { [ $optimus -gt 0 ] && opti_preset=1 ;}
	## old version check and move. # NOTE TO REMOVE IN FUTURE RELEASE.
	if [ $(ls -1 $nvdir/release | grep -c .) -gt 0 ]; then
		mv -f $nvdir/release/* $(user_CF_DIR)/release/
	fi
	# drv_list_file=$(rem_drv_list)
	## zen notify desktop entry option (define zenvidia changelog reading behaviour)
	notif_desk_file=/home/$(def_user)/.config/autostart/zen_notify.desktop
	notif_desk_opt=$(cat $notif_desk_file| sed -En "s/^Exec=.*-(.*)/\1/p")
	## then read script conf.
	. $basic_conf
	. $color_conf
	## force optimus check to off and unset opti_preset.
	[ $opti_preset_off = 1 ] && opti_preset=0
fi
## set default or null value after conf files reading in case reading failure.
# hlp_txt=1 # TEST TO REMOVE.
default_sets
# load markup span font colors.
zen_colors
# pick all necessary env Definition
display_and_compil_vars
# PCI_ID # IN TEST
## configuration file check
if [ ! -s $script_conf ]; then #
	warn_log=$"<b>Script's config file missing.\n</b>"
	warn_image='zen-error'
	qst=0; ok_lbl='' ; cancel_lbl=$"Abort"'!zen-close' ; kill_yad=0
	win_yad_warns
	exit 0
fi
## pick cmd line long options if any (X server off only).
cmd_opt=$1; cmd_ver=$2
## option section is for zen_task_menu needs and is available only from zen_task_menu calls or from cammand line.
while [ $# -gt 0 ]
	getopts "rdhxpcnzouat" OPTION; do # 't' is the function's test option.
	task_opt=1
	case $OPTION in
		r) read_zen_changelog;;
		d) read_changelog;;
		h) read_nv_help;;
		x) [ $UID = 0 ] && edit_xorg_conf;;
		p) [ $UID = 0 ] && prime_setup;;
		c) edit_color_conf;;
		n) zen_notif_setup;;
		z) edit_script_conf;;
		o) [ $UID = 0 ] && win_open_switch;;
		a) read_about;;
		u) if [ $UID = 0 ]; then legacy_drv=0; check_for_newer; check_update; fi ;;
# 		t) set_su ;;
	esac
exit 0
done
## ### LET'S START ###
start_cmd
