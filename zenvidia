#!/bin/bash
#  Zenvidia
#  Sat Feb  6 16:58:20 2010
#  Copyright  2010-2023  PirateProd
#  <wildtruc@noneltd.net>
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with main.c;if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301, USA

# DEFAULT set options
 set -e -E -u -o functrace

 export PS4='->$(tput setaf 6)${LINENO}$(tput sgr 0)$(printf "\\t")-> '
## Fixed Variables (could not be change)
### ZENVIDIA VARS ### readonly install_dir="/usr/local" (AI fix)
install_dir=/usr/local							# default tools & system install directory
nvdir=$install_dir/share/zenvidia			# default Zenvidia directory
conf_dir=$nvdir									# default config files directory
script_conf=$nvdir/script.conf				# default Zenvidia main config files
zen_framework_conf=/etc/dkms/framework.conf.d/zenvidia.conf

### NVIDIA-INSTALLER PATH ###
profile_path="$install_dir/share/nvidia"
nvi_docs="$install_dir/share/doc/NVIDIA_GLX-1.0"
zen_docs="$install_dir/share/doc/zenvidia"
### NVIDIA-INSTALLER VARS ###
profile="--application-profile-path=$profile_path"
docs="--documentation-prefix=$install_dir"
## systemctl data path.
systemd_dir=/usr/lib/systemd/system
## defaut window manager image
img_zen_desktop=$install_dir/share/pixmaps/zen-emblem.png
# zen_version=$(cat $nvdir/zen_version)

export PATH=$PATH:$install_dir/bin
## set translation path.
TEXTDOMAIN=zenvidia
TEXTDOMAINDIR=$nvdir/locale
export TEXTDOMAIN TEXTDOMAINDIR

## terminal fonts colors.
red='\e[1;31m'
yel='\e[0;33m'
grn='\e[0;32m'
blu='\e[0;34m'
cya='\e[0;36m'
pur='\e[0;35m'
nc='\e[0m'

shopt -s extglob

### PROLOGUE
ifs=$IFS
### MAIN VARS
## find first default values for distro and desktop user
## define who is facing the screen.
def_user(){
	[ $(x_check) -gt 0 ] && stat -c %U -- /run/user/* | grep -v "root" || stat -c %U -- /run/user/*
}
def_user_id(){
	[ $(x_check) -gt 0 ] && stat -c %u -- /run/user/* | grep -v "root" || stat -c %u -- /run/user/*
}
pkg_installer(){
	pkg_mng=1
	case $(distro_version) in
 		arch|manjaro) echo "$(command -v pacman)" ;;
 		mageia|mandriva) echo "$(command -v urpmi)";;
		rhel|fedora|centos) echo "$(command -v dnf)";;
		opensuse|sles) echo "$(command -v zypper)";;
		ubuntu|mint|debian) echo "$(command -v apt-get)";;
# 		sles) echo "";;
		*) echo "none" ; pkg_mng=0 && return ;;
	esac
}
pkg_install_cmd(){
	pkg_inst=1
	case $(distro_version) in
 		arch|manjaro) echo "$(pkg_installer) install --noconfirm ";;
 		mageia|mandriva) echo "$(pkg_installer) -y install ";;
		rhel|fedora|centos) echo "$(pkg_installer) -y install ";;
		opensuse|sles) echo "$(pkg_installer) --non-interactive install ";;
		ubuntu|mint|debian) echo "$(pkg_installer) -y install ";;
# 		sles) echo "";;
		*) echo "none" ; pkg_inst=0 && return ;;
	esac
}
# elf types
libclass(){
	# debian : /x86_64-linux-gnu /i386-linux-gnu
	# arch : /usr/lib /usr/lib32
	# rpm base : /usr/lib64 /usr/lib
	ELF_LIST=() ELF_LIB_LIST=()
	# remind that systemd-path system-library-arch give system arch libs full path.
	# command like this have a clue (useful for zenvidia3):
	# systemd-path search-library-arch | sed -n "s/^.*://p"
	# define distro base ELF type
	if [[ $(systemd-path system-library-arch) =~ "64" ]]; then
		ELF_TYPE="64"
		case $(distro_version) in
			arch|manjaro) master=lib; ELF_32='32'; ELF_64=''; ELF_LIST=( $ELF_64 $ELF_32 ) ;;
			rhel|fedora|centos|mageia|mandriva|opensuse|sles) master=lib; ELF_32=''; ELF_64='64';;
			ubuntu|mint|debian) master=lib; ELF_32='/i386-linux-gnu'; ELF_64='/x86_64-linux-gnu';;
			*) master=lib; ELF_32=''; ELF_64='64';;
		esac
		ELF_LIST=( $ELF_64 $ELF_32 )
		ELF_LIB_LIST=( $master$ELF_64 $master$ELF_32 )
	else
		## Library places have been redifine in Debian like.
		## But can't tell if unbuntu or mint are touch.
		## debian is define apart for the moment.
		## ELF_32='/i386-linux-gnu'; ELF_64='/x86_64-linux-gnu'
		ELF_TYPE=""
		case $(distro_version) in
			arch|manjaro) master=lib; ELF_32=''; ELF_64='' ;;
			rhel|fedora|centos|mageia|mandriva|opensuse|sles) master=lib; ELF_32=''; ELF_64='';;
			ubuntu|mint|debian) master=lib; ELF_32='/i386-linux-gnu'; ELF_64='';;
			*) master=lib; ELF_32=''; ELF_64='';;
		esac
		ELF_LIST=( $ELF_64 )
		ELF_LIB_LIST=( $master$ELF_64 )
	fi
	# CHECK that /usr/local/ for lib is in LD conf.d path
	for LD in ${ELF_LIB_LIST[@]} ; do
		if [ $($d_ldconfig -p |grep -c "$install_dir/$LD") -eq 0 ]; then
			[[ "$(distro_version)" =~ ubuntu|mint|debian ]] && LD=$(sed -n 's|\/|-|g;p' <<< ${LD})
 			[ -e /etc/ld.so.conf.d/local-$LD.conf ] || \
			printf "$install_dir/$LD" > /etc/ld.so.conf.d/local-$LD.conf
			$d_ldconfig
		fi
	done
}
x_check(){
	 ps -A | grep -i "xorg\|wayland" &>/dev/null; [ $? = 0 ] && echo 0 || echo 1
}
kernel_src(){
	# debian : linux linux-headers /usr/src/kernel-headers-$(uname -r)
	# arch : linux linux-headers /lib/modules/$(uname -r)build
   # mageia, mandriva : kernel-desktop-devel-latest /usr/src/linux-$(uname -r)
	# rpm base : kernel-devel kernel-headers /usr/src/linux-$(uname -r)
	# rh : kernel-devel kernel-headers /usr/src/kernels/$(uname -r) ou /lib/modules/$(uname -r)/source
	case $(distro_version) in
 		arch|manjaro) echo "/lib/modules/$(uname -r)/build" ;;
		rhel|fedora|centos) echo "/lib/modules/$(uname -r)/source";;
		mageia|mandriva) echo "/lib/src/linux-$(uname -r)";;
		ubuntu|mint|debian) echo "/usr/src/kernel-headers-$(uname -r)";;
		*) echo "/usr/src/linux-$(uname -r)";;
	esac
}
user_DL_DIR(){
# 	if [ $(x_check) -eq 0 ]; then
		echo "/home/$(def_user)/"$"Downloads"
# 	fi
}
user_CF_DIR(){
# 	if [ $(x_check) -eq 0 ]; then
		echo "/home/$(def_user)/.zenvidia"
# 	fi
}
remove_drv_list(){
	if ! [ -f $(user_CF_DIR)/notify/drvlist ]; then
		su_cmd "$(command -v zen_notify) -n &>/dev/null"
	fi
	echo "$(user_CF_DIR)/notify/drvlist" && return
}
distro_version(){
	if [[ -r /etc/os-release ]]; then
		if [ "$(grep -c "ID=ubuntu" /etc/os-release )" -gt 0 ]; then
			echo "unbuntu"
		elif [ $(grep -c "ID_LIKE=" /etc/os-release ) -gt 0 ]; then
			echo "$(sed -En "s/ID_LIKE=(.*)$/\1/p" /etc/os-release )"
		else
			echo "$(sed -En "s/^ID=(.*)$/\1/p" /etc/os-release )"
		fi
		return
	fi
		local DISTRIB_ID
		if [ -r /etc/lsb-release ]; then
			echo "$(sed -En "s/^DISTRIB_ID=(.*)$/\1/p" /etc/lsb-release )"
		elif type lsb_release &>/dev/null; then
			DISTRIB_ID=$(lsb_release -i -s)
		fi
		## fix case sensitive
		case ${DISTRIB_ID} in
			Fedora) echo fedora ;;
			RedHatEnterprise*|CentOS|ScientificSL) echo rhel ;;
			OpenSUSE|SUSE*) echo sles ;;
			Arch|Manjaro) echo arch ;;
			*) if [[ ${DISTRIB_ID} ]]; then
					echo "${DISTRIB_ID}"
				else
					echo "unknown"
				fi
			;;
		esac
	#fi
}
distro_name(){
	if [[ -r /etc/os-release ]]; then
		echo "$(sed -En "/^NAME=/{;s/\"//g;s/^.*=(.*)?$/\1/p}" /etc/os-release )"
	else
		if [ -r /etc/lsb-release ]; then
			. /etc/lsb-release
			echo "$(sed -En "s/^NAME=[\"]?(.*)[\"]?$/\1/g;p" /etc/lsb-release )"
		elif type lsb_release &>/dev/null; then
			echo "$(lsb_release -i -s)"
		fi
	fi
	return
}
set_su(){
	local warn_text su_opts set_args su_cmd_prompt
	warn_text=$"$( cat <<-MSG
		<b>Su command is not congigured</b>

		Without a proper <b>su</b> command for user calls, Zenvidia main functions
		are unusable and script will abort.

		Please, enter <b>sudo</b> or <b>su</b> command line with options for default
		user admin privilege.

		<i>If you don't know what is talking about here, just abort.
		</i>
	MSG
	)"
	su_opts="sudo -u!sudo -l -U!sudo -i!su -l"
	set_args=$($d_yad --width=400 --borders=15 --title="$WIN_TITLE" --window-icon="$img_zen_desktop" --image="zen-warning" \
	--center --text="$warn_text" --form --button=$"Abort"'!gtk-close:1' --button=$"Set"'!zen-ok:0' --field="":LBL '' \
	--separator=';' \
	--field=$"<b>Distribution name</b>"!$"Enter the name of the distribution if not displayed.":LABEL "$(distro_version)" \
	--field=$"<b>su command line</b>"!$"Select a commande in the list or type one.":CBE "$su_opts" \
	|| if [ $? = 252 ]; then echo 200; elif [ $? = 1 ]; then echo 100; else echo 0; fi)
	case ${set_args} in
		100|200) exit 1;;
		*) su_cmd_prompt=$(echo "$set_args"|cut -d';' -f3)
			## do not write if var already exist.
			[ -s $script_conf ] && [ $(grep -c "su_cmd_prompt=" $script_conf ) -eq 0 ] && \
			echo -e '## force admin su cmd :\nsu_cmd_prompt="'$su_cmd_prompt'"' >> $script_conf
			. $script_conf
		;;
	esac
}
module_dest_location(){
	case "$(distro_version)" in
		fedora* | rhel* | ovm*) echo "extra" ;;
		sles* | suse* | opensuse*) echo "updates" ;;
		debian* | ubuntu*) echo "updates/dkms" ;;
		arch*) echo "updates/dkms" ;;
		*) echo "extra" ;;
	esac
	return
}
dm_serv(){
	echo "$($d_sys show display-manager.service | sed -En "s/^Id=(.*)\..*$/\1/p")"
	return
}
zen_colors(){
	# pango colors
	end='</span>'
	v='<span color="'$main'" weight="normal" font="'$size0'" font_family="'$font0'">'	#green
	j='<span color="'$sub'">'			#orange/yellow
	y='<span color="'$log_msg'">'		#cyan/blue
	r='<span color="'$title'">'
	# big red orange title
	rBB='<span color="'$title'" weight="bold" font="20" font_family="'$font1'">'	#red
	# Big
	bf='<span font="'$size1'">'
	nf='<span font="'$size0'">'
	mf='<span font="'$(($size0+2))'">'
	sf='<span font="'$(($size0-2))'">'
	# Bold
	B='<span weight="bold">'
	vB='<span color="'$main'" weight="bold" font="'$size0'" font_family="'$font0'">'
	yB='<span color="'$log_msg'" weight="bold" font_family="'$font0'">'
	jB='<span color="'$log_warn'" weight="bold" font_family="'$font0'">'
	gB='<span color="'$log_grn'" weight="bold" font_family="'$font0'">'
	rB='<span color="'$log_err'" weight="bold" font_family="'$font0'">'
	# grey dash
	# 	ge='<span color="#68686F" weight="bold">' #68686F
	ge='<span color="#68686F">'
	nr='<span color="#000000">'
	## xterm colors
	xt_colors=" -fg '$fg_xterm' -bg '$bg_xterm'"
	xN='\e[0m'
	xB='\e[1m'
}
PCI_ID(){
	## graphic cards id
	i=0
	optimus=0
	test $UID = 0 && tee /sys/bus/pci/rescan <<<1 &>/dev/null
# 	sleep 1
	## rescan in case of device power switch off (nvidia-xrun, bbswitch, etc).
	pci_list=( "$(lspci -mnn | grep "VGA")" )
	IFS=$(echo -en "\n\b")
	for dev_slot in ${pci_list[@]}; do
		dev_n+=("$i")
		vnd+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^(.*) \[.*\]$/\1/p")")
		vnd_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
		if [[ "${vnd_id[$i]}" =~ "10de" ]]; then
			dev+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}'| sed -En "s/^.*\[(.*)\] \[.*\].*$/\1/p")")
			dev_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.* \[(.*)\]$/\1/p")")
			dev_name+=( "${dev[$i]}" ); install_dev="${dev[$i]}"
		else
			[ "${vnd_id[$i]}" = "8086" ] && dev+=("Intel Graphic") # d_name="${dev[$i]}" dev+=("Intel Graphic",i915)
			[ "${vnd_id[$i]}" = "1002" ] && dev+=("AMD Radeon") # d_name="${dev[$i]}" dev+=("AMD Graphic",flglx)
			[ "${vnd_id[$i]}" = "1022" ] && dev+=("AMD Embed") # d_name="${dev[$i]}" dev+=("AMD Graphic",radeon)
			dev_name+=( "modesetting" )
			optimus=$((optimus+1))
		fi
		slot+=("$(printf "$dev_slot"| awk '{print $1}')")
		slot_id+=("$(printf "$dev_slot"| awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^.*\[.*\] \[(.*)\].*$/\1/p")")
# 		((i++))
		i=$(($i+1))
	done
	[ $optimus -gt 0 ] && opti_preset=1
	if [ $i -gt 1 ]; then
		if ! [[ "${vnd_id[*]}" =~ "10de" ]]; then
			scan_alert="\n\nNvidia device was not scanned.\nRun again with root privilege and rescan pci bus."
		fi
	fi
	return
}
## If version is 'undifined', control if driver is initialy installed before starting some menu.
check_version(){
	if [ $from_install = 0 ]; then
		if ! [[ $(version) =~ [0-9]* || $(new_version) =~ [0-9]* ]]; then
			warn_log=$"$( cat <<-ERR
				${j}${bf}Version text file not found.${end}${end}

				Look like driver isn't installed initialy.
				Go to ${y}<b>» Main menu » Install drivers</b>${end} first.
			ERR
			)"
			ok_lbl=$"Ok"'!zen-ok' ; cancel_lbl=$"Close"'!zen-close'
			win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "zen-error"
			return 0
			base_menu
		fi
	fi
}

### SU, EXIT AND ERROR TOOLS
su_cmd(){
	local sudo_cmd
	if [ ${su_cmd_prompt} ]; then sudo_cmd="${su_cmd_prompt}"; else
		[ -e $(command -v sudo) ] && sudo_cmd="sudo -u" || sudo_cmd="su -l"
	fi
	if [[ -n "${@}" ]]; then
		eval ${sudo_cmd} $(def_user) ${@} # $cmd $opt_def $opt_val
	else
		echo "$sudo_cmd"
	fi
}
error()(
# exit code from dkms script devs.
   local msg=$(echo "${2}" | sed -n "s/<[^>]*>//g;p")
   exec >&2 ; echo ""; echo -en "${red}$msg_title${yel} at line ${grn}${1}${nc} : ${cya}${msg}${nc}\n"
)
die(){
	## pre-check example, case multi yad windows are pop up.
	## var need to be write at each yad pop level.
	# parent+=$(ps -C yad -o pid | sed -n '$p')
	## case one window:
	# [ -f "$(find -L $(kernel_src) -name "sign-file")" ] || die 0 "${LINENO}" "sign-file kernel script not found"
	## case more windows:
	# if [ ! -f "$(find -L $(kernel_src) -name "sign-file")" ];then echo -e "pass=1" >> $tmp_vars && die 0 "${LINENO}" "sign-file kernel script not found"; fi
	## sig term codes : 1 SIGHUP, 2 SIGINT, 3 SIGQUIT, 6 SIGABRT, 9 SIGKILL, 14 SIGALRM, 15 SIGTERM
	## syntax in context : die 0-9 "message" $1 <= error code to return with.
	ret=${1}; line=${2}; msg="${3}"; menu="${4}"
# 	shift
	[ ${ret} -ge 2 ] && msg_title=$"Warn" || msg_title=$"Error"
	## NOTE ret code has to be adapt by function case.
	# Display error Yad window if X is active.
	[ $(x_check) -gt 0 ] && error "$line" "$msg" || error "$line" "$msg"; win_yad_ret "${line}" "${msg}"
	[ ${ret} = 0 ] && ( $(kill_parent_pid) ; exit $ret ) # fatal, kill also yad parents
	[ ${ret} = 1 ] && exit $ret # fatal, plain exit
	[ ${ret} = 2 ] && return 0 # not fatal, just warning
	[ ${ret} = 3 ] && { # could be fatal if exit 1/0, else back to a previous menu.
		if [ "${menu}" ]&&[[ "${menu}" =~ [a-z] ]]; then
			if [ $task_opt -gt 0 ]; then exit 0; else $(${menu}); fi
		else
			return ${menu}
		fi
	}
	[ ${ret} = 4 ] && return 0 # same as die 2 but with report link displayed.
}
evac(){
# 	syntax : evac ${var} "menu1" "menu2|exit code"
	case ${1} in
		200) [[ "${3}" =~ [0-9] ]] && exit ${3} || $(${3});;
		100|*) [ $task_opt -gt 0 ] && exit 0 || $(${2}) ;;
	esac
}
DEV(){
	## syntax in X context :	DEV "message" "back menu"
	## syntax in tty context :	DEV "message" "exit 0"
	msg=${1}; menu="${2}"
	shift
	# Display Yad window if X is active only.
	if [ $(x_check) -gt 0 ]; then
		exec >&2 ; echo ""
		echo -en "${red}Developper message${yel} : ${grn}${msg} \n${cya}This function is not available yet or is under rewrite/inspection.\nIt will be hopefuly available soon.${nc}\n"
		[[ ${menu} =~ [0-9] ]] && exit ${menu}
	else
		win_yad_dev "${msg}" ; [[ ${menu} =~ [0-9] ]] && exit ${menu} || $(${menu})
	fi
# 	$(${menu})
}
uncompatible_kernel_alert(){
	local warn_log yad_warn compat_list='' ui_form
	if [ ${uncompatible_kernel} -gt 0 ]; then
		[ $compatible_kernel -gt 0 ] && compat_list="\n${ge}$compatible_kernel is a known working kernel.${end}"
		[ ${#drv_model[@]} -gt 1 ] && { exit_msg=$"Consider"; ui_form=0 ;} || { exit_msg=$"You can't try or consider"; ui_form=1 ;}
		warn_log=$"$( cat <<-WRN
			${r}KERNEL ALERT${end}
			${v}Driver's ${y}${drv_model[@]}${end} source code for ${j}$(new_version)${end} is known to having issues
			with ${j}${KERNEL}${end} kernel and wont compile without errors.

			${exit_msg} using an older kernel instead.${end}${compat_list}

		WRN
		)"
		cancel_lbl=$"Abort"'!zen-close'; ok_lbl="Let's try"'!zen-ok'
		yad_warn=$(win_yad_warns "${warn_log}" ${ui_form} "${ok_lbl}" "${cancel_lbl}" 0 "zen-error")
		if [ $yad_warn -ge 1 ]; then
			return 1
		fi
	fi
}
kill_parent_pid(){
	for pid in "${parent[@]}"; do
		[ "$(ps -p $pid| awk '/[0-9]/ {print $1}')" != '' ] && [ $? = 0 ] && kill -15 "$pid"
	done
}
list_kill_parent_pids(){
	if [ -n ${#parent[@]} ]; then
		## get the previous yad pid if any for die process
		pid_ctrl=$(ps -C yad -o pid | sed -En 's/^[ ]+([0-9]+$)/\1/;$p')
		## check if pid is already in list before adding
		[[ "${parent[@]}" =~ $pid_ctrl ]] || parent+=( $pid_ctrl )
		trap "[ \${#parent[@]} -gt 0 ] && \$(kill_parent_pid)" 1 2 # INT
	fi
}
debug_failure(){ # full debug failure function, to called from command line
	## in script synttax : trap 'debug_failure ${LINENO} "$BASH_COMMAND"' ERR
	local lineno=$1
	local msg=$2
	echo -en "${grn}Failed at $lineno${nc}: ${cya}$msg${nc}\n"
}

### INSTALL TOOLS
## dependencies control
dep_exec_check(){
	deplist=()
	## standard
	p_wget=$(command -v wget) || deplist+=("wget")
	p_gcc=$(command -v gcc) || deplist+=("gcc")
	d_yad=$(command -v yad) || deplist+=("yad")
	d_xdpy=$(command -v xdpyinfo) || deplist+=("xdpyinfo")
	d_ssl=$(command -v openssl) || deplist+=("openssl")
	d_randr=$(command -v xrandr) || deplist+=("xrandr")
	pk_exec=$(command -v pkexec) || deplist+=("polkit")
	d_sys=$(command -v systemctl)
	## sbin
	d_grub=$(find /usr/{sbin,local/sbin} -regextype sed -regex ".*grub[0-9]\?-.*"| sed -n "s/-.*$//;1p")
	p_dkms=/sbin/dkms || deplist+=("dkms")
	d_ldconfig=/sbin/ldconfig
	## initramfs_tools function provides ramfs tool.
	## kmod provides symlinks for:
	# lsmod        compat lsmod command
	# modinfo      compat modinfo command
	# modprobe     compat modprobe command
	# depmod       compat depmod command
	## nvidia binaries if any.
	d_nv_installer=${install_dir}/bin/nvidia-installer
	d_nv_settings=${install_dir}/bin/nvidia-settings
	d_nv_persistenced=${install_dir}/bin/nvidia-persistenced
	d_nv_probe=${install_dir}/bin/nvidia-modprobe
}
dep_lib_check(){
	# debian : linux linux-headers /usr/src/kernel-headers-$(uname -r)
	# arch : linux linux-headers /lib/modules/$(uname -r)build
   # mageia, mandriva : kernel-desktop-devel-latest /usr/src/linux-$(uname -r)
	# rpm base : kernel-devel kernel-headers /usr/src/linux-$(uname -r)
	# rh : kernel-devel kernel-headers /usr/src/kernels/linux-$(uname -r)
	if [ $resolve_dep = 0 ]; then
		case $(distro_version) in
			arch|manjaro) deplist+=("kernel-headers"); deplist+=("git") ;;
			rhel|fedora|centos) deplist+=("kernel-headers"); deplist+=("kernel-devel"); deplist+=("git") ;;
			mageia|mandriva) deplist+=("kernel-desktop-devel-latest"); deplist+=("git") ;; # deplist+=("kernel-desktop-devel");;
			ubuntu|mint|debian) deplist+=("kernel-headers"); deplist+=("kernel-devel-$(uname -r)"); deplist+=("git") ;;
# 			*) ;;
		esac
		return
	fi
}
dep_control(){ # yad and xterm autoinstall here.
	if [ -x $(pkg_installer) ]; then
		p_xterm=$(command -v xterm) || (
		echo -e $"${red}XTERM and YAD are missing, installing ...${nc}"; $(pkg_install_cmd) xterm yad;
		export p_xterm=$(command -v xterm)
		export d_yad=$(command -v yad)
		)
		if [ "${#deplist[*]}" -gt 0 ] ; then
			for d in ${deplist[@]}; do
				dep_text+=("$d, ")
			done
			if [ $d_yad ]; then
				warn_text=$"$(
				cat <<-DEP
					<b>Script Dependencies Check</b>

					Required dependencies are not met.
					${dep_text[@]} are missing.
				DEP
				)"
				if [ $UID = 0 ]; then
					warn_log=$"$(
					cat <<-DEP
						$warn_text

						Will you install them now ?
					DEP
					)"
					ok_lbl=$"Install"'!zen-ok' ; cancel_lbl=$"Close"'!zen-close'
					win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 ""
					if [ $_exit = 0 ]; then
						y_text=$"Depencies installation, please wait . . ."
						local pulse=1 log=1 hold=1 hide_txt=1
						win_log_options
						{ timeout=30 ;{
							$(pkg_install_cmd) ${deplist[*]} 2>&1 | \
							while read line; do echo "# ${line}"; done
							echo -e "# "
							$esc_message
							sleep 2
						}& eval lpid=$!; y_pulse; } | win_yad_progress
						sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
					else
						exit 0
					fi
				else
					warn_log=$"$(
					cat <<-DEP
						$warn_text

						<b>Your are not administrator</b>.
						You need to restart with adminsitratior privileges
						or use your packages manager to install them.
					DEP
					)"
					die 3 ${LINENO} "${warn_log}" 1
					exit 0
				fi
			else
				if [ $UID = 0 ]; then
					EXEC=$"$(
						cat <<-DEP
							read -p "Will you install them now ? (Y/N) :" confirm
							if [[ "\$confirm" =~ [yY] ]]; then
								echo -e "\n${grn}Depencies installation, please wait . . .${nc}\n"
								$(pkg_install_cmd) ${deplist[*]}
								sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
							else
								echo -e "\n${red}Those dependencies are mandatory for Zenvidia.${nc}\n"
								echo -e "If you don't want Zenvidia to install them automatically,"
								echo -e "you need to use your packages manager instead"
								echo -e "BYE !"
							fi
						DEP
					)"
				else
					EXEC=$"$(
						cat <<-DEP
							echo -e "Zenvidia is start without admin privileges."
							echo -e "You need to restart with ${red}Zenvidia (admin)${nc} to install them."
						DEP
					)"
				fi
				w_text=$"$(
					cat <<-DEP
						echo -e "${red}Script Dependencies Check${nc}\n"

						echo -e "Required dependencies are not met.\n"
						echo -e "${dep_text[*]}\n"
						$EXEC
						echo -e "\n${cya}*****  Close window to escape *****${nc}"
					DEP
					)"
				primary_dsp=$(xrandr --current| grep -w "connected"| grep primary)
				term_x_dsp=$(printf "$primary_dsp"| grep -o "[0-9]\{3,4\}[x]"|sed -n "s/x//p")
				xt_options=' -hold -fn 8x13 -geometry 80x24+'$[ ( ($term_x_dsp-660)/2) ]'+0'
				$p_xterm $xt_options -e "$w_text"
			fi
			## check if datas comes from special distro config.
			grep -E "^[ ]?deplist" $(user_CF_DIR)/distro.conf &>/dev/null
			if [ $? -eq 0 ]; then
				sed -Ei "s/^[ ]?(deplist.*)$/# \1/" $(user_CF_DIR)/distro.conf
			fi
			dep_exec_check
		fi
		return
	else
		die 1 ${LINENO} $"${red}NO PACKAGE INSTALLER FOUND, ABORTING.${nc}\n" ""
	fi
# 	unset deplist
}
connected(){ ping -c2 www.nvidia.com &>/dev/null; echo "$?" ;}
# connected(){ echo 1 ;}
connection_control(){ ### Depracated
	if [ $(connected) -gt 1 ]; then
		w_text=$"$( cat <<-MSG
			No internet connection detected.
			A valid network connection is required for any download.
		MSG
		)"
		echo -e "${red}$w_text${nc}"
		cnx_msg=$"NONE"
		echo 1
		die 2 ${LINENO} "$w_text" ""
	else
		cnx_msg=$"Connected"
		echo 0
	fi
}
connection_check(){
	if [ $(connected) -gt 1 ]; then
		w_text=$"$( cat <<-MSG
			No internet connection detected.
			A valid network connection is required for any download.
		MSG
		)"
		die 3 ${LINENO} "$w_text" "base_menu"
	fi
}
### INSTALL & COMPIL SECTION ###
## VARS
zen_version(){
	[ -f $(user_CF_DIR)/zen_version ] && cat $(user_CF_DIR)/zen_version || cat ${nvdir}/zen_version
}
dkms_version(){
	## depending of the age/kind of distributions DKMS could be 3.0.x or 3.1.x version.
	## Behaviour of AUTOINSTALL and no-autoinstall is not the same for each
	$p_dkms --version | sed -n "s/^.*-//p" | awk -F '.' '{print $1$2}'
}
## nvidia driver vars [in functions)
## some sets have to be place as function to be re-used at multi levels.
nv_pci_device(){
	lspci -mnn | grep "VGA.*NVIDIA" | awk -F '["]?[.*| ]?"' '/1/ {print $4}' | sed -En "s/^(.*\[(.*)\]).*\[.*\].*$/\2/p" | uniq
}
nv_pci_vnd(){ ### TEST not used yet
	lspci -mnn | grep "VGA.*NVIDIA" | awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^·*\[(.*)\].*$/\1/p"
}
nv_pci_vnd_id(){ ### TEST not used yet
	lspci -mnn | grep "VGA.*NVIDIA" | awk -F '["]?[.*| ]?"' '/1/ {print $3}' | sed -En "s/^(·*)\[.*\].*$/\1/p"
}
nv_kernel_check(){
	## not all distro return kernel version the same way,
	## we need to insert a 0 to get a proper value.
	echo "$KERNEL" | awk -F'.' '{print $1$2}'
	return
}
nv_modules_presence(){
	stat /usr/lib/modules/$KERNEL/$(module_dest_location)/nvidia.ko* &>/dev/null && echo 1 || echo 0
}
version(){
	if [ -f $(user_CF_DIR)/version.txt ]; then
		cat $(user_CF_DIR)/version.txt
	else
		[ $(nv_modules_presence) -gt 0 ] && /sbin/modinfo -F version nvidia || echo 0
	fi
	return
}
version_license(){
	[ $(nv_modules_presence) -gt 0 ] && /sbin/modinfo -F license nvidia || echo "Not define yet"
	return
}
new_version(){
	if [ $from_install = 1 ]; then
			if [ "$run_pkg" ]; then
				echo "$run_pkg" | sed -En "s/^.*-(.*)/\1/; s/.run//g;p"
			else
				echo "$LAST_PACK"
			fi
	else
		echo "$(version)"
	fi
	return
}
old_version(){
	if [ -s $tmp_old ]; then cat $tmp_old; else [ $(nv_modules_presence) -gt 0 ] && /sbin/modinfo -F version nvidia -k $KERNEL || echo "0"; fi
	return
}
nv_old(){
	local count_array part prefix='' suffix='' IFS=' '
	count_array=( $(echo "$(old_version)"|tr . ' ') )
	for c in ${count_array[@]}; do
		(( ${#c} < 3 )) && prefix=0 || prefix=''
		part+=$(printf ${prefix}$c)
	done
	[ ${#count_array[*]} -eq 3 ] || suffix='000'
	echo "${part[*]}$suffix"
	return
}
nv_new(){
	if [ "$(new_version)" ]&&[ "$(new_version)" != "0" ]; then
		local count_array c part prefix='' suffix='' local IFS=' '
		count_array=( $(echo "$(new_version)"|tr . ' ') )
		for c in ${count_array[@]}; do
			(( ${#c} < 3 )) && prefix=0 || prefix=''
			part+=$(printf ${prefix}$c)
		done
		[ ${#count_array[@]} -eq 3 ] || suffix='000'
		echo "${part[*]}$suffix"
	else
		echo "$(version)"| sed -n "s/\.//g;p"
	fi
	return
}
# mod_installed(){ # used by nv_build_dkms only # [ko\|ko.xz]
#  	test -d $kernel_path && find $kernel_path -name "nvidia.ko*" -print0 | xargs -0 /sbin/modinfo -F version
#  	return
# }
old_inst(){ # used by nv_build_dkms only
	if [ $(old_version) ]; then
		local count_array part prefix='' suffix=''
		local IFS=' '
		count_array=( $(echo "$(old_version)"|tr . ' ') )
		for c in ${count_array[@]}; do
			(( ${#c} < 3 )) && prefix=0
			part+=$(printf ${prefix}$c)
		done
		[ ${#count_array[@]} -eq 3 ] || suffix='000'
		echo "${part[*]}$suffix"
	else
		echo "0"
	fi
}
chk_family(){
	[ -n $(new_version) ] && echo "$(new_version)"| cut -d'.' -f1 || echo '0'
}
chk_old_family(){
	[ -n $(old_version) ] && echo "$(old_version)"| cut -d'.' -f1 || echo '0'
}
## define installed driver version, if any
drv_installed(){
	if [ "$(version)" == "0" ]; then
		echo $"not installed"
	else
		echo $(version)
	fi
}

## OPTIONS
## gcc and other compatibility control
gcc_compil_vars(){
	if [[ $(gcc --version | grep "gcc") ]]; then
		GCC=$(gcc --version | grep "gcc" | sed -n "s/^.*) //p"| awk '{print $1}')
	else
		GCC='none'
	fi
	KERNEL=$(uname -r)
	kernel_path="/lib/modules/$KERNEL/$(module_dest_location)/"
	if [ $UID = 0 ]; then grub_cfg=$(find /boot -wholename "*/grub.cfg"|grep -iv "efi"); grub_def=/etc/default/grub; fi

}
xterm_display_vars(){
	xt_options=''
	local xt_colors='' xx_hold x_pixel x_milli pixel
	[ $xt_hold = 0 ]|| xx_hold='-hold'
	# sets for xterm
	x_pixel=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.* ([0-9]{3,5})x([0-9]{3,5}) .*$/\1;\2/1p")
	x_milli=$($d_xdpy | grep -A1 "screen #0"| sed -En "s/^.*\(([0-9]{3,4})x([0-9]{3,4}).*\).*$/\1;\2/1p")
	term_x_dsp=$(printf "$x_pixel"| cut -d';' -f1)
	if [ $xt_hold = 1 ]; then
		x_esc_message=$"\n${nc}*****  Close window to escape *****"
		x_sleep=''
	else
		x_esc_message=$"\n${nc}*****  Window will auto-close in ${xt_delay} seconds *****"
		x_sleep="sleep ${xt_delay}"
	fi
	# xt_options="$xt_colors$xx_hold -fn 8x13 -geometry 80x24+"$[ ( ($(printf "$x_pixel"| cut -d';' -f1)-660)/2) ]"+0"
	pixel=$[ ($(printf "$x_pixel"| cut -d';' -f1)-660)/2 ]
	xt_options=( $xt_colors $xx_hold -fn 8x13 -geometry 80x24+$pixel+0 )
}
nv_installer_check(){
	if [ -s ${d_nv_installer} ]; then
		NV_bin_ver=$($d_nv_installer -v | grep "nvidia-installer"|awk '{print $3}')
	else
		NV_bin_ver='none'
	fi
}
## system pre config.
nv_open_modules_set(){
	# nvidia_installer give the possibility to use open driver version, but not the possibility to choose
	# between open or proprietary version by installing both, or just test open only.
	# let's do this.
	if [ $open_wrn = 1 ]; then
		if [ $extract_open = 1 ]; then
			if [ $use_open -ne 1 ]; then
				local yad_warn
				_title="$_zen_title"
				_text=$"$(cat <<-MSG
					${jB}Nvidia Open Source Modules${end}
					${vB}Since 515 driver series, it is possible to use nvidia open source drivers
					By default, Zenvidia will build them alongside the main ones.

					AT THIS POINT, OPEN SOURCE DRIVERS WILL BE ONLY BUILD.
					You will be able to switch between version with the ${j}Open Driver Switch Tool${end}
					in ${j}Configuration and Tools${end} menu (restart Zenvidia is mandatory).

					${j}WARNING ${end}:${v}<i> Open drivers are in still in early state, many features are not
					accessible at this point.
					Check progress in Nvidia Changelog update regulary</i>.${end}

					Do you want to build open source drivers ?${end}
				MSG
				)"
				warn_log=$_text
				ok_lbl=$"Yes, please"'!zen-ok' ; cancel_lbl=$"No thanks"'!zen-close'
				yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
				if [ $yad_warn -gt 1 ]; then exit 1; else
					if [ $yad_warn = 0 ]; then
						open_drv=1; use_open=0
					else
						open_drv=0; use_open=0
					fi
					sed -Ei "s/^(use_open)=[0-9]$/\1=$use_open/" $basic_conf
					sed -Ei "s/^(open_drv)=[0-9]$/\1=$open_drv/" $basic_conf
					if [ $first_open = 1 ]; then
						_text=$"$(cat <<-MSG
							${jB}Nvidia Open Source Modules${end}

							${j}WARNING ${end}:${vB}By default, Zenvidia send alert about open driver building,
							If you select ${j}<i>NO</i>${end} here, the previous window won't be displayed again.

							${v}<i>(Choice will be saved in configuration file and could be changed)</i>${end}

							Do you want to be warn at each drivers upgrade ?${end}
						MSG
						)"
						warn_log=$_text
						ok_lbl=$"Yes, please"'!zen-ok' ; cancel_lbl=$"No thanks"'!zen-close'
						yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
# 						if [ $yad_warn -ge 1 ]; then exit 1; fi
						if [ $yad_warn -gt 1 ]; then exit 1; else
							if [ $yad_warn = 0 ]; then
								first_open=0; open_wrn=1
							else
								first_open=0; open_wrn=0
							fi
							sed -Ei "s/^(open_wrn)=[0-9]$/\1=$open_wrn/" $basic_conf
							sed -Ei "s/^(first_open)=[0-9]$/\1=$first_open/" $basic_conf
						fi
					fi
				fi
			fi
		fi
	fi
	## check for open drivers source dir in tree
	if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
		cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open /usr/src/open-nvidia-$(new_version)
	fi
}
gcc_options_check(){
	# test driver code compilator version __GNUC__, __GNUC_MINOR__
 	if [ "$basic_conf" != '' ]; then
		if [ $(grep -E -c "gcc_mismatch" $basic_conf) -gt 0 ]; then
			if [ $gcc_mismatch = 1 ]; then ignore_mismatch="IGNORE_CC_MISMATCH=1"; else ignore_mismatch=''; fi
			export IGNORE_CC_MISMATCH=$gcc_mismatch
		fi
	fi
}
proc_options(){
	proc=$(grep -E -c "processor.*[0-9]{,2}" /proc/cpuinfo)
	## Select tuen compression coantainer for backup.
	if [ $use_gzip -eq 0 ]; then
	## XZ, ZST compression cab is not made for weak processors, try at least to define a minimum number of cores required.
 		#[ $proc -gt 12 ] && ZIP='ZST' && zip_opt='zst' && zip_ex='.zst'
		[ $proc -gt 8 ] && ZIP='XZ' && zip_opt='xz' && zip_ex='.xz' && return
		[ $proc -le 8 ] && ZIP='GZIP' && zip_opt='gzip' && zip_ex='.gz' && return
	else
		ZIP='GZIP'; zip_ex='.gz'
	fi
}
## PAY ATTENTION : With RT kernel, drivers could install properly but they could also not init at Xorg start.
## Do not ever overwrite current used kernel by RT one.
is_RT(){
	[[ -n $(grep "PREEMPT_RT" /boot/config-$KERNEL) && \
	$(grep -c "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL) -gt 0 ]] && echo 1 || echo 0
}
rt_options(){
# test if kernel is realtime.
	local yad_warn
	if [ $(is_RT) = 1 ]; then
		## user warning
		warn_log=$"$( cat <<-TXT
			${rBB}REALTIME Kernel Detected${end}
			${vB}ATTENTION :${v} You are about to install driver on a realtime kernel.

			Don't forget Nvidia drivers is not normaly made for realtime.
			Troubles init at boot time could happen.
			Think about making a root partition backup if you have no fallback.

			${j}"<b> dd if=/dev/sdxx of=root.img bs=1024k status=progress </b>"${end}
			(from a live usb)

			Do you really want to use compilation over realtime kernel ?${end}${end}
			TXT
		)"
		# yes 0, no 1
		ok_lbl=$"Proceed"'!zen-ok' ; cancel_lbl=$"Abort"'!zen-close'
		yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "zen-warning")
		if [ $yad_warn -gt 1 ]; then exit 1; else
			if [ $yad_warn = 0 ]; then
				ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
				export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
			else
				base_menu
			fi
		fi
	fi
}

### TOOLS ###
## initramfs tools detect and config.
initramfs_tools(){
	## try to find 'dracut' first, then fallbback to 'update-initramfs' if not found.
	## look the possibility to add /usr/bin/mkinitcpio -p linux. how-to ?
	## if none are found, disable initramfs rebuild and warn.
	for init_sys in {dracut,update-initramfs,mkinitcpio}; do
		command -v $init_sys &>/dev/null && {
		[ "$init_sys" = "dracut" ] && echo "$init_sys -f --kver"
		[ "$init_sys" = "update-initramfs" ] && echo "$init_sys -u -k"
		[ "$init_sys" = "mkinitcpio" ] && echo "$init_sys -p linux --kernel"
		} || echo 0
	done
}
test_ramfs_tool(){
## detect if ramfs tool exist then send to initramfs_warn if none.
	test "$(initramfs_tools)" = 0 && echo 0 || echo 1
}
initramfs_warn(){
	if [ $(test_ramfs_tool) = 0 ]; then
		## send alert
		## and ask to proceed with modprobe reload if initramfs tool is no detected.
		local yad_warn
		warn_log=$"$( cat <<-WRN
			${j}<b>No tool were found to rebuild initramfs</b>${end}
			Modprobe reload could work for the used kernel,
			but probably not for an extra kernel.
			Updated Modules wont probably load at reboot.

			You have been warn !
		WRN
		)"
		ok_lbl=$"Proceed"'!zen-ok' ; cancel_lbl=$"Abort"'!zen-close'
		yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "zen-warning")
		if [ $yad_warn -gt 1 ]; then exit 0; else
			if [ $yad_warn = 1 ]; then
				exec_mod_tool=0
				base_menu
			else
				exec_mod_tool=1
			fi
		fi
	fi
}
## commands
exec_depmod(){
	 if [[ -f /boot/System.map-$1 ]]; then
        /usr/sbin/depmod -a "$1" -F "/boot/System.map-$1"
    else
        /usr/sbin/depmod -a "$1"
    fi
    return
}
exec_mod_load(){
	## from DKMS script (partly)
	find /sys/devices -name modalias -print0 | xargs -0 cat | xargs /sbin/modprobe -a -b -q &
	sleep 1
	command -v restorecon &>/dev/null && restorecon "/boot/symvers-$KERNEL.*"
	if [ -f /lib/systemd/system/systemd-modules-load.service ]; then
		$d_sys restart systemd-modules-load.service
	fi
	return
}
exec_initramfs(){
## rebuild initramfs if modules reload service found is uselees in the case.
	## progress message is place before fuction exec and formated like this :
	## progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; } for zenity.
	## progress_msg(){ echo -en "\r# ($m%) - Rebuilding INITRAMFS"; } for terminal.
	## last 'echo' is for zenity progress bar only. ex:
	# 	echo "# Updating $KERNEL initramfs."; sleep 2
	# 	progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; }
	# 	m=1 ;
	progress "$(initramfs_tools) $KERNEL" "${1}" "${2}" #; . $tmp_count
	return $?
}
nv_persistenced(){
	## nvidia percistenced allow GPU to be pre init in some case.
	nv_persist_ctl=/lib/systemd/system/nvidia-persistenced.service
	if [[ $use_persistenced = 1 || $use_open = 1 && $(chk_family) -lt 555 && $(chk_family) -ge 535 ]]; then
		[ -f $nv_persist_ctl ] || { touch $nv_persist_ctl; chmod 644 $nv_persist_ctl; nv_persistenced_conf;}
# 		nv_persistenced_conf
		$d_sys daemon-reload
		$d_sys enable nvidia-persistenced.service
		$d_sys start nvidia-persistenced.service
	else
		[ -f $nv_persist_ctl ] && {
			$d_sys disable nvidia-persistenced.service
			$d_sys stop nvidia-persistenced.service
			$d_sys daemon-reload
		}
	fi
}
back_old_driver(){
	mkdir -p $nvtmp/old_kernel/
	[ $(ls -1  $kernel_path | grep -c "nvidia") -gt 0 ] && cp -f $kernel_path/nvidia* $nvtmp/old_kernel/
}
restore__driver(){ # WATCH
	if [ -f $nvtmp/${1}/nvidia.ko* ]; then
		echo -e $"# ${nf}${j}** Restoring drivers to $kernel_path ** ${end}${end}"; sleep 1
		cp -f $nvtmp/${1}/nvidia* $kernel_path
		if [ -d $nvtmp/${1}/dkms/$compiled_driver/ ]; then
			echo -e $"# ${nf}${j}** Restoring drivers dkms folders to dkms path ** ${end}${end}"; sleep 1
			mkdir -p /var/lib/dkms/$compiled_driver
			cp -rf $nvtmp/${1}/dkms/$compiled_driver/* /var/lib/dkms/$compiled_driver/
		fi
		m=1; do_slp=1
		progress "( exec_depmod "$KERNEL" )" $"\${ge}\${sf} * Depmod $KERNEL modules - \$m sec.\${end}\${end}" "$m"
	fi
}
restore_pcks_cmd(){
	# p: preserve perm, h: preserve sym, f: file.
	local zip_type zip_opt msg verbose=''
	if [ $(x_check) -gt 0 ]; then
		eval res_version=${1}
		zip_type=$(ls -1 $nv_backup_dir/nvidia.$res_version.tar.* | sed -n 's/.*\.//;1p')
	else
		zip_type=$res_suffix
	fi
	[ "$zip_type" = "gz" ] && zip_opt='gzip'
	[ "$zip_type" = "xz" ] && zip_opt='xz'
	[ "$zip_type" = "zst" ] && zip_opt='zstd'
	if [ $(x_check) -gt 0 ]; then
		echo -e $"# ${yel}Uncompressing $res_version archive for $KERNEL${nc} :\n"
		verbose='-v'
	else
		if [ $from_install = 1 ]; then
			msg=$"\${j}(\$m s)\${end}\${ge}\${sf} - Restoring from nvidia.$res_version.tar.$zip_type\${end}\${end}"
		else
			msg=$"(\$m sec.) - Restoring from nvidia.$res_version.tar.$zip_type"
		fi
	fi
	m=1; do_slp=1
	progress "tar --$zip_opt $verbose -xf $nv_backup_dir/nvidia.$res_version.tar.$zip_type -C /" "$msg" "$m"
	ldconfig
}
restore_broken_install(){ # for old driver install method only.
	# restore previous libs from backup if exist, then restore saved drivers.
	local res_version res_suffix
	if [ $nv_old -gt 0 ]; then
		if [ -f $nv_backup_dir/$(old_version).tar.* ]; then
			echo -e $"# ${j}<b>Restoring $(old_version) libraries installation</b>${end}"
			res_version=$(old_version)
			res_suffix=$(ls -1 $nv_backup_dir/$res_version.tar.* | sed -n 's/.*\.//;1p')
			restore_pcks_cmd
			[ $(nv_modules_presence) -gt 0 ] && \
			if [[ ! "$(/sbin/modinfo -F version nvidia -k $KERNEL)" =~ $(old_version) ]]; then
				# old_kernel point the backup dir name.
				restore__driver "old_kernel"
			fi
		else
# 			local yad_warn
			warn_log=$"$( cat <<-WRN
				${j}NO BACKUP ARCHIVE FOUND${end}
				There is no backup to restore.
				${y}You need to reinstall completly the driver package.${end}
			WRN
			)"
			die 3 ${LINENO} "$warn_log" 1
		fi
	fi
	return
}
## configuration
dm_service_patch(){
	local ExecStartPre=$(command -v zenvidia-modules-reload)
	local ExecStart=$(command -v $(dm_serv))
	## make dm.service backup
	if [ -e $systemd_dir/$(dm_serv).service ]; then
		[ -e $systemd_dir/$(dm_serv).service.bak ] || cp -f $systemd_dir/$(dm_serv).service $systemd_dir/$(dm_serv).service.bak
		if [ $(grep -c "$ExecStartPre" $systemd_dir/$(dm_serv).service) -eq 0 ]; then
			[ $(grep -c "$ExecStart" $systemd_dir/$(dm_serv).service) -gt 0 ] || ExecStart=$(sed -n "s/^ExecStart=\(.*\)/\1/p" $systemd_dir/$(dm_serv).service)
			if [ $from_install = 1 ]; then
				echo $"# ${v}${j}($n%)${end} - Patching $(dm_serv).service for driver load at session restart (experimental)${end}"
			else
				echo $"# Patching $(dm_serv).service for driver load at session restart (experimental)."
			fi
			sed -Ei 's|^(ExecStart='${ExecStart}')$|ExecStartPre='${ExecStartPre}'\n\1|' $systemd_dir/$(dm_serv).service
			sleep 2
			n=$[ $n+2 ]; echo "$n"
		fi
		$d_sys daemon-reload
	fi
}
restart_dm_warn(){ # WATCH
	# can be potentially add : gdm, sddm, lightdm, lxdm (gdm,kdm,xdm,lightdm,lxdm,slim,sddm)
	local yad_warn reboot
	if (( $(chk_family) <= $(chk_old_family) )); then
		warn_log=$"$(cat <<-MSG
			$warn_log_title
			${v}Restart display manager service${end} (${y}experimental${end})

			This is a experimental feature allowing drivers to be relaod
			at simple display manager restart.

			Potentialy usable : gdm, sddm, lightdm, lxdm and kdm (sddm).
			(lighdm only tested at this point).

			Be aware that system driver management will be complete only
			after system reboot.

		MSG
		)"
		# win_yad_warns
		ok_lbl=$"Yes"'!zen-ok' ; cancel_lbl=$"No, I will reboot"'!zen-undo'
		reboot=0
	elif (( $(chk_family) > $(chk_old_family) )); then
		warn_log=$"$(cat <<-MSG
			$warn_log_title
			${v}Restart display manager service${end} (${y}unavailable${end})

			$(chk_family) driver family is a greater serie than $(chk_old_family).
			Nvidia firmware has been probably upgrade to a highter level.

			You need to reboot the system for all change to take effect.

		MSG
		)"
		ok_lbl=$"Yes, reboot"'!zen-ok' ; cancel_lbl=$"No, I will reboot"'!zen-undo'
		reboot=1
	fi
	yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
	if [ $yad_warn = 0 ]; then
		[ $reboot = 0 ] && { IFS=$ifs; touch /var/run/nv-modules-reload.pid; $d_sys restart display-manager.service; }
		[ $reboot = 1 ] && { $d_sys reboot; }
	fi
	return
# 	shift
}
nv_persistenced_conf(){
	## NOTE : ExecStart could be added a multiple time.
	cat <<-SYS > $nv_persist_ctl
		[Unit]
		Description=NVIDIA Persistence Daemon
		Wants=syslog.target

		[Service]
		Type=forking
		PIDFile=/var/run/nvidia-persistenced/nvidia-persistenced.pid
		#Restart=always
		ExecStart=$d_nv_persistenced --user $(def_user) --persistence-mode --verbose
		ExecStopPost=/bin/rm -rf /var/run/nvidia-persistenced

		[Install]
		WantedBy=multi-user.target
		SYS
}
nv_open_switch(){ # WATCH
	local probe_open=/etc/modprobe.d/open-NVIDIA.conf
	reverse_conf(){
		[ $open_drv -ne $old_open_drv ] && { sed -Ei "s/^(open_drv)=.*$/\1=$old_open_drv/" $basic_conf
			eval open_drv=$old_open_drv ;}
		[ $use_open -ne $old_use_open ] && { sed -Ei "s/^(use_open)=.*$/\1=$old_use_open/" $basic_conf
			eval use_open=$old_use_open ;}
		die 3 ${LINENO} "$reverse_err_msg" "base_menu"
	}
	local yad_warn drv_on drv_off license warn_log_title
	if [[ $open_drv -eq 1 && $use_open -ne $old_use_open ]]; then
			if [ $use_open -eq 1 ]; then
				drv_on='open-nvidia'
				drv_off='nvidia'
			else
				drv_on='nvidia'
				drv_off='open-nvidia'
			fi
			warn_log=$"$( cat <<-MSG
				${j}${bf}$drv_on switch${end}${end}
				${v}You are going to switch from ${j}$drv_off${end} to ${j}$drv_on${end}
				Are you sure ?${end}
			MSG
			)"
			# win_yad_warns
			ok_lbl=$"Yes, switch to $drv_on"'!zen-ok' ; cancel_lbl=$"No, keep $drv_off"'!zen-undo'
			yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
			if [ $yad_warn -ge 1 ]; then [ $task_opt -gt 0 ] && exit 0 || menu_modif; fi

			## Switch exec start here
			y_text=$"DRIVER SWITCH from DKMS ${j}$drv_off${end} to ${j}$drv_on${end} build"
			local pulse=1 log=1 hold=1 hide_txt=1
			win_log_options
			{	timeout=30
			{	echo -e $"# ${v}Switching from ${y}$drv_off${end} to ${y}$drv_on.${end}${end}"
				## 6 ops for progress.
				if [ -d /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module ]; then
					cp -f /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
					echo -e $"# ${v}Depmod ${j}$KERNEL${end} modules ...${end}"
					sleep 2
					m=1; do_slp=1
					progress "( exec_depmod "$KERNEL" )" $"\${ge}\${sf} * Depmod $KERNEL modules (\$m sec.)\${end}\${end}" "$m"
				else
					## NOTE : in case of a recent kernel update, only the predifined type with AUTOINSTALL="yes"
					## is compile and install by dkms and thus, the other var/lib/dkms module dir doesn't exist.
					## It is there needing to recompile the all nvidia and open-nvidia.
					nv_build_dkms
				fi
				if [[ $drv_on == "nvidia" ]]; then
					license="NVIDIA"
				else
					license="Dual MIT/GPL"
				fi
				if [[ "$(/sbin/modinfo -F license $kernel_path/nvidia.ko*)" == "$license" ]]; then
					echo -e $"# ${v}License is $license${end}"
				else
					echo -e $"# ${r}ERROR!${end}${y}: License is still $license, reversing all.${end}"
					reverse_err_msg=$"# ${r}ERROR!${end}${y}: License is still $license, reversing all.${end}"
					reverse_conf
				fi
				sleep 2
				## add or remove open-driver kernel options.
				if [ $use_open -eq 1 ]; then
					if [ $(chk_family) -lt 545 ]; then
						echo -e $"# ${v}Set ${y}$drv_on${end} kernel options.${end}"
						cat <<-CONF > $probe_open
							options nvidia NVreg_OpenRmEnableUnsupportedGpus=1
						CONF
					fi
				else
					echo -e $"# ${v}Unset ${y}$drv_off${end} kernel options.${end}"
					[ -f $probe_open ] && rm -f $probe_open
				fi
				[ $(chk_family) -ge 535 ] && nv_persistenced
				echo -e $"# ${v}Re-create ${j}$KERNEL${end} initramfs ...${end}"
				sleep 2
				m=1; do_slp=1
				#rebuild initramfs
				if [ $exec_mod_tool = 1 ]; then
					echo -e $"# ${v}Exec ${j}$KERNEL${end} modules reload${end}"; sleep 2
					exec_mod_load
				else
					## rebuild iniramfs first.
					echo -e $"# ${v}Exec ${j}$KERNEL${end} modules initramfs update${end}"; sleep 2
					exec_initramfs $"\${ge}\${sf} * Exec $KERNEL modules iniramfs (\$m sec.)\${end}\${end}" "$m"
					echo -e $"# ${v}Restore ${j}$KERNEL${end} modules selinux connection ...${end}"
					sleep 2
					## systemctl restart systemd-modules-load.service
					exec_mod_load
				fi
				sleep 2
				## add no-autoinstall blank file
				if [ $(dkms_version) -lt 31 ]; then touch /etc/dkms/no-autoinstall; fi
				## set DKMS AUTOINSTALL values for each driver type.
				echo -e $"# ${v}Set ${y}$drv_on${end} DKMS AUTOINSTALL option to \"yes\".${end}"
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/$drv_on-$(version)/dkms.conf
				## remove blank lines ?
				sed -ni "s/AUTOINSTALL.*$//g;p" /usr/src/$drv_off-$(version)/dkms.conf
				## set diplayed license by driver type.
				sleep 2
				echo -e "# "
				echo -e $"# ${v}Driver ${y}$drv_on${end} switch done.${end}"
				sleep 2
				echo -e $esc_message
				$x_sleep
				sed -Ei "s/^(use_open)=.*$/\1=$use_open/" $basic_conf
			} & eval lpid=$!; y_pulse; } | win_yad_progress
			warn_log_title=$"${j}${bf}$drv_on switch${end}${end}"
			[ -e $systemd_dir/$(dm_serv).service ] && restart_dm_warn
	else
		if [ $open_drv -ne $old_open_drv ]; then
			warn_log=$"$( cat <<-MSG
			${j}${bf}Open Driver removal${end}${end}
			${v}You are going to remove open source driver from driver tree.
			Are you sure ?${end}
			MSG
			)"
			# win_yad_warns
			ok_lbl=$"Yes, remove"'!zen-ok' ; cancel_lbl=$"No, preserve"'!zen-undo'
			yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
			if [ $yad_warn -ge 1 ]; then [ $task_opt -gt 0 ] && exit 0 || menu_modif; fi

			## remove dkms driver tree.
			y_text=$"Open Source Drivers deletion"
			local pulse=1 log=1 hold=1 hide_txt=1
			win_log_options
			{	timeout=30
			{	sleep 2
				## 7 ops progress.
				echo -e $"# ${v}Remove ${j}open source${end} drivers from DKMS tree${end}"
				/usr/sbin/dkms remove -m "open-nvidia"/$(version) -all
				sleep 2
				echo -e $"# ${v}Restoring ${y}default${end} Nvidia drivers.${end}"
				cp -f /var/lib/dkms/nvidia/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
				sleep 2
				echo -e $"# ${v}Depmod ${j}$KERNEL${end} modules ...${end}"
				m=1; do_slp=1
				progress "( exec_depmod "$KERNEL" )" $"\${ge}\${sf} * Depmod $KERNEL modules (\$m sec.)\${end}\${end}" "$m"
				sleep 2
				if [[ "$(/sbin/modinfo -F license $kernel_path/nvidia.ko*)" == "NVIDIA" ]]; then
					echo -e $"# ${v}License is back to NVIDIA${end}"
				else
					echo -e $"# ${r}ERROR!${end}${y}: License is still Dual MIT/GPL, abort.${end}"
					reverse_err_msg=$"# ${r}ERROR!${end}${y}: License is still Dual MIT/GPL, abort.${end}"
					reverse_conf
					exit 1
				fi
				echo -e $"# ${v}Restore ${j}$KERNEL${end} modules connection ...${end}"
				sleep 2
				## systemctl restart systemd-modules-load.service
				exec_mod_load
				## remove no-autoinstall blank file
				test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
				echo -e $"# ${v}Set Nvidia DKMS AUTOINSTALL option to \"yes\".${end}"
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/nvidia-$(version)/dkms.conf
				sed -n "s/AUTOINSTALL.*$//g;p" /usr/src/open-nvidia-$(version)/dkms.conf
				sleep 2
				echo -e $"# ${v}Unset ${y}$drv_off${end} kernel options (if any).${end}"
				[ -f $probe_open ]&& rm -f $probe_open
				sleep 2
				echo -e $"# ${v}Set back Configuration file to NVIDIA only.${end}"
				sed -Ei "s/^(open_drv)=.*$/\1=0/" $basic_conf
				sed -Ei "s/^(use_open)=.*$/\1=0/" $basic_conf
				sleep 2
				echo -e ""
				echo -e $"# ${v}Reboot for change to take effect.${end}"
				sleep 2
				echo -e $esc_message
				$x_sleep
			} & eval lpid=$! ; y_pulse; } | win_yad_progress
			warn_log_title=$"${j}${bf}Nvidia Driver refresh.${end}${end}"
			[ -e $systemd_dir/$(dm_serv).service ] && restart_dm_warn
		fi
	fi
}
blacklist_and_grub_set(){
	# Perform blacklist and grub config.
	local blacklist drm_fbdev drm_msg option_set opt_mod_list
	local fonts sub_fonts serie mod short option message
	eval timeout=$timeout

	## font display differently if install process in on.
	if [ $from_install = 1 ]; then
		fonts="${nf}${j}($n%)${end}${end}${ge}${sf}"
		sub_fonts="${ge}($n%)${sf}"
	else
		fonts="${ge}${nf}"
		sub_fonts="${ge}${sf}"
	fi
	blacklist='nouveau.modeset=0 rd.driver.blacklist=nouveau'
	test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='.* '
	## Older driver version wasn't supporting frame buffer distro splash screen, and need
	## drm_modset 0. NOTE : 440 serie is set as default, but the real serie where
	## this option is needed is not known > too old.
	[ $(chk_family) -le 440 ] && drm_modset=0
	[ $(chk_family) -lt 545 ] && drm_fbdev=''
	[ $(chk_family) -ge 545 ] && drm_fbdev=' nvidia-drm.fbdev=1' # || drm_fbdev=''
	## take care of modeset 1 for 515 serie too.
	if [ $opti_preset = 1 ]; then
		## optimus section.
		drm_modset=1; drm_msg='Optimus device'
		if [ "$old_drm_modset" != '' ]&&[ $drm_modset -ne $old_drm_modset ]; then
			sed -Ei "s/^(drm_modset)=.*$/\1=$drm_modset/" $basic_conf
		fi
	else
		drm_msg=$(chk_family)' serie'
	fi
	if [ $(grep -c "GRUB_CMD.*nouveau" $grub_def) -gt 0 ]; then
		if [ $(cat $grub_def| grep -E -c "^GRUB_CMD.*$blacklist nvidia-drm.modeset=$drm_modset$drm_fbdev $grub_orig.*$") -eq 0 ]; then
# 			if [ "$timeout" != '' ];then
			if [ $from_install = 0 ]; then
				echo $"# GRUB conf options update."; sleep 2
			else
				echo $"# ${fonts} * GRUB conf options update.${end}${end}"; sleep 2
			fi
			## then, replace default env grub with new vars and update grub.cfg.
			sed -Ei "s/^(GRUB_CMD.*)=\"(.*) ($grub_orig.*)\"$/\1=\"$blacklist nvidia-drm.modeset=$drm_modset$drm_fbdev \3\"/" $grub_def
			$d_grub-mkconfig -o $grub_cfg 2>&1 | \
			while read -r line; do
# 				if [ "$timeout" != '' ];then
				if [ $from_install = 0 ]; then
					echo "# * ${line}"
				else
					echo "# ${sub_fonts} * ${line}${end}${end}"; n=$((n+1)); echo $n
				fi
			done
		else
# 			if [ "$timeout" != '' ];then
			if [ $from_install = 0 ]; then
				echo $"# GRUB conf already set."; sleep 2
			else
				echo $"# ${fonts} * GRUB conf already set.${end}${end}"; sleep 2
			fi
		fi
	else
# 		if [ "$timeout" != '' ];then
		if [ $from_install = 0 ]; then
			echo $"# Create GRUB conf for nouveau driver blacklisting and other options."; sleep 2
		else
			echo $"# ${fonts} * Create GRUB conf for nouveau driver blacklisting and other options.${end}${end}"; sleep 2
		fi
		sed -En "s/^GRUB_CMD.*=\"(.*)\"$/grub_orig='\1'/p" $grub_def > $(user_CF_DIR)/grub-orig
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$blacklist nvidia-drm.modeset=$drm_modset$drm_fbdev \2\"/" $grub_def
		$d_grub-mkconfig -o $grub_cfg 2>&1 | \
		while read -r line; do
			if [ "$timeout" != '' ];then
				echo "# * ${line}"
			else
				echo "# ${sub_fonts} * ${line}${end}${end}"; n=$((n+1)); echo $n
			fi
		done
	fi
	## blacklist nouveau
	[ -e /etc/modprobe.d/blacklist-nouveau.conf ] || echo "blacklist nouveau" > /etc/modprobe.d/blacklist-nouveau.conf
	## modprobe options.
	## NOTE : Usualy nvidia driver prefer mod options config in grub,
	## modprobe conf are set, for some of them, for session and mods reload.
	opt_mod_list=(
		"535,nvidia_drm,drm,modeset=$drm_modset,nvidia-drm"
		"555,nvidia,gsp,NVreg_EnableGpuFirmware=$GSP_firm,GSP firmware"
		)
	for option_set in "${opt_mod_list[@]}"; do
		serie=$(cut -d',' -f1 <<< $option_set )
		mod=$(cut -d',' -f2 <<< $option_set )
		short=$(cut -d',' -f3 <<< $option_set )
		option=$(cut -d',' -f4 <<< $option_set )
		message=$(cut -d',' -f5 <<< $option_set )
		conf_file=/etc/modprobe.d/nvidia-${short}.conf
		if [ $(chk_family) -ge ${serie} ]; then
			grep "${option}" $conf_file &>/dev/null
			if [ $? -gt 0 ]; then
# 				if [ "$timeout" != '' ]; then
				if [ $from_install = 0 ]; then
					echo $"# Update modprobe ${message} option for ${drm_msg}."; sleep 2
				else
					echo $"# ${fonts} * Update modprobe ${message} option for ${drm_msg}.${end}${end}"; sleep 2
				fi
				echo "options ${mod} ${option}" > $conf_file
			else
# 				if [ "$timeout" != '' ]; then
				if [ $from_install = 0 ]; then
					echo $"# Modprobe ${drm_msg} ${message} option already set."; sleep 2
				else
					echo $"# ${fonts} * Modprobe ${drm_msg} ${message} option already set.${end}${end}"; sleep 2
				fi
			fi
		else
			## remove GSP or modset config in case of driver regression.
			grep "${option}" $conf_file &>/dev/null
			if [ $? -eq 0 ]; then
# 				if [ "$timeout" != '' ]; then
				if [ $from_install = 0 ]; then
					echo $"# Remove modprobe ${message} option for ${drm_msg}."; sleep 2
				else
					echo $"# ${fonts} * Remove modprobe ${message} option for ${drm_msg}.${end}${end}"; sleep 2
				fi
				rm -f $conf_file
			fi
		fi
	done
}
## OPTIMUS SETUP
# let xorg_conf configure the xorg config file, then ask for prime or optimus if detected.
# Then modify as appropiate.
prime_setup(){
	local xorg_version=$(cat /var/log/Xorg.0.log| sed -En "/Build ID:/{;s/^.*\ ([1\.]?[0-9]*[.].*)-.*$/\1/p}")
	local xorg_last=$(printf $xorg_version | grep -c 21)
	local xorg_cfg=/etc/X11/xorg.conf.nvidia
	local old_auto_set=$opti_auto_set old_preset=$opti_preset old_offload=$offload old_render=$render
	local render com xrandr_conf gdm_conf desktop_conf

	if [ $opti_auto_set = 1 ]; then
		[ $offload = 1 ] && render='PRIME'
	else
		prime_setup_window
	fi
	if [[ "$render" =~ "PRIME render offload"|"NONE" ]]; then
		## modify xorg conf. Disable dGPU
		## Screen 0 "intel" 0 0
		## Inactive	"nvidia"
		## Option	"AllowNVIDIAGPUScreens"
		## Option	"AllowPRIMEDisplayOffloadSink" "true"
		## __NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia "$@"
		## add specific sets for xrandr to avoid tearing
		## modesettings create tearing on iGPU sync. To prevent this it's needed to workaround:
		# $ xrandr --output <output> --set "PRIME Synchronization" 0 # disabling.
		# $ xrandr --output <output> --set "PRIME Synchronization" 1 # enabling.

		for e in ${dev_n[@]}; do
			[[ ${vnd_id[$e]} =~ "10de" ]] && com='#' || com=''
			sed -Ei "s/^[#]?(.*Screen ${e}.*$)/${com}\1/" $xorg_cfg
		done
		sed -Ei "s/^[#]?(.*Inactive.*$)/#\1/" $xorg_cfg
		if [[ "$render" =~ "NONE" ]]; then
			sed -Ei "s/^[#]?(.*Option.*\"AllowNVIDIAGPUScreens\".*$)/#\1/" $xorg_cfg
			sed -Ei "s/^[#]?(.*Option.*\"AllowPRIMEDisplayOffloadSink\".*$)/#\1/" $xorg_cfg
		else
			sed -Ei "s/^[#]?(.*Option.*\"AllowNVIDIAGPUScreens\".*$)/\1/" $xorg_cfg
			sed -Ei "s/^[#]?(.*Option.*\"AllowPRIMEDisplayOffloadSink\".*$)/\1/" $xorg_cfg
		fi
	else
		## modify xorg conf. Disable iGPU.
		## Screen 1 "nvidia" 0 0 ou Screen 0 "nvidia" 0 0
		## Inactive	"intel"
		for e in ${dev_n[@]}; do
			[[ ${vnd_id[$e]} =~ "10de" ]] && com='' || com='#'
			sed -Ei "s/^[#]?(.*Screen ${e}.*$)/${com}\1/" $xorg_cfg
# 			echo ">>>>>> device $com ${vnd_id[$e]}"
		done
		sed -Ei "s/^#(.*Inactive.*$)/\1/" $xorg_cfg
	fi
	if [ $(chk_family) -ge 435 ]; then
		## Prime version. REVERSE PRIME since 435 and above.
		## Offload and REVERSE PRIME version since 495 and above doesn't need known specific sets.
		xrandr_conf=$(
			cat <<-CONF
				xrandr --setprovideroutputdevice modesetting NVIDIA-G0
				xrandr --auto
			CONF
		)
		gdm_conf='xrandr --setprovideroutputsource modesetting NVIDIA-G0'
	elif [[ $(chk_family) -ge 390 && $(chk_family) -lt 435 ]]; then
		## PRIME vesion since 390 and above.
		xrandr_conf=$(
		cat <<-CONF
			xrandr --setprovideroutputdevice modesetting NVIDIA-0
			xrandr --auto
		CONF
		)
		gdm_conf='xrandr --setprovideroutputsource modesetting NVIDIA-0'
	fi
	## add Arch primus_run to /usr/local/bin.
	if [ ! -e /usr/local/bin/run_offload ]; then
	cat <<-BIN>/usr/local/bin/run_offload
		#!/bin/bash
		__NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia "$@"
	BIN
	fi
	## wroten sets to dm config.
	if [ "$(dm_serv)" == "lightdm" ]; then
		## make security backup if not exist.
		[ -s /etc/lightdm/lightdm.conf.bak ] || cp -f /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak
		## change Seat /etc/lightdm/lightdm.conf
		if [ "$render" = "NONE" ]; then
			[ -e /etc/lightdm/prime_ini ] && rm -f /etc/lightdm/prime_ini
			sed -Ei "s/^.*(type=.*)$/#\1/" /etc/lightdm/lightdm.conf
			sed -Ei "s/^.*(display-setup-script)=.*$/#\1=\/etc\/lightdm\/prime_ini/" /etc/lightdm/lightdm.conf
		else
			## add conf
			cat <<-INI >/etc/lightdm/prime_ini
				#! /bin/bash

				$xrandr_conf
			INI
			chmod 755 /etc/lightdm/prime_ini
			sed -Ei "s/^.*(type)=.*$/\1=local/" /etc/lightdm/lightdm.conf
			sed -Ei "s/^.*(display-setup-script)=.*$/\1=\/etc\/lightdm\/prime_ini/" /etc/lightdm/lightdm.conf
		fi
	elif [ "$(dm_serv)" == "sddm" ]; then
		## make security backup if not exist.
		[ -s /usr/share/sddm/scripts/Xsetup.bak ] || cp -f /usr/share/sddm/scripts/Xsetup /usr/share/sddm/scripts/Xsetup.bak
		## modify conf /usr/share/sddm/scripts/Xsetup
		if [ "$render" = "NONE" ]; then
			cp -f /usr/share/sddm/scripts/Xsetup.bak /usr/share/sddm/scripts/Xsetup
		else
			cat <<-INI >/usr/share/sddm/scripts/Xsetup
				#! /usr/bin/sh

				$xrandr_conf
			INI
			chmod 755 /usr/share/sddm/scripts/Xsetup
		fi
	elif [ "$(dm_serv)" == "gdm" ]; then
		# /usr/share/gdm/greeter/autostart/optimus.desktop
		# /etc/xdg/autostart/optimus.desktop
		desktop_conf=$(cat <<-CONF
			[Desktop Entry]
			Type=Application
			Name=Optimus
			Exec=sh -c "$gdm_conf; xrandr --auto"
			NoDisplay=true
			X-GNOME-Autostart-Phase=DisplayServer
		CONF
		)
		if [ "$render" = "NONE" ]; then
			[ -e /usr/share/gdm/greeter/autostart/optimus.desktop ] && rm -f /usr/share/gdm/greeter/autostart/optimus.desktop
			[ -e /etc/xdg/autostart/optimus.desktop ] && rm -f /etc/xdg/autostart/optimus.desktop
		else
			echo "$desktop_conf" > /usr/share/gdm/greeter/autostart/optimus.desktop
			echo "$desktop_conf" > /etc/xdg/autostart/optimus.desktop
		fi
	fi
	## write or update render, offload and opti_auto_set in user config file.
	[ $offload -ne $old_offload ] && sed -Ei "s/^(offload)=.*$/\1=$offload/" $basic_conf
	[ $opti_auto_set -ne $old_auto_set ] && sed -Ei "s/^(opti_auto_set)=.*$/\1=$opti_auto_set/" $basic_conf
	[ "$render" != "$old_render" ] && sed -Ei "s/^(render)=.*$/\1=\"$render\"/" $basic_conf
	## if program is not launch from install process, go back section menu or exit if task bar cmd.
	[ $from_install = 0 ] && { [ $task_opt = 1 ] && exit 0 || menu_modif ;}
}
prime_setup_window(){
	local applicable_list opti_set offload_set select_render_sets
	[ $(chk_family) -ge 390 ] && applicable_list+="PRIME!"
	[ $(chk_family) -ge 435 ] && applicable_list+="PRIME render offload!"
	[ $opti_preset = 0 ] && opti_set='FALSE' || opti_set='TRUE'
	[ $offload = 0 ] && offload_set='FALSE' || offload_set='TRUE'
	tip_1=$"$(
		cat <<-TIPS
			If set, GPU renderer choice will be set to PRIME by default
			You can changed this set in : > Configuration and Tools > Edit Zenvidia config.
		TIPS
	)"
	tip_2=$"$(
		cat <<-TIPS
			If set, this window wont be displayed at the next installation or update and recorded sets applicable.
			You can changed this set in : > Configuration and Tools > Edit Zenvidia config.
		TIPS
	)"
	w_text=$"$(
		cat <<-INFO
			${j}<b>PRIME Display GPU configuration</b>${end}
			${v}There a few usable method to use Nvidia GPU for applications or desktop.${end}
			${y}<u>PRIME</u>${end} : use NVIDIA dGPU as a primary renderer with iGPU off.
			${y}<u>PRIME render offload</u>${end} : use NVIDIA dGPU as renderer and iGPU as desktop default.
			${y}<u>NONE</u>${end} : use iGPU only, don't use NVIIDA dGPU (this cancel previous config too).
			${sf}
			${v}Notes${end} :
			<b>PRIME Render</b> is applicable for all version since 390 serie.
			<b>PRIME Render Offload</b> is applicable from 435 serie and X version 1.20.7

			<b>You're actually running the ${y}$xorg_version${end} Xorg version. ${j}Only applicables will be listed${end}</b>.

			${j}Notice${end} : <b>run_offload</b> script will be created during proces.
			It contains default ENV variables for <b>PRIME render offload</b>. This, is necessary to run any
			applications with dGPU render and need to be insert in desktop file or command line as below :
			> <b>[YOUR_ENV_VAR] run_offload [application]</b>

			<b>Full documentation can be found in</b> : > ${j}Help and Documentation${end} > ${j}Documentation Manual${end}
			 - Chapter 17. <i>Using the NVIDIA Driver with Optimus Laptops</i>
			 - Chapter 34. <i>Offloading Graphics Display with RandR 1.4</i>
			 - Chapter 35. <i>PRIME Render Offload</i>
			${end}
		INFO
	)"
	local select_render_sets
	select_render_sets=$($d_yad --width=400 --borders=15 --title="$WIN_TITLE" --window-icon="$img_zen_desktop" --wrap --center \
	--text="$w_text" --form --button=$"Abort"'!gtk-close:1' --button=$"Set"'!gtk-ok:0' --separator=';' \
	--field="":LBL '' \
	--field=$"Select the default NVIDIA dGPU behaviour"!$"Select in the list.":CB "${applicable_list[*]}NONE" \
	--field="":LBL '' \
	--field=$"Set Prime instead of Offload by default"!"$tip_1":CHK "$offload_set" \
	--field=$"Set Optimus Render config auto"!"$tip_2":CHK "$opti_auto_set" || \
	if [ $? = 252 ]; then echo 200; elif [ $? = 1 ]; then echo 100; else echo 0; fi )
	case $select_render_sets in
		100)	if [ $from_install = 1 ]; then
					render='NONE'; offload=0; opti_auto_set=0
				else
					[ $task_opt = 1 ] && exit 1 || menu_modif
				fi
			;;
		200)	[ $task_opt = 1 ] && exit 1 || base_menu ;;
		0|*) ## cut output to be sent to prime_setup here.
				render=$(echo $select_render_sets| cut -d';' -f2)
				offload=$([ "$(echo $select_render_sets| cut -d';' -f4)" = "TRUE" ] && echo 1 || echo 0 ;)
				opti_auto_set=$([ "$(echo $select_render_sets| cut -d';' -f5)" = "TRUE" ] && echo 1 || echo 0 ;)
			;;
	esac
}
xorg_conf(){
## prime setup start here.
# Is opti_preset set ?
# If opti_preset is set, ask if user wants to config prime and warn about modesetting TearFree option is not available
# until version 21.2 of Xorg. 20.14 here.
	local conf_date w_pix h_pix w_mil h_mil dpi_v dpi_h x_dpi x_plore def freq freq_prim freq_scnd dec freq

# 	[ -f $x_tmp ] || { x_tmp=$(mktemp $zen_tmp_dir/zn_xorg.XXXX);} #rem_tmp+=("rm -f $x_tmp") ;}
#  	local x_conf_dir=/etc/X11 # UNUSED ?
	x_tmp=$(mktemp $zen_tmp_dir/zn_xorg.XXXX) # global var, not local
## creation order :
## 	sec_files		x 1
## 	sec_layout		x X
## 	sec_device		x X
## 	sec_option_df	x X/1
## 	sec_screen		x X/1
	sec_files(){
		if [ $ELF_TYPE -eq 64 ]; then
			ELF=$ELF_64
		else
			ELF=''
		fi
		conf_date=$(date +%D-%T)
		cat <<-XF > $x_tmp
			## xorg conf originaly created by $(new_version) nvidia installer.
			## Edited automaticaly by Zenvidia > $conf_date

		XF
		if [ $(chk_family) -lt 430 ]; then
			cat <<-XF >> $x_tmp
			Section "Files"
			   ModulePath "$nv_root/nvidia/xorg/modules"
			   ModulePath "/usr/$master$ELF/xorg/modules"
			EndSection

			XF
		fi
	}
	sec_layout(){
		layout_screen(){
			for e in ${dev_n[@]}; do
				if [ $opti_preset = 0 ]; then
					cat <<-XF
						   Screen ${dev_n[$e]}	"Screen${dev_n[$e]}" 0 0
					XF
				else
					if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
						cat <<-XF
						#   Screen ${dev_n[$e]}	"Screen${dev_n[$e]}" 0 0
						XF
					else
						cat <<-XF
						   Screen ${dev_n[$e]}	"Screen${dev_n[$e]}" 0 0
						#   Inactive	"Device${dev_n[$e]}"
						XF
					fi
				fi
			done
		}
		## layout section may differ with second card (optimus).
		## main screen become nvidia's.
		if [ $opti_preset = 0 ]; then
			cat <<-XF >> $x_tmp
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"Xinerama" "0"
				#   InputDevice	"Mouse0" "CorePointer"
				EndSection

			XF
		else
			cat <<-XF >> $x_tmp
				Section "ServerLayout"
				   Identifier	"Layout0"
				$(layout_screen)
				#   Option	"AutoAddDevices" "false"
				#   Option	"AutoAddGPU" "false"
				   Option	"AllowNVIDIAGPUScreens"
				## AllowPRIMEDisplayOffloadSink is needed by Xorg 1.20.6 (435 serie)
				#   Option	"AllowPRIMEDisplayOffloadSink" "false"
				   Option	"Xinerama" "0"
				#   InputDevice	"Mouse0" "CorePointer"
				EndSection

			XF
		fi
		cat <<-XF >> $x_tmp
			Section "ServerFlags"
				# allows the server to start up even if the mouse does not work
			   AllowMouseOpenFail
			EndSection

		XF
	}
	## optional. Input Device section. Undocumented.
	sec_input(){
		cat <<-XF >> $x_tmp
			Section "InputDevice"
			## generated from default
			   Identifier	"Mouse0"
			   Driver	"mouse"
			   Option	"Protocol" "auto"
			   Option	"Device" "/dev/input/mice"
			   Option	"Emulate3Buttons" "no"
			   Option	"ZAxisMapping" "4 5"
			EndSection
		XF
	}
	## optional. optimus primay gpu set.
	sec_output(){
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			cat <<-XF >> $x_tmp
				Section "OutputClass"
					Identifier	"Screen${dev_n[$e]}"
					Device	"Device${dev_n[$e]}"
					Driver	"nvidia"
					MatchDriver	"nvidia"
				EndSection
			XF
		fi
	}
	sec_device(){
			pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			cat <<-XF >> $x_tmp
				Section "Device"
				   Identifier	"Device${dev_n[$e]}"
				   Driver	"nvidia"
				   VendorName	"${vnd[$e]}"
				   BusID	"PCI:$pci_slot"
			XF
			else
				if [ $opti_preset = 1 ]; then
					pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
					cat <<-XF >> $x_tmp
						Section "Device"
						   Identifier	"Device${dev_n[$e]}"
						   Driver	"modesetting"
						   VendorName	"${vnd[$e]}"
						   BusID	"PCI:$pci_slot"
						## modesetting Tear Free is available starting xorg version 21.2.
						#   Option	"TearFree" "true"
						   Option	"SWcursor" "false"
						#   Option	"kmsdev" "/dev/dri/card0"
							Option	"ShadowFB" "true"
							Option	"DoubleShadow" "false"
						   Option	"AccelMethod" "glamor"
							Option	"PageFlip" "false"
						#   Option	"ZaphodHeads" "LVDS,VGA-0"
					XF
				fi
			fi
	}

	sec_option_df(){
	## compute X screen DPI ex : (1080x25.4)/286. From Nvidia Doc formula.
		if [ $d_xdpy ]; then
			w_pix=$(printf "$x_pixel"| cut -d';' -f1)
			h_pix=$(printf "$x_pixel"| cut -d';' -f2)
			w_mil=$(printf "$x_milli"| cut -d';' -f1)
			h_mil=$(printf "$x_milli"| cut -d';' -f2)
			## formule
			dpi_w=$(echo "($w_pix*25.4+$w_mil-1)/$w_mil"| bc -l| sed -n "s/\..*$//p")
			dpi_h=$(echo "($h_pix*25.4+$h_mil-1)/$h_mil"| bc -l| sed -n "s/\..*$//p")
			## inclusion
			x_dpi=$dpi_w" x "$dpi_h
		else
			## fallback value.
			x_dpi="96 x 96"
		fi
		## get display current def and freq
		x_plore=$(xrandr --current | grep -m1 "*")
		def=$(printf "$x_plore"| awk '{print $1}')
		freq=$(printf "$x_plore"| sed -En "s/.* ([0-9]{2,3}\.[0-9]{2})\*.*$/\1/g;p")
		eval freq_prim=$(printf "$freq"| cut -d. -f1)
		eval freq_scnd=$(printf "$freq"| cut -d. -f2)
		if [ $freq_scnd ]; then
			if [ $freq_scnd -gt 10 ]; then dec=50; else dec=5; fi
			if [ $freq_scnd -gt $dec ]; then freq=$(($freq_prim+1)); else freq=$freq_prim; fi
		fi
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			if [ $opti_preset = 1 ]; then
				cat <<-XF >> $x_tmp
					   Option	"AllowEmptyInitialConfiguration"
				XF
			fi
			cat <<-XF >> $x_tmp
				#   Option	"NoLogo" "true"
				#   Option	"DPMS" "true"
				#   Option	"HardDPMS" "true"
				   Option	"UseEDID" "true"
				#   Option	"CustomEDID" "DFP-0:/tmp/edid[x].bin"
				   Option	"ProbeAllGpus" "false"
				#   Option	 "AllowExternalGpus" "true"
				#   Option	"UseDisplayDevice" "none"
				#   Option	"ConnectedMonitor" "DFP"
				#   Option	"DynamicTwinView" "false"
				#   Option	"AddARGBGLXVisuals"
				   Option	"SLI" "off"
				#   Option	"MultiGPU" "off"
				   Option	"BaseMosaic" "off"
				#   Option	"UseEdidDpi" "false"
				#   Option	"ColorSpace" "YCbCr444"
				#   Option	"ColorRange" "limited"
				   Option	"Stereo" "0"
				#   Option	"ForceStereoFlipping" "0"
				   Option	"RenderAccel" "true"
				   Option	"NoRenderExtension" "false"
				   Option	"AllowIndirectGLXProtocol" "true"
				#   Option	"AllowGLXWithComposite" "true"
				#   Option	"TripleBuffer" "true"
				   Option	"Coolbits" "8"
				#   Option	"UBB" "true"
				#   Option	"Overlay" "false"
				#   Option	"CIOverlay" "false"
				#   Option	"NoFlip" "true"
				#   Option	"GLShaderDiskCache" "false"
				#   Option	"SWCursor" "false"
				#   Option	"HWCursor" "false"
				#   Option	"ConnectToAcpid" "true"
				#   Option	"EnableACPIBrightnessHotkeys" "true"
				   Option	"DPI" "$x_dpi"
				   Option	"ConstantDPI" "true"
				   Option	"nvidiaXineramaInfoOrder" "DFP-0"
				   Option	"MetaModes" "${def}_${freq} +0+0"
				EndSection

			XF
		else
		## here second card option merge to Device section.
			cat <<-XF >> $x_tmp
				EndSection

			XF
		fi
	}
	sec_screen(){
		cat <<-XF >> $x_tmp
			Section "Screen"
				Identifier	"Screen${dev_n[$e]}"
				Device	"Device${dev_n[$e]}"
				Monitor	"Monitor${dev_n[$e]}"
				DefaultDepth	24
			EndSection

		XF
	}
	sec_files
	sec_layout
	for e in ${dev_n[@]}; do
		#sec_output
		sec_device
		sec_option_df
		sec_screen
	done
}
fix_profiles_rc(){
	## If nvidia profile doesn't exist in user nv dir, create.
	## Then, create an empty user profile alongside the nvidia copy
	## in nvidia-application-profiles-rc.d/user-application-profiles-rc
	## If profile exist, convert to fixed in user nv dir
	## NOTE : some lines can't be convert because they are not formated like others and have to be manualy add in user-rc,
	## WARNING : some are really faulty, don't add them.
	create_rules(){
		echo -e "$headers" > $fixed_rc
		echo -e "  \"rules\": [" >> $fixed_rc
		## extract rules patterns "pattern" "profile"
		cat $version_rc | sed -n "/^.*\"rules\" : \[.*$/,/^    \].*$/p"| \
		sed -En "s/.*(\{) (\"pattern\"[ ]?: \".*\",).*(\"profile.*\") (\},).*/${tab}  \1\n${tab}   \2\n${tab}   \3\n${tab}  \4/p" >> $fixed_rc
		## extract rules patterns "pattern" "feature" "matches" "profile"
		cat $version_rc | sed -n "/^.*\"rules\" : \[.*$/,/^    \].*$/p"| \
		sed -En "s/.*(\{) (\"pattern\"[ ]?: \{) (\"feature.*\",).*(\"matches.*\") (\},).*(\"profile.*\") (\}[,]?).*/\
${tab}  \1\n${tab}   \2\n${tab}    \3\n${tab}    \4\n${tab}   \5\n${tab}   \6\n${tab}  \7/p" >> $fixed_rc
		echo -e "  ]," >> $fixed_rc
	}
	create_profiles(){
		## extract profiles patterns and add "key" "value" to each xml sections.
		cat $version_rc | sed -n "/^.*\"profiles\" : \[.*$/,/^.*\],.*$/{;s/    /  /g;p}"| \
		sed -En "s/.*(\"settings\"[ ]?: \[) (\".*\",) (.*) \].*/\
${tab}  \1\n${tab}${tab}\{\n${tab}${tab} \"key\": \2\n${tab}${tab} \"value\": \3\n${tab}${tab}\}\n${tab}  \]/i;s/\],/\]/g;p" >> $fixed_rc
		echo -e "}" >> $fixed_rc
	}
	local nv_user_dir=/home/$(def_user)/.nv
	local version_rc=$install_dir/share/nvidia/nvidia-application-profiles-$(new_version)-rc
	local fixed_rc=$nv_user_dir/nvidia-application-profiles-rc
	local headers tab
	[ -d $nv_user_dir/nvidia-application-profiles-rc.d ] || {
		mkdir -p $nv_user_dir/nvidia-application-profiles-rc.d
		touch $nv_user_dir/nvidia-application-profiles-rc.d/user-application-profiles-rc
	}
	headers=$( cat <<-HEAD
		# Application profiles originaly created by Zenvidia from
		# Nvidia profiles rc version $(new_version) - $(date)
		# Be aware that some rules are not filtered because their formats differ from default.
		{
	HEAD
	)
	local tab='    '
	create_rules || die 1 "${LINENO}" "Nvidia profiles rc rebuild tool failed to rebuild rules" ""
	create_profiles || die 1 "${LINENO}" "Nvidia profiles rc rebuild tool failed to rebuild profiles" ""
}
make_tip_docs(){ # WATCH
	local x_tip_tmp=$(mktemp $zen_tmp_dir/tip_xorg.XXXX)
	local src_doc=$nvi_docs/html/xconfigoptions.html
	local x_doc=$zen_tmp_dir/x-tips
	local nv_doc=$zen_tmp_dir/nv-tips

	## first clean all lists.
	## take to set xtip and docs vars local.
	local index regex section_key_kist manpage section_key section_line key line base_query list_opts
	local index_list=$(sed -n "/<a name=\".*\".*$/{;s/.*name=\"\([A-Z]\w*\)\" .*$/\1/p}" $src_doc)

	## start nvidia X doc reformatting
	for index in ${index_list[@]}; do
		echo -e "<$index>" >> $x_tip_tmp
		## IncludeImplicitMetaModes need one more substitution.
		if [ "$index" = "IncludeImplicitMetaModes" ]; then
			regex="s/ Option/\n Option/g;"
		else
			regex=''
		fi
		sed -n "/\"$index\"/,/<\/dd>/{;/^<dd>/,/^<\/dd>/{;/<p>/,/<\/p>/{;s/&.*\;/ /g;p}}}" $src_doc | \
		tr "\n" " " | \
		sed -En "s/(<a href=.*title=( )?\".*\">)//g;s/<[^>]*>//g;s/\. /.\n/g; \
		s/: {6}/:\n  /g;s/ {5}/ /g;s/ {3}/ /g;${regex}p" >> $x_tip_tmp || die 1 ${LINENO} "Tips extraction regex failed" ""
		echo -e "\n</$index>" >> $x_tip_tmp
	done
	sed -n "/^[[:blank:]]*$/d;s/^\ //i;p" $x_tip_tmp > $nv_doc
	## start xorg and devices man reformatting
# 	unset section_key_kist
	IFS=$(echo -en "\n\b")
	section_key_kist=(
		"xorg.conf|SERVERFLAGS SECTION,section are:|132,122" #160,150
		"xorg.conf|INPUTDEVICE SECTION,for a description of the device-specific options.|121,86" #140,105
		"xorg.conf|FILES SECTION,The entries that can appear in this section are:|69,64" #80,75
		"xorg.conf|SCREEN SECTION,The Identifier entry is mandatory. All others are optional|88,70" #105,87
		"modesetting|The following driver Options are supported|30" #?
		"intel|The following driver Options are supported|215" # 230
		"amdgpu|The following driver Options are supported:|61" #80
	)

	local manual
	for manual in ${section_key_kist[*]}; do
		local list_opts key line
		manpage=$(printf "$manual"| cut -d"|" -f1)
		section_key=$(printf "$manual"| cut -d"|" -f2)
		section_line=$(printf "$manual"| cut -d"|" -f3)
		## make difference between man exploration with 2 section lines and only 1.
		if [[ "$section_key" =~ , ]]; then
			key+=( "$(cut -d, -f1 <<< $section_key)" )
			key+=( "$(cut -d, -f2 <<< $section_key)" )
			line+=( "$(cut -d, -f1 <<< $section_line)" )
			line+=( "$(cut -d, -f2 <<< $section_line)" )
			base_query=$(man --nh --nj -P cat $manpage | col -b | sed -En "s/(\t)/ /g;s/([\ ]{2,10})/ /g;p"| \
			grep -A${line[0]} "${key[0]}"|grep -A${line[1]} "${key[1]}")"\n" || die 1 ${LINENO} "Couldn't get first xorg tip pattern." ""
		else
			base_query=$(man --nh --nj -P cat $manpage | col -b | sed -En "s/(\t)/ /g;s/([\ ]{2,10})/ /g;p"| \
			grep -A${section_line} "${section_key}") || die 1 ${LINENO} "Couldn't get second xorg tip patterns." ""
		fi
		## make option's name list.
		## Files section a different query for list and eextraction.
		if [[ "${key[0]}" =~ "FILES SECTION" ]]; then
			list_opts+=( $(echo -e "$base_query" | \
			sed -En "s/^ ([A-Z]\w*) (\")?(\w*)(\")$/\1/p") )
		else
			list_opts+=( $(echo -e "$base_query" |  grep "^ Option " | \
			sed -En "s/^ ([A-Z]\w*) (\")?(\w*)(\")?( \"\w*\")?$/\3/p") )
			list_opts+=( $(echo -e "$base_query" |  grep -v "^ Option " | \
			sed -En "s/^ ([A-Z]\w*) (\w*)?$/\1/p") )
		fi
		## make man page extraction.
		if [[ "${key[0]}" =~ "FILES SECTION" ]]; then
			echo -e "$base_query" | sed -En "/^ ([A-Z]\w*) \"(\w*)\"$/,/^$/p" | \
			sed -En "s/^ ([A-Z]\w*) \"(\w*)\"$/<\1>/i;p" > $x_tip_tmp
		else
			echo -e "$base_query" | sed -En "/^ ([A-Z]\w*) \"(\w*)\"( \"\w*\")?$/,/^$/p" | \
			sed -En "s/^ ([A-Z]\w*) (\")?(\w*)(\")?( \"\w*\")?$/<\3>/i;p" > $x_tip_tmp
			echo -e "$base_query" | sed -En "/^ ([A-Z]\w*) (\w*)$/,/^$/p" | \
			sed -En "s/^ ([A-Z]\w*) (\w*)$/<\1>/i;p" >> $x_tip_tmp
		fi
		## now, create final tip.
		echo -e "<DEV:$manpage>" >> $x_doc
		for index in ${list_opts[@]}; do
			cat <<-PARA >> $x_doc
				<$index>
				$(sed -n "/<$index>/,/^$/p" $x_tip_tmp | grep -v "<$index>" | tr -d "\n" | sed -n "s/\. /.\n/g;s/^ //g;p")
				</$index>
			PARA
		done
		echo -e "</DEV:$manpage>" >> $x_doc

	done
	cp -f $x_doc $zen_docs/
	cp -f $nv_doc $zen_docs/
	IFS=$ifs
}
## AFTER INSTALL
clean_old_version(){ # post install part.
	local drv_src=() rep_clean
	y_text=$"Cleaning old ${j}$(old_version)${end} source and DKMS tree"
	local pulse=1 log=0 hold=0 hide_txt=0
	win_log_options
	{	timeout=30
	{	if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
		fi
		for rep_clean in ${drv_src[*]}; do
			## clean dkms tree
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
				echo $"# Cleaning $rep_clean $(old_version) DKMS tree"; sleep 2
# 				dkms_clean
				$p_dkms remove -m nvidia/$(old_version) --all
				if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
					rm -rf /var/lib/dkms/$rep_clean/$(old_version)
				fi
			fi
			## clean source tree
			if [ -d /usr/src/$rep_clean-$(old_version) ]; then
				echo $"# Cleaning $rep_clean $(old_version) source tree"; sleep 2
				rm -rf /usr/src/$rep_clean-$(old_version)
			fi
		done
		}& eval lpid=$! ; y_pulse ;} | win_yad_progress
}
POST_INSTALL(){
	echo "# "
	echo $"# ${v}${j}($n%)${end} - <u>Post install routines</u>${end}"; sleep 2
	echo $"# ${v}${j}($n%)${end} - Create XORG config file for Nvidia device${end}"; sleep 2
	xorg_conf || die 1 "${LINENO}" "Xorg auto config failed" ""# 8
	n=$[ $n+2 ]; echo "$n" # 8
	echo $"# ${v}${j}($n%)${end} - libraries sub routines${end}"; sleep 2
	echo $"# ${j}${nf}($n%)${end}${end}${ge}${sf} * Linking $nv_root libs to system${end}${end}"; sleep 2
	n=$[ $n+2 ]; echo "$n" # 9
	## set old_version and new_version function in the first place for loop,
	## the modinfo calculation slow down the process to much.
	local old_lib_version=$(old_version)
	local new_lib_version=$(new_version)
	local allocator pkcs11 openssl wayland='' vulkanprod='' gpucomp=''
	local link_list=() rm_lib lib_x fixed_lib=() fixed_lib_log=() UDEV_RULES
	local lib_X old_lib line lib_V r_dir elf_x link_v

	## validate newly installed nvidia bins
	eval d_nv_installer=${install_dir}/bin/nvidia-installer
	eval d_nv_settings=${install_dir}/bin/nvidia-settings
	eval d_nv_probe=${install_dir}/bin/nvidia-modprobe
	[ $(chk_family) -ge 535 ] && eval d_nv_persistenced=${install_dir}/bin/nvidia-persistenced

	# libnvidia-wfb.so is broken with old version, need to be replace with xorg server libwfb.so. If exist in nvidia's dirs.
	if [ $(chk_family) -lt 418 ]; then
		## 418 and above don't need nvidia libwfb.so to be replace anymore
		if [ -e $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so ]; then
			mv -f $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so.orig
			ln -sf /usr/$master$ELF_64/xorg/modules/libwfb.so $nv_root/nvidia.${new_lib_version}/xorg/modules/libwfb.so
			report_log+=($"\t\t\t\t${gB} libwfb\t${end}> ${y}link to system${end}.\n")
		fi
	fi
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/install-$new_version.log; fi
	echo $"# ${j}${nf}($n%)${end}${end}${ge}${sf} * Fixing broken libs and links if needed${end}${end}"; sleep 2

	### WARNING WARNING SCRIPT DOESN'T SUPPORT WAYLAND, NEED TO KNOW HOW TO DO THIS !
	## wayland-client and vulkan-producer are dedicate to wayland.
	## NOTE need to understand how wayland is detected.
	[ $wayland_link = 1 ] && wayland="wayland-client"
	## 545 serie updates.
	[ $(chk_family) -gt 396 ] && { allocator="allocator"; pkcs11="pkcs11"; openssl="pkcs11-openssl3" ;}
	[ $(chk_family) -lt 545 ] && vulkanprod="vulkan-producer"
	[ $(chk_family) -ge 545 ] && gpucomp="gpucomp"
	[ $(chk_family) -ge 580 ] && vksc="vksc-core"
	link_list=( "fbc" "cfg" "gtk2" "gtk3" ${pkcs11} ${openssl} ${allocator} ${vulkanprod} ${gpucomp} ${wayland} ${vksc} )
	## Remove previous version libs if needed.
	for lib_X in "${ELF_LIB_LIST[@]}"; do
		for old_lib in ${link_list[@]}; do
			if [ -s $install_dir/$lib_X/libnvidia-$old_lib.so.${old_lib_version} ]; then
				rm_lib=libnvidia-$old_lib.so.${old_lib_version}
				rm -f $install_dir/$lib_X/$rm_lib
				if [ -h $install_dir/$lib_X/libnvidia-$old_lib.so ]||\
				[ -h $install_dir/$lib_X/libnvidia-$old_lib.so.1 ]; then
					rm -f $install_dir/$lib_X/libnvidia-$old_lib.so*
				fi
				fixed_lib+=("$old_lib")
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ "$lib_X" =~ "64" ]]; then lib_x="x86_64"; else lib_x="i386"; fi
			fixed_lib_log+=($" cleaned ($lib_x)\n")
		fi
	done
	## send report from previous list before.
	if [ ${#fixed_lib_log[*]} -gt 0 ]; then
		for line in ${fixed_lib_log[*]}; do
			report_log+=($"\t\t\t\t${gB} lib fix\t${end}> ${y}${fixed_lib_log[@]}${end}.\n")
		done
	fi
	## fix lib64 prefix libs links if needed
	r_dir=$install_dir/$master$ELF_64
	for links in ${link_list[@]}; do
		if [ ! -e $r_dir/libnvidia-$links.so.${new_lib_version} ]; then
			cp -f $nvtmp/$extracted_release/libnvidia-$links.so.${new_lib_version} $r_dir/
		fi
		if [ ! -h $r_dir/libnvidia-$links.so.1 ]; then
			if [ -f $r_dir/libnvidia-$links.so.${new_lib_version} ]; then
				ln -sfr $r_dir/libnvidia-$links.so.1 $r_dir/libnvidia-$links.so
				ln -sfr $r_dir/libnvidia-$links.so.${new_lib_version} $r_dir/libnvidia-$links.so.1
				fixed_lib_log+=("$links,")
			fi
		fi
	done
	if [ ${#fixed_lib_log[*]} -gt 0 ]; then
		if [[ $ELF_64 =~ "64" ]]; then elf_x='(x86_64)'; else elf_x='(i386)'; fi
		fixed_lib_log+=($" links updated $elf_x")
		report_log+=($"\t\t\t\t${gB} link fix\t${end}> ${y}${fixed_lib_log[@]}${end}.\n")
	fi
	## symlink libvdpau_nvidia to system
	for lib_V in "${ELF_LIB_LIST[@]}"; do
		eval link_v=$(file -p /usr/$lib_V/vdpau/libvdpau_nvidia.so.1| grep -c "nvidia.${new_lib_version}")
		if [ $(chk_family) -lt 430 ]; then
			if [ $link_v -eq 0 ]; then
				[ -d /usr/$lib_V/vdpau ]|| mkdir -p /usr/$lib_V/vdpau
				ln -sfr /usr/$lib_V/vdpau/libvdpau_nvidia.so /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
				ln -sf $nv_root/nvidia.${new_lib_version}/$lib_V/vdpau/libvdpau_nvidia.so.${new_lib_version} \
				/usr/$lib_V/vdpau/libvdpau_nvidia.so.1
			fi
		else
			[ -h /usr/$lib_V/vdpau/libvdpau_nvidia.so.1 ]&& rm -f /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
		fi
	done
	n=$[ $n+2 ]; echo "$n" # 10
	## link now all new libraries and nvidia-application-profiles-key-documentation to system.
	if [ -d /usr/share/nvidia ]; then
		## ALERT Clean old profile version if exist before new one (done by last 535 serie version).
		test -f $install_dir/share/nvidia/nvidia-application-profiles-${old_lib_version}-rc && {
			if [ $(nv_new) -ne $(nv_old) ]; then
				rm -f $install_dir/share/nvidia/nvidia-application-profiles-${old_lib_version}-*
			fi
		}
		cp -rn /usr/share/nvidia $install_dir/share/
		rm -rf /usr/share/nvidia
		ln -sf -T $install_dir/share/nvidia /usr/share/nvidia
		## link new profile to sys. "$install_dir/share/nvidia"
		ln -sfr $install_dir/share/nvidia/nvidia-application-profiles-${new_lib_version}-key-documentation \
		$install_dir/share/nvidia/nvidia-application-profiles-key-documentation
		ln -sfr $install_dir/share/nvidia/nvidia-application-profiles-${new_lib_version}-rc \
		$install_dir/share/nvidia/nvidia-application-profiles-rc
		## copy doc to user $HOME/.nv
		cp -f $install_dir/share/nvidia/nvidia-application-profiles-${new_lib_version}-key-documentation \
		/home/$(def_user)/.nv/nvidia-application-profiles-key-documentation
		## if fix_profiles is set to 1, convert.
		if [ $fix_profiles = 1 ]; then
			echo $"# ${nf}${j}($n%)${end}${end}${ge}${sf} * Fixing user's nvidia profiles rc file${end}${end}"; sleep 2
			n=$[ $n+2 ]; echo "$n"
			fix_profiles_rc
		fi

		## create new x-docs and nv-docs for xorg configuration GUI tips. TASK
		echo $"# ${nf}${j}($n%)${end}${end}${ge}${sf} * Create Nvidia and Xorg helper tips for Xorg GUI${end}${end}"; sleep 2
		n=$[ $n+2 ]; echo "$n"
		make_tip_docs
	fi
	## NVIDIA_GLX-1.0 changelog file is replace even if the file is older than the installed one.
	## To prevent overwwrite in case of downgrade, file copied in zenvidia doc dir, then update
	## if driver version is newer than the previous.
	if [ ! -e $zen_docs/NVIDIA_Changelog ]||[ $(nv_new) -gt $(nv_old) ]; then
		cp -f $nvi_docs/NVIDIA_Changelog $zen_docs/
	fi
	if [ $(ls -1 /etc/ld.so.conf.d/ | grep -c "nvidia-") -eq 0 ]; then
		for lib in "${ELF_LIB_LIST[@]}"; do
			echo "/opt/nvidia/$lib" > /etc/ld.so.conf.d/nvidia-$lib.conf
		done
	fi
	echo $"# ${nf}${j}($n%)${end}${end}${ge}${sf} * Validating new libraries (ldconfig)${end}${end}"; sleep 2
	ldconfig
	## old driver version (here optimus laptop case) doesn't create nvidia devs. ATTENTION EXPERIMENTAL
	UDEV_RULES='/etc/udev/rules.d/01-nvidia-driver.rules'
	if [ $(chk_family) -le 430 ]; then
		## partly inspired by Alexandre Freire dos Santos work in Batocera.PLUS
		## https://github.com/AlexxandreFS/Batocera.PLUS/blob/master/script/nvidia-driver-udev-rules.sh
		## thanks to him.
		echo $"# ${nf}${j}($n%)${end}${end}${ge}${sf} * Creating udev rules for $(chk_family) serie${end}${end}"; sleep 2
		for dev in ${dev_id[@]}; do
			#SUPPORTED_GPUS_JSON=$nvi_docs'/supported-gpus/supported-gpus.json'
			#UDEV_RULES='/etc/udev/rules.d/01-nvidia-driver.rules'
			# OLD line : ACTION=="add", DEVPATH=="/bus/pci/drivers/nvidia", RUN+="$d_nv_probe -c 0 ${nv_mod_opts[*]}"
			test -f ${UDEV_RULES} || touch ${UDEV_RULES}
			cat <<-UDEV > ${UDEV_RULES}
			ACTION=="add", DEVPATH=="/bus/pci/drivers/nvidia", RUN+="$d_nv_probe -c 0 -m -u"
			UDEV
		done
		n=$[ $n+2 ]; echo "$n"
	else
		test -f ${UDEV_RULES} && rm -f $UDEV_RULES
	fi
	if [ $opti_preset = 1 ]; then
		prime_setup
		## here systemctl power management.
		if [ $opti_preset = 1 ]&&[ $enable_powerd = 1 ]; then
			if [ -f $install_dir/share/doc/NVIDIA_GLX-1.0/nvidia-dbus.conf ]; then
				cp -f $install_dir/share/doc/NVIDIA_GLX-1.0/nvidia-dbus.conf /etc/dbus-1/system.d
				ln -sf $install_dir/bin/nvidia-powerd /usr/bin/nvidia-powerd
				$d_sys enable nvidia-powerd.service
			fi
		fi
	fi
	## if driver version greater than 430.xx, backup xorg modules content to default libs dirs. Just in case.
	if [ $(chk_family) -ge 430 ]; then
		if [ -s $xorg_default/modules/extensions/libglxserver_nvidia.so ]; then
			mkdir -p $nv_root/nvidia.${new_lib_version}/xorg/modules/{extensions,drivers}
			cp -rf $xorg_default/modules/extensions/libglxserver_* $nv_root/nvidia.${new_lib_version}/xorg/modules/extensions/
			cp -f $xorg_default/modules/drivers/nvidia_drv.so $nv_root/nvidia.${new_lib_version}/xorg/modules/drivers/
		fi
	fi
	## nvidia services are per defaut set to 444 (O_o), setting them to 644 like all service files.
	chmod 644 /usr/lib/systemd/system/nvidia-*

	## To perform when all install operation (true or passed like in libs reinsttall mode)
	## are done successfully.
	if [[ $pass != '' ]]&&[[ $pass = 0 || $pass = 2 ]]; then
		## enable nvidia-persistenced if needed.
		[ $(chk_family) -ge 545 ] && nv_persistenced
		n=$[ $n+2 ]; echo "$n" # 11
		echo $"# ${v}${j}($n%)${end} - Blacklisting and other routines${end}"; sleep 1
		echo $"# ${v}${j}($n%)${end}${ge}${sf} * Blacklist and GRUB conf update if needed${end}${end}${end}"; sleep 2
		blacklist_and_grub_set
		n=$[ $n+2 ]; echo "$n" # 12
		## clean old install dir
		if [ $(nv_new) -ne $(nv_old) ]; then
			if [ -d $nv_root/nvidia.${new_lib_version} ]; then
				if [ -d $nv_root/nvidia.${old_lib_version} ]; then
					echo $"# ${v}${j}($n%)${end} - Cleaning old ${old_lib_version} source and DKMS tree if needed.${end}"; sleep 2
					rm -rf $nv_root/nvidia.${old_lib_version}
					report_log+=($"\t\t\t\t${gB} old version\t${end}> ${y}${old_lib_version} directory cleaned${end}.\n")
					clean_old_version
					report_log+=($"\t\t\t\t${gB} old source\t${end}> ${y}All ${old_lib_version} version cleaned${end}.\n")
					n=$[ $n+2 ]; echo "$n" # 14
				fi
			fi
		fi
	fi
}

### COMPIL & COMPIL CONF TOOLS ###
## check for patch in new version.
nv_build_options(){
	## nvidia build evolve in time, there need to set different options along side versions.
	## below vars have to be declare as globalthen reset at first.
	force_glvnd='' add_glvnd='' wine_special='' ask_open_build='' extract_open=0 extract_build=0 allow_install=''

	## in some case distro update deliver broken kernel, uncompatible var
	## is here to prevent compilation attempt and broke driver behaviour
	## check and/or create issue kernel list
	[ -f $(user_CF_DIR)/compilation-issue-list.log ] || > $(user_CF_DIR)/compilation-issue-list.log && issue_log=$(user_CF_DIR)/compilation-issue-list.log
	uncompatible_kernel=${uncompatible_kernel:-0}
	compatible_kernel=${compatible_kernel:-0}


	## list has to be set to 4 digit with inserted 0 if needed.
	# format 'xxxx|xxxx|xxxx' etc
	# 	uncompatible_list='061805'
	# 	uncompatible_list='618'
	# define driver file locations
	nv_xorg_dir=$nv_root/nvidia.$(new_version)/xorg
	xorg_default=/usr/$master$ELF_64/xorg
	no_check='--no-check-for-alternate-installs'
	no_net='-N'
	[ $use_indirect = 0 ]|| force_glvnd='--force-libglx-indirect'
	[ $use_glvnd = 0 ]|| add_glvnd='--install-libglvnd'
	## since 515 series, open drivers are available. Default is none.
	[ $(chk_family) -ge 260 ] && {
		compat32='--compat32-libdir='$master$ELF_32
		compat64='--opengl-libdir='$master$ELF_64
		gl_headers='c' ;}
	[ $(chk_family) -ge 390 ] && no_net=''
	[ $(chk_family) -ge 410 ] && gl_headers=''
	[ $(chk_family) -ge 430 ] && nv_xorg_dir=$xorg_default
	[ $(chk_family) -ge 430 ] && wine_special='--wine-prefix='$nv_root'/nvidia.'$(new_version)
	[ $(chk_family) -lt 515 ] && open_drv=0 # ensure open driver will not be checked for lower serie.
	if [ $(chk_family) -ge 515 ]; then extract_open=1; ask_open_build=1; enable_powerd=1; fi
	[ $(chk_family) -ge 550 ] && allow_install='--allow-installation-with-running-driver'

	## in some case, kernel or driver or both are uncompatible, we have to try to handle those issues
	## and prevent compilation misbehaviour.
	if [[ -f $issue_log && $(grep -c "$(chk_family)" $issue_log) -gt 0 ]]; then
			local list_family=() line s_line_drv_mod line_ker_ver line_ker_comp
			drv_model=()
			list_family=( "$(grep "$(chk_family)" $issue_log)" )
			for s_line in ${list_family[@]}; do
				line_drv_mod="$(echo "$s_line" | cut -d' ' -f2)"
				line_ker_ver=$(echo "$s_line" | cut -d' ' -f3)
				line_ker_comp=$(echo "$s_line" | cut -d' ' -f4)
				if [ $(nv_kernel_check) -eq $line_ker_ver ]; then
					[[ "${line_ker_comp}" != '' ]] && compatible_kernel=${line_ker_comp}
					uncompatible_kernel=1
					drv_model+=( "$line_drv_mod" )
				fi
			done
	fi
}
nv_cmd_dkms_conf(){
	## check if source dir exit
	chk_dirs(){ [ -d /usr/src/$_src-$(new_version) ]||mkdir -p /usr/src/$_src-$(new_version); }
	## special IGNORE_PREEMPT_RT_PRESENCE script install.
	## add a pre install script for further kernel update through dkms.
	chk_RT(){
		if [ $(is_RT) -eq 1 ]; then
			if [ ! -e /usr/src/$_src-$(new_version)/nvidia.sh ]; then
				cat <<-SCP > /usr/src/$_src-$(new_version)/nvidia.sh
				#! /bin/bash

				if [ \$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$(uname -r)) -gt 0 ]; then
					export IGNORE_PREEMPT_RT_PRESENCE=1
				fi
				SCP
				chown root:root /usr/src/$_src-$(new_version)/nvidia.sh
				chmod 744 /usr/src/$_src-$(new_version)/nvidia.sh
			fi
		fi
	}
	local drv_src _src AUTOINSTALL='' PRE_BUILD='' #POST_BUILD='' # << Not used, legacy
	# Create DKMS conf
	if [ $from_install = 1 ]; then
		echo $"# ${v}${j}($n%)${end} - Create DKMS conf file...${end}"; sleep 2
	else
		echo $"# Create DKMS conf file..."; sleep 2
	fi
	## loop between open and private.
	## test if version support open driver version.
	if [ $(chk_family) -ge 515 ]; then
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
			AUTOINSTALL='AUTOINSTALL="yes"'
		fi
		for _src in ${drv_src[@]}; do
			local mods_list=()
			chk_dirs
			chk_RT
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL=''; else AUTOINSTALL='AUTOINSTALL="yes"'; fi
				else
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL='AUTOINSTALL="yes"'; else AUTOINSTALL=''; fi
				fi
			fi
			if [ $(is_RT) -eq 1 ]; then
				PRE_BUILD='PRE_BUILD="nvidia.sh"'
			fi
			cat <<-EOT3 > /usr/src/$_src-$(new_version)/dkms.conf
			PACKAGE_NAME="nvidia"
			PACKAGE_VERSION="$(new_version)"
			$PRE_BUILD
			$AUTOINSTALL
			MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' IGNORE_CC_MISMATCH='$gcc_mismatch' KERNEL_UNAME=\${kernelver} modules"

			BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
			DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

			EOT3
			o=1
			mods_list+=( "uvm" )
			mods_list+=( "modeset" )
			mods_list+=( "drm" )
			for mods in ${mods_list[@]}; do
				cat <<-EOT4 >> /usr/src/$_src-$(new_version)/dkms.conf
				BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
				DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"

				EOT4
				o=$((o+1))
			done
		done
	fi
	if [ $(chk_family) -lt 515 ]; then
		_src='nvidia'
		chk_dirs
		## dkms config part.
		cat <<-EOT1 > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' IGNORE_CC_MISMATCH='$gcc_mismatch' KERNEL_UNAME=\${kernelver} modules"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

		EOT1
		o=1
		mods_list+=( "uvm" )
		mods_list+=( "modeset" )
		mods_list+=( "drm" )
		for mods in ${mods_list[@]}; do
			cat <<-EOT2 >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
			DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"
			EOT2
			o=$((o+1))
		done
	fi
	if [ $(chk_family) -le 355 ]; then
		_src='nvidia'
		chk_dirs
		cat <<-EOT0 > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' KERNEL_UNAME=\${kernelver} modules"
		CLEAN="'make' clean"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"
		BUILT_MODULE_NAME[1]="\${PACKAGE_NAME}-uvm"
		BUILT_MODULE_LOCATION[1]="uvm/"
		DEST_MODULE_LOCATION[1]="/$(module_dest_location)"
		EOT0
	fi
}
nv_dkms_mok_key(){
	## something can go wrong during module signing, need to figure out.
	# 	/lib/modules/6.1.10-100.fc36.x86_64/build/scripts/sign-file sha512 /var/lib/dkms/mok.key /var/lib/dkms/mok.pub /var/lib/dkms/nvidia/390.157/build/nvidia.ko
	# 	strip -g /var/lib/dkms/nvidia/390.157/build/nvidia.ko

	## for an unknown reason (at least not found) it happens that DKMS MOK keys are not generated.
	## and prevent DKMS compilation to succeed. Then, if not found we're create new self-signed ones.
	mok_signing_key="/var/lib/dkms/mok.key"
	mok_certificate="/var/lib/dkms/mok.pub"
	## this part is more or less taken from dkms script. Thankfully.
	if [ ! "$mok_signing_key" ] || [ ! "${mok_certificate}" ]; then
		echo $"# ${v}${j}($n%)${end} - DKMS MOK key/certificate are missing, generating new one for modules signin process.${end}"
		$d_ssl req -new -x509 -nodes -days 36500 -subj "/CN=DKMS module signing key" \
		-newkey rsa:2048 -keyout "$mok_signing_key" \
		-outform DER -out "$mok_certificate" &>/dev/null
		if [ ! -f "$mok_signing_key" ]; then
			echo $"# ${r}${j}($n%)${end} - MOK $mok_signing_key key not found and/or can't be generated, modules won't be signed${end}"
			## send ERROR if mok gen fail and abort.
			warn_log=$"$( cat <<-ERROR
				${r}MODULES SIGNATURE ERROR${end}.
				$(new_version) compilation can't be done successfully.

				$mok_signing_key and $mok_certificate can't be found
				and attempt to create new ones failed.

				Very sorry about that.
			ERROR
			)"
			die 0 ${LINENO} "$warn_log" ""
		fi
	fi
}
module_signing(){
	if [ -f "$(find -L $(kernel_src) -name "sign-file")" ]; then
		## list modules.
		for mod in $(ls -1 *.ko); do
			echo -e $"# ${nf}${ge}* Signing $mod ...${end}${end}";
			sleep 1
			## find the sign-file script in kernel source
			## NOTE sha512 was used until v2.3.62, but is wrong for modules signature in actual distro which is based on sha256.
			$(find -L $(kernel_src) -name "sign-file") sha256 $mok_signing_key $mok_certificate $mod  # TEST
			## strip on uncompressed modules only
			strip -g $mod
		done
	fi
}
compress_type(){
	grep -q '\.gz:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && echo "gz"
	grep -q '\.xz:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && echo "xz"
	grep -q '\.zst:' /lib/modules/$KERNEL/modules.dep 2>/dev/null && echo "zst"
}
compress_cmd(){
	if [ "${1}" = "gz" ]; then
		gzip -9f -f *.ko || die 0 ${LINENO} "Modules failed to compress as GZ" ""
	elif [ "${1}" = "xz" ]; then
		xz -f -T$proc --check=crc32 --lzma2=dict=1MiB -f *.ko || die 0 ${LINENO} "Modules failed to compress as XZ" ""
	elif [ "${1}" = "zst" ]; then
		zstd -f -rm -T0 -p$proc -f *.ko || die 0 ${LINENO} "Modules failed to compress as ZST" ""
	fi
}
move_modules(){
	[ -d $install_path ] || install_path=$kernel_path
	if [ -e nvidia.ko${mod_suffix} ]; then
		echo -e $"#${nf}${ge}* $safe_msg $module modules in $install_path${end}${end}"; echo $(($n+$o)); o=$(($n+$o))
		cp -f nvidia.ko${mod_suffix} $install_path/nvidia.ko$mod_suffix
		if [[ -s nvidia-uvm.ko${mod_suffix} ]]; then cp -f nvidia-uvm.ko${mod_suffix} $install_path/nvidia-uvm.ko${mod_suffix}; fi
		if [[ -s uvm/nvidia-uvm.ko${mod_suffix} ]]; then cp -f uvm/nvidia-uvm.ko${mod_suffix} $install_path/nvidia-uvm.ko${mod_suffix}; fi
		if [[ -s nvidia-modeset.ko${mod_suffix} ]]; then cp -f nvidia-modeset.ko${mod_suffix} $install_path/nvidia-modeset.ko${mod_suffix}; fi
		if [[ -s nvidia-drm.ko${mod_suffix} ]]; then cp -f nvidia-drm.ko${mod_suffix} $install_path/nvidia-drm.ko${mod_suffix}; fi
	else
		pass=1 && die 0 ${LINENO} "No Nvidia modules to move found" ""
	fi
}
nv_dkms_cmd_line(){
	## syntax :
	## nv_dkms_cmd_line "remove/add/install/build" "$module" "$KERNEL"/'' 1/2/3
	## DKMS evolve over time. It could become complexe to manage some difference between version,
	## so let's do it this there.
	# since 3.2.2, dkms introduced post_transaction options in /etc/framework.conf and execute it at the end of each action.
	# by this way, devs broke all possibilité to activate internal dracut/inittrd.
	# ex opts=( -k $kernel --no-depmod --verbose $force --directive=post_transaction="" )
	local cmd=${1} module=${2} kernel=${3} opts=()
	# remove, all case
	[ ${4} = 1 ] && opts=( --all --verbose --directive=post_transaction='' )
	# add no force, case install
	[ ${4} = 2 ] && opts=( -k $kernel --verbose )
	# else with force, case update
 	[ ${4} = 3 ] && opts=( -k $kernel --verbose $force )
	{ local IFS=' '; $p_dkms ${cmd} -m ${module} ${opts[@]}; } || { echo -e "\n${r}"$"DKMS didn't succeed to execute command. Not fatal, hopefuly.""${end}"; }
}
build_dkms(){
	## back_previous driver in case of FAILURE
	back_old_driver
	## test and fix mok keys if needed.
 	nv_dkms_mok_key
	local drv_src show_dkms make_log_file mod_suffix vermagic line
	# vars reset
	compiled_driver='' pass='' compilation_error=()
		remove_add(){
			remove_seq(){
				echo -e $"#${v} Removing previous ${j}$(old_version)${end} ${y}$_dkms${end} DKMS modules from DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				if [ $(ls -1 /var/lib/dkms/$_dkms/$(old_version)/$KERNEL/$ARCH/module/ | grep -c "nvidia.ko") -gt 0 ]; then
					if [ $(nv_old) -gt $(nv_new) ]; then
						( nv_dkms_cmd_line "remove" "$_dkms/$(old_version)" "" 1 ) | \
						while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
						echo -e "# "
					else
						nv_dkms_cmd_line "remove" "$_dkms/$(old_version)" "$KERNEL" 1 | \
						while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
						echo -e "# "
					fi
				else
					echo "#${ge}${sf} NO MODULE FOUND, nothing to do.${end}${end}"
				fi
				sleep 2
			}
			add_seq(){
				echo -e $"#${v} Add ${j}$(new_version)${end} ${y}$_dkms${end} modules to DKMS tree.${end}"
				echo $(($n+$o)); o=$(($n+$o)) #4
				sleep 2
				( nv_dkms_cmd_line "add" "$_dkms/$(new_version)" "$KERNEL" 3 ) | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
			}
			## remove previous known and unknown version if any before installing new one.
			if [ $(nv_old) -gt 0 ] && [ $(nv_old) -ne $(nv_new) ]; then
				remove_seq
			else
			## if not :
			## is the modules version present in dkms tree ?
				if [ $(old_inst) -gt 0 ]; then
					## check its status.
					if [ $(old_inst) -ne $(nv_new) ]; then
						if [ $($p_dkms status -m $_dkms/$old_version -k $KERNEL| grep -E -c "built|installed") -gt 0 ]; then
							# if build or installed, and not same as new one, check status and 'remove' it.
							remove_seq
						else
							## if not in the dkms tree, just remove them, and make a depmod to clear things.
								echo -e $"#${ge}* Removing out of DKMS tree $old_version $_dkms from kernel modules path.${end}"
								echo $(($n+$o)); o=$(($n+$o)) #3
								sleep 2
								rm -f $kernel_path/*
						fi
						if [ $(dkms_version) -lt 32 ]; then
							echo -e $"# ${ge}* Executing clean depmod before next step.${end}"
							sleep 2
							progress "( exec_depmod "$KERNEL" )" $"\${ge}\${sf} * Exec $KERNEL modules depmod - \$m sec.\${end}\${end}" "$m"
						fi
						echo -e $"# ${ge}* Done.${end}"
						sleep 2

					fi
				else
					echo -e $"# ${ge}* No previous driver found. Installing $(new_version) $_dkms.${end}"
					echo $(($n+$o)); o=$(($n+$o)) #3
					sleep 2
				fi
			fi
			if [ $($p_dkms status -m $_dkms/$(new_version) -k $KERNEL| grep -E -c "added|built|installed") -eq 0 ]; then
				add_seq
			fi
		}
		build_seq(){
			build_seq_1(){
				echo -e $"#${v} Building ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				if [ -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module/nvidia.ko* ]; then
					echo -e $"#${y} * Nothing to do for $(new_version) $_dkms already build.${end}"
					echo -e "exec_mod_tool=1" >> $tmp_vars
					pass=0
				else
					# $p_dkms build -m $_dkms/$(new_version) -k $KERNEL $force 2>&1 | \ # legacy
					( nv_dkms_cmd_line "build" "$_dkms/$(new_version)" "$KERNEL" 3 ) | \
					while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
					echo -e "# "
					if [ -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/module/nvidia.ko.* ]; then
						echo -e $"#${y} * All Clear for $(new_version) $_dkms is build.${end}"
						pass=0
					else
						error_array="$(chk_family) ${_dkms} $(nv_kernel_check)"
						[ $(grep -c "$error_array" $issue_log) -eq 0 ] && echo "$error_array" | tee -a $issue_log &>/dev/null
						compilation_error+=( $_dkms ) # replace the pass variable in error context.
						pass=1
					fi
				fi
				echo -e "pass=$pass" >> $tmp_vars
				echo -e $"# ${y} ---  $_dkms script ended  --- ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #6
				sleep 2
			}
			build_seq_2(){
				echo -e $"#${v} Build and Install ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules for $KERNEL ${end}"
				echo $(($n+$o)); o=$(($n+$o)) #5
				sleep 2
				# $p_dkms install -m $_dkms/$(new_version) -k $KERNEL --verbose $force # legacy
				( nv_dkms_cmd_line "install" "$_dkms/$(new_version)" "$KERNEL" 3 ) | \
				while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
				echo -e "# "
				sleep 2
				echo -e $"#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} modules in $kernel_path ${end}"
				echo $(($n+$o)); o=$(($n+$o))
				if [[ $(nv_modules_presence) -gt 0 && $(/sbin/modinfo -F version nvidia -k $KERNEL | grep -c "$(new_version)") -gt 0 ]]; then
					echo -e $"# ${y}* All Clear for $(new_version) $_dkms in $KERNEL kernel.${end}"
					pass=0
					echo $(($n+$o)); o=$(($n+$o))
					echo -e $"# ${ge}* Check validated (pass=$pass)${end}"
					sleep 2
				else
					error_array="$(chk_family) ${_dkms} $(nv_kernel_check)"
					[ $(grep -c "$error_array" $issue_log) -eq 0 ] && echo "$error_array" | tee -a $issue_log &>/dev/null
					pass=1
					compilation_error=( "$_dkms" )
					echo -e $"# ${ge}* Check unvalidated (pass=$pass)${end}"
					sleep 2
				fi
				echo -e "pass=$pass" >> $tmp_vars
				echo -e "compiled_driver=$_dkms" >> $tmp_vars
				echo -e $"# ${y} ---  $_dkms script ended  --- ${end}"
			}
			case $_dkms in
				open-nvidia)
					compiled_driver=open-nvidia
					case $use_open in
						0) build_seq_1 ;;
						1) build_seq_2 ;;
					esac
				;;
				nvidia)
					compiled_driver=nvidia
					case $open_drv in
						0) build_seq_2 ;;
						1) [ $use_open = 0 ] && build_seq_2 || build_seq_1 ;;
					esac
				;;
			esac
		}
		post_treatment(){
			echo -e $"#${v} Checking ${j}$(new_version)${end} ${y}$_dkms${end} build log presence${end}"
			echo $(($n+$o)); o=$(($n+$o))
			if [ -s /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log ]; then
				test -d $nvlog/dkms/$_dkms/ || mkdir -p $nvlog/dkms/$_dkms/
				cp -f /var/lib/dkms/$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log $nvlog/dkms/$_dkms/
				make_log_file=$nvlog/dkms/$_dkms/make.log
				echo -e "make_log_file=$make_log_file" >> $tmp_vars
				echo -e $"# ${nf}${ge}* $_dkms $(new_version) log found.${end}${end}"
				echo -e $"# ${nf}${ge}* $_dkms make log copied to $make_log_file.${end}${end}"
			else
				echo -e $"# ${ge}* No $(new_version) $_dkms build log found.${end}"
				if [ -f /var/lib/dkms/$_dkms/$(new_version)/build/make.log ]; then
					echo -e $"# ${nf}${ge}* $(new_version) ${r}FAILURE log found${end}.${end}${end}"
					make_log_file=/var/lib/dkms/$_dkms/$(new_version)/build/make.log
					echo -e "make_log_file=$make_log_file" >> $tmp_vars
					echo -e "failure_log=$make_log_file" >> $tmp_vars
					echo -e "compilation_error=( "${compilation_error[@]}" )" >> $tmp_vars
					if [ ${#compilation_error[@]} -gt 0 ]; then
						die 4 ${LINENO} $"${j}* ${r}WARNING${end}: No $_dkms modules found in DKMS build path${end}" ""
					else
						die 4 ${LINENO} $"Driver compilation or post treatment failed." ""
					fi
				fi
			fi
			sleep 2
		}
	## known bug : it appears on unknown reason that DKMS script do not install modules.
	## some solutions is tried here, but not sure of their complete behaviour.
	if [ $open_drv = 1 ]; then
		drv_src=( "open-nvidia" "nvidia" )
	else
		drv_src=( "nvidia" )
	fi
	show_dkms=' (dkms)'
	[ -f $tmp_vars ] && echo -e "show_dkms=' (dkms)'" >> $tmp_vars
	n=15
	o=0
	test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ] # window count divider.
	if [ "$(old_version)" ]; then
		if [ $(nv_old) -ge $(nv_new) ]; then force='--force'; else force=''; fi
	fi
	## get the previous yad pid if any for die process
	list_kill_parent_pids

	for _dkms in ${drv_src[@]} ; do
		echo -e $"#${v} <u>Compiling ${j}$(new_version)${end} ${y}$_dkms${end} DKMS modules </u>${end}"
		echo $(($n+$o)); o=$(($n+$o)) #1
		echo -e $"#${y} ---  $_dkms script start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) #2
		sleep 2
		remove_add
		build_seq
		post_treatment
		echo -e "# "
	done
	echo -e $"#${v} Done${end}"
	echo -e "# "
	echo -e "${esc_message}"
	$x_sleep
}
nv_build_dkms(){
 	if [ $from_install = 1 ];then
		echo -e $"# ${v}${j}($n%)${end} - Build and install DKMS modules...${end}"; sleep 1
	else
		echo -e $"# Build and install DKMS modules."; sleep 1
	fi
 	local pulse=0 log=1 hold=1 hide_txt=1
 	win_log_options
 	y_text=$"Installing ${j}$(new_version)${end} driver over ${y}$KERNEL${end} kernel with DKMS"
 	{ build_dkms ; } | win_yad_progress
}
build_source(){
	local m drv_src show_dkms make_log_file pass mod_suffix vermagic safe_msg
	local make_env='' opts_355='' dep_check=0 pass='' compilation_error=() safe_path=''
	# NOTE : Since 545 serie nvidia-installer can install over a loaded driver, but ... it doesn't really works.
	# UPDATE : Since 580 serie, nvidia-installer install works. Caveat : it install only the designed module in dkms/nvidia.
	# Still useless. Kept for infos only.
	nv_installer(){ ### LEGACY : UNUSED
		[ $(chk_family) -ge 550 ] && {
		## nvidia_installer command line.
		# -k kernel_name, -Z disable nouveau, -z no nouveau check, -b no backup, -n no precompiled --no-rebuild-initramfs.
# 		nvidia-installer -s -z -N -K -b --no-x-check --no-check-for-alternate-installs --dkms \
		$nvdl/nv-update-$(new_version) -s -z -n -K -b -j12 --no-x-check --dkms --no-rpms -M ${module_type} \
		--skip-module-unload --skip-module-load --no-kernel-module-source --no-distro-scripts --allow-installation-with-running-driver \
		--kernel-source-path=$(kernel_src) --kernel-install-path=${kernel_path} \
		--tmpdir=${buildtmp} --log-file-name=${driver_logfile} #| fmt -w 100 | while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
		# -s -z -n -K -b -j12 --no-x-check --dkms --no-rpms --skip-module-unload --no-distro-scripts --allow-installation-with-running-driver
		} || ( restore__driver "old_kernel" && die 0 ${LINENO} "Nvidia installer failed to compile drivers. Known internal error." "" )
	}
	nv_make_mods(){ ### LEGACY : UNUSED
	# Used by nv_installerand also UNUSED.
		nv_installer | while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
		if [ -f ${kernel_path}/nvidia.ko ]; then
			pushd ${kernel_path}
			echo -e $"#${v} Signing ${j}$(new_version)${end} ${y}$module${end} modules.${end}"
			module_signing; echo $(($n+$o)); o=$(($n+$o))
			sleep 1
			echo -e $"#${v} Modules for ${j}$(new_version)${end} are raw. ${y}Compressing in $(compress_type)${end} modules.${end}"
			compress_cmd "$(compress_type)" | while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
			sleep 1
			popd
		fi
		m=1; do_slp=1
		progress "( exec_depmod "$KERNEL" )" $"\${ge}\${sf} * Exec $KERNEL modules depmod - \$m sec.\${end}\${end}" $m
		[ $(nv_modules_presence) -gt 0 ] && /sbin/modinfo -F version ${kernel_path}/nvidia.ko* | grep "$(new_version)" &>/dev/null
		dep_check=$?
	}
	make_cmd(){
		$make_env make -j$proc NV_EXCLUDE_BUILD_MODULES='' IGNORE_CC_MISMATCH="$gcc_mismatch" KERNEL_UNAME=${KERNEL} modules \
		|| { echo -e "\n${r}"$"Make didn't succeed to execute command. Not fatal, hopefuly.""${end}"; }
	}
	make_mods(){
		[ $upgrade_other = 1 ] && make_env='env KERNEL_SOURCES='$(kernel_src)
		[ $(chk_family) -lt 355 ] && 	opts_355="cd uvm/; eval \$(make_cmd); cd ../"
		make_cmd | fmt -w 120 | \
		while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"| grep -v "CONFTEST"; echo "${line}" &>> make.log; done
		$opts_355
		sleep 2
		mod_check
	}
	copy_mods(){
		module=${1} seq_type=${2}
		safe_msg=$"Copying"
		if [ $seq_type = 1 ]; then
			install_path=$kernel_path
			safe_path=/var/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
			dep_check=1
			msg_type=$"Installing"
		else
			install_path=/var/lib/dkms/$module/$(new_version)/$KERNEL/$ARCH/module
			safe_path=''
			dep_check=0
			msg_type=$"Backup"
		fi
		echo -e "#${v} $msg_type ${j}$(new_version)${end} ${y}$module${end} in $install_path:${end}"; echo $(($n+$o)); o=$(($n+$o)) # 5
		sleep 2
		echo -e $"#${nf}${ge}* Compressing $module modules${end}${end}" # 7
		compress_cmd "$(compress_type)" | while read -r line; do echo "#${ge}${sf} ${line}${end}${end}"; done
		# message is send through move_modules fucntion
			if [ "$(compress_type)" != '' ]; then mod_suffix='.'$(compress_type); else mod_suffix=''; fi
			move_modules
			[ "$safe_path" != '' ] && { install_path=$safe_path; safe_msg=$"Saving"; move_modules; }
			## compress modules.
			if [ $dep_check = 1 ]; then
				echo -e $"#${nf}${ge}* Executing $module $KERNEL depmod${end}${end}"
				m=1; do_slp=1
				progress "( exec_depmod "$KERNEL" )" $"\${ge}\${sf} * Exec $KERNEL modules depmod - \$m sec.\${end}\${end}" "$m"
			fi
	}
	mod_check(){
		if [ -e /usr/src/$module-$(new_version)/nvidia.ko ]; then
			echo -e $"#${y} ---  $module Compilation done  --- ${end}"; echo $(($n+$o)); o=$(($n+$o)) # 4
			sleep 2
			echo -e $"#${v} Signing ${j}$(new_version)${end} ${y}$module${end} modules.${end}"
			module_signing; echo $(($n+$o)); o=$(($n+$o))
			if [[ ${#drv_src[@]} -gt 0 ]]; then
				[[ ${module} =~ ^open ]] && { [ $use_open = 1 ] &&  seq_type=1 || seq_type=2 ;}
				[[ ${module} =~ ^nvidia ]] && { [ $use_open = 1 ] && seq_type=2 || seq_type=1 ;}
			else
				seq_type=1
			fi
			copy_mods "$module" $seq_type
			pass=0
		else
			error_array="$(chk_family) ${_dkms} $(nv_kernel_check)"
			[ $(grep -c "$error_array" $issue_log) -eq 0 ] && echo "$error_array" | tee -a $issue_log &>/dev/null
			compilation_error+=( $_dkms ) # replace the pass variable in mog messages context.
			pass=1
		fi
	}
	post_treatment(){
		echo -e $"#${v} Checking ${j}$(new_version)${end} ${y}$module${end} build log presence.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 8
		if [ -s /usr/src/$module-$(new_version)/make.log ]; then
			[ -d $nvlog/source/$module ]|| mkdir -p $nvlog/source/$module
			cp -f /usr/src/$module-$(new_version)/make.log $nvlog/source/$module
			make_log_file=$nvlog/source/$module/make.log
			echo -e "make_log_file=$make_log_file" >> $tmp_vars
			echo -e $"#${ge} * $module $(new_version) log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
			echo -e $"#${ge} * $module make log copied to $make_log_file.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 10
		else
			echo -e $"#${ge} * No $(new_version) $module build log found.${end}"; echo $(($n+$o)); o=$(($n+$o)) # 9
		fi
# 		if [ $dep_check = 1 ]; then
# # 			modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
# 			[ $(nv_modules_presence) -gt 0 ] \
# 				&& { modinfo -F version ${kernel_path}/nvidia.ko* | grep "$(new_version)" &>/dev/null && pass=0 ;} \
# 				|| pass=1
# # 		else
# # 			pass=0
# 		fi
		if [ $pass = 0 ]; then
			echo -e $"#${ge} * $module control passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
			echo -e "pass=$pass" >> $tmp_vars
		else
			echo -e $"#${ge} * $module control not passed (pass=$pass).${end}"; echo $(($n+$o)); o=$(($n+$o)) # 11
			echo -e $"#${j} ---  ${r}ERROR${end}  ---  No modules found in destination path  --- ${end}";
			make_log_file=$nvlog/source/$module/make.log
			echo -e "pass=$pass" >> $tmp_vars
			echo -e "make_log_file=$make_log_file" >> $tmp_vars
			echo -e "failure_log=$make_log_file" >> $tmp_vars
			echo -e "compilation_error=( "${compilation_error[@]}" )" >> $tmp_vars
			if [ ${#compilation_error[@]} -gt 0 ]; then
				die 4 ${LINENO} $"${j}* ${r}WARNING${end}: No $_dkms modules found in build path${end}" ""
			else
				die 4 ${LINENO} $"Driver compilation or post treatment failed." ""
			fi
			restore__driver "old_kernel"

		fi
		sleep 2
	}
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	[ -f $tmp_vars ]&& echo -e "show_dkms=' (from source)'" > $tmp_vars
	## back_previous driver in case of FAILURE
	back_old_driver
	## prepare modules signing (with dmsk mok files)
	nv_dkms_mok_key
	n=10
	o=0
	test ${#drv_src[*]} -gt 1 && n=$[ $n / ${#drv_src[*]} ]
	## get the previous yad pid if any for die process
	list_kill_parent_pids
	for module in ${drv_src[@]} ; do
		pushd /usr/src/$module-$(new_version)
		sleep 1
		echo -e $"# ${v} <u>Compiling ${j}$(new_version)${end} from ${y}$module${end} modules source:</u>${end}"; echo $(($n+$o)); o=$(($n+$o))
		sleep 2
		if [ -d /usr/src/$module-$(new_version) ]; then
			echo -e $"#${y} ---  $module compilation start  --- ${end}"; echo $(($n+$o)); o=$(($n+$o))
			sleep 2
			echo -e $"#${ge} Compilation $module.${end}"
#			nv_make_mods ### LEGACY : UNUSED
 			make_mods
			sleep 2
			post_treatment
		else
			echo -e $"# ${v}Source ${j}$(new_version)${end} ${y}$module${end} unaviable.${end}"; echo $(($n+$o)); o=$(($n+$o))
			echo -e $"# ${v}Check your kernel source three.${end}"; echo $(($n+$o)); o=$(($n+$o))
			return 1 ; base_menu
			echo -e "pass=1" >> $tmp_vars
		fi
		make clean
		echo -e "# "
		popd
	done
	echo -e $"#${v} Done.${end}"
	sleep 2
	echo -e "# "
	echo -e "$esc_message"
	$x_sleep
}
nv_cmd_make_src(){
 	[ -f "$(find -L $(kernel_src) -name "sign-file")" ] || die 1 "${LINENO}" "sign-file kernel script not found" ""
	echo -e $"# Build & install modules from source..."; sleep 1
	## get the previous yad pd if any
	list_kill_parent_pids

 	local pulse=0 log=1 hold=1 hide_txt=1
 	win_log_options
 	y_text=$"Installing ${y}$KERNEL${end} kernel modules from ${j}$(new_version)${end} source directory"
	{ build_source || die 0 ${LINENO} "Build process failed" ""; } | win_yad_progress || die 0 "${LINENO}" "DKMS Yad environnement process failed" ""
}
nv_cmd_install_driver(){
		## we need to give it a chance.
		local probe_open=/etc/modprobe.d/open-NVIDIA.conf
		## prevent installer to doing think for 'upgrade an other kernel'.
		upgrade_other=0
		## check driver source presence and copy it to src dir if necessary.
		if [ ! -d /usr/src/nvidia-$(new_version) ]; then
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel /usr/src/nvidia-$(new_version)
			if [ $extract_open = 1 ]; then
				test $ask_open_build -eq 1 && nv_open_modules_set
			fi
		fi
# 		if [[ $(modinfo -F version nvidia) != $(new_version) ]]; then
		if [ "$(old_version)" != "$(new_version)" ]; then
			if [ $use_dkms = 1 ]; then
				if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel ]; then
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_vars
# 					if [ $pass -eq 1 ]; then
					if [[ -n $pass && $pass -eq 1 ]]; then
						echo "# ${nf}${r}${j}($n%)${end}"$" DKMS compilation ERROR !!""${end}${end}"; sleep 2
					else
						## prevent from mysterious bugs by backup newly compiled modules.
						## backup newly compiled drivers in case of libs install error.
						mkdir -p $nvtmp/new_kernel/dkms/$compiled_driver
						cp -f $kernel_path/nvidia* $nvtmp/new_kernel/
						cp -rf /var/lib/dkms/$compiled_driver/* $nvtmp/new_kernel/dkms/$compiled_driver/
					fi
				fi
			fi
			if [ $use_dkms = 0 ]; then
				echo $"# ${v}${j}($n%)${end} - Nvidia MODULES compilation from source...${end}"; sleep 1
				nv_cmd_make_src
			fi
			if [ $pass = 0 ]; then
				if [ $use_open = 1 ]; then
					if [ $(chk_family) -lt 545 ]; then
						echo -e $"# ${v}Set ${y}$drv_on${end} kernel options.${end}"
						cat <<-CONF > $probe_open
							options nvidia NVreg_OpenRmEnableUnsupportedGpus=1
						CONF
					fi
				else
					[ -f $probe_open ] && rm -f $probe_open
				fi
				## service file patch.
				dm_service_patch
			fi
		else
			[ -f $tmp_vars ] && echo -e "pass=2" >> $tmp_vars
		fi
}
nv_cmd_update(){
	driver_logfile=$nvlog/$(new_version)-$KERNEL.log
	## reset parent list if any
	local compiled_driver='' failure_log='' process_type=1
	## get parent pid for kill process if needed.
	list_kill_parent_pids
	## check for for patch in new version.
	rt_options
	nv_build_options
	## ctrl if kernel is in the issue list of nv_build_options
	uncompatible_kernel_alert

	if [ $extract_open = 1 ]; then
		if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open/* /usr/src/open-nvidia-$(new_version)
		fi
	fi
	## check for open modules presence.
	test $ask_open_build -eq 1 && nv_open_modules_set
	if [ $use_dkms = 1 ]; then
		[ $from_install = 1 ] && nv_cmd_dkms_conf # BUG useless ?
		nv_build_dkms
	else
		if [ $use_dkms = 0 ]; then
			echo -e $"# Nvidia MODULES compilation from source..."; sleep 1
			nv_cmd_make_src
		fi
	fi
	. $tmp_vars

	if [[ -n $pass && $pass -eq 0 ]]; then
		## rebuild initramfs in case of trouble booting.
		echo -e $"# Updating $KERNEL modules."; sleep 1
		if [ $(/sbin/modinfo -F version ${kernel_path}/nvidia.ko* | grep -c "$(new_version)") -gt 0 ]; then
			if [ $exec_mod_tool = 1 ]; then
				echo -e $"# Exec $KERNEL modules reload "; sleep 2
				exec_mod_load
			else
				if [[ $(dkms_version) -lt 32 || $use_dkms = 0 ]]; then
					m=1; do_slp=1
					exec_initramfs $"Rebuilding $KERNEL INITRAMFS (\$m sec.)" "$m"
					[ -e $tmp_count ] && . $tmp_count
				fi
			fi
		else
			die 3 ${LINENO} $"# ERROR ! $KERNEL modules do not match $(new_version). Abort." 1
		fi
	else
		if [ $pass -eq 1 ]; then
			echo -e $"# DKMS compilation ERROR !!"; sleep 2
		fi
 	fi
 	install_log_messages
 	blacklist_and_grub_set
 	## service file patch.
 	dm_service_patch
}
nv_cmd_install_libs(){ # TODO CHECK REGULARY AT DRIVER UPGRADE
## INFOS ABOUT NVIDIA-INSTALLER OPTIONS :
#  --opengl-prefix=OPENGL-PREFIX
#      The prefix under which the OpenGL components of the NVIDIA driver will be installed; the default is:
#      '/usr'.  Only under rare circumstances should this option be used.  The Linux OpenGL ABI
#      (http://oss.sgi.com/projects/ogl-sample/ABI/) mandates this default value.
# --opengl-libdir=OPENGL-LIBDIR
#      The path relative to the OpenGL library installation prefix under which the NVIDIA OpenGL components will
#      be installed.  The default is 'lib' on 32bit systems, and 'lib64' or 'lib' on 64bit systems, depending on
#      the installed Linux distribution.  Only under very rare circumstances should this option be used.
#  --wine-prefix=WINE-PREFIX
#      The prefix under which Wine components of the NVIDIA driver will be installed.  The default is '/usr'.
#  --wine-libdir=WINE-LIBDIR
#      The path relative to the Wine installation prefix under which Wine components of the NVIDIA driver will be
#      installed.  The default is '<opengl-libdir>/nvidia/wine', where <opengl-libdir> is the path determined for
#      --opengl-libdir above.
#	-b --no-sigwinch-workaround --no-distro-scripts $no_check \	
#	--x-prefix=$xorg_dir --x-module-path=$xorg_dir/modules --opengl-prefix=$croot_all \
#	sh $run_pkg -a $quiet -z -Z --no-x-check --ui=none $unified \
#	--kernel-source-path=$kernel_src --kernel-install-path=$kernel_path  --no-abi-note \
#	sh $run_pkg -s -z -N --no-x-check \
## EXTRA INFOS
#	$nocheck --no-kernel-module --no-opengl-files --skip-module-unload \
#	--no-recursion --opengl-headers --install-libglvnd --glvnd-glx-client --force-libglx-indirect  --opengl-libdir=$master$ELF_64 \
#	--utility-prefix=$install_dir --utility-libdir=$install_dir/$master$ELF_64 \
# 	temp="--tmpdir=$buildtmp"

	## create base libs install directories
	for d in {$nv_root/nvidia.$(new_version)/$master$ELF_32,$nv_root/nvidia.$(new_version)/$master$ELF_64,$nv_xorg_dir}; do
		[ -d $d ] || mkdir -p $d
	done
	## get the previous yad pid if any for die process
	list_kill_parent_pids

	# nvidia-installer libraries log file
	lib_logfile=$nvlog/libinstall-$(new_version).log
	## install default libs with nvidia-installer
	echo "# "
	echo $"# ${v}${j}($n%)${end} - <u>Install Nvidia default libraries</u>${end}"; sleep 1

	y_text=$"Installing ${j}$(new_version)${end} libraries to $nv_root/nvidia.$(new_version)"
	local pulse=1 log=1 hold=1 hide_txt=1
	win_log_options
	pushd $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)
	{ timeout=120 ;{
	echo -e $"# ${j}<b>libraries installation in background</b>${end}"
	echo -e $"# ${y}Please wait...${end}"
	{ ${install_bin} -s -z $no_net --no-x-check --no-distro-scripts --no-kernel-module --skip-module-unload --no-recursion \
	$gl_headers $add_glvnd $force_glvnd --install-compat32-libs \
	--compat32-prefix=$nv_root/nvidia.$(new_version) $compat32 $compat64 \
	--x-prefix=/usr --x-library-path=$nv_root/nvidia.$(new_version) --x-module-path=$nv_xorg_dir/modules \
	--opengl-prefix=$nv_root/nvidia.$(new_version) $wine_special --utility-prefix=$install_dir \
	$docs $profile --tmpdir=$buildtmp --log-file-name=$lib_logfile 2>&1 | fmt -w 100 | \
	while read -r line; do echo -e "# ${y}${sf}${line}${end}${end}"; done ;}
	echo -e "# "
	echo -e "$esc_message"
	$x_sleep
	}& eval lpid=$!; y_pulse; } | win_yad_progress #|| die 3 ${LINENO} "Yad librairies install window failed.\nAborting." "restore__driver \"old_kernel\""
	popd
	## report nvidia installer log message
	if [ $(cat $lib_logfile| grep -c "WARNING") -gt 0 ]; then
		if [ $(cat $lib_logfile| grep "WARNING"| grep -c "libGL.so") -gt 0 ]; then
			report_log+=($"${vB}Nvidia-installer:\t\t${end}${jB} no effect\t${end}> ${y}WARNING on missing /usr/lib(32/64)/LibGL.so link,\n\t\t\t\t\t\t    LibGL.so is already link in default nvidia's libraries directory${end}.\n")
		elif [ $(cat $lib_logfile| grep "WARNING"| grep -c "libglvnd") -gt 0 ]; then
			report_log+=($"\t\t\t\t${jB} no effect\t${end}> ${y}WARNING missing libglvnd developpement files.${end}\n")
		fi
	fi
}
nv_cmd_install_cuda(){
	# cuda_12.9.1_575.57.08_linux.run
	echo "# "
	echo $"# ${v}${j}($n%)${end} - <u>Install Nvidia Cuda Toolkit</u>${end}"; sleep 1
	## get the previous yad pid if any for die process
	list_kill_parent_pids

	y_text=$"Installing ${j}$(new_cuda_version)${end} libraries in system tree"
	local pulse=1 log=1 hold=1 hide_txt=1
	win_log_options
	pushd $(user_CF_DIR)/cuda/
	{ timeout=120 ;{
	echo -e $"# ${j}<b>libraries installation in background</b>${end}"
	echo -e $"# ${y}Please wait...${end}"
	sh ${cuda_package} --silent --toolkit --override 2>&1 | fmt -w 100 | \
	while read -r line; do echo -e "# ${y}${sf}${line}${end}${end}"; done
	echo -e "# "
	echo -e $esc_message
	$x_sleep
	}& eval lpid=$!; y_pulse; } | win_yad_progress
	popd
}

### INSTALL MODULE AND LIBRARIES PROCESS ###
## ### MAIN SECTION ###
## LOGS ###
install_log_messages(){
	local yad_warn
	lib_overwrite=0
	## install log messages
	if [ -n $pass ]; then
		if [ $pass -eq 0 ]; then
	# 		if [ "$timeout" != '' ];then
			if [ $from_install = 0 ];then
				echo $"# Modules build done."; sleep 2
			else
				echo $"# ${v}${j}($n%)${end} - Modules build done.${end}"; sleep 2
			fi
			report_log+=($"${vB}Driver build$show_dkms:\t\t${end}${gB} success\t${end}> ${y}Installation complete with no error${end}\n")
		fi
		if [ $pass = 1 ]; then
			list_kill_parent_pids
	# 		if [ "$timeout" != '' ];then
			if [ $from_install = 0 ];then
				echo $"# Modules build ERROR."" (${compilation_error[@]})"; sleep 2
			else
				echo "# ${nf}${r}${j}($n%)${end}"$" Modules build ERROR."" (${compilation_error[@]})""${end}${end}"; sleep 2
			fi
			report_log+=($"${vB}Driver build:\t\t\t${end}${rB} failure\t${end}> ${y}ERROR, 'make' exit with 'failed' state${end}\n")
			warn_log=$"$( cat <<-ERROR
				${r}MODULES BUILD RETURN ERRORS.${end}.
				$(new_version) ${compilation_error[@]} compilation failed.
				Source make.log has been saved in <i>$failure_log</i>.

				Do you want to read $failure_log ?
			ERROR
			)"
			ok_lbl=$"Yes"'!zen-ok'; cancel_lbl=$"No thanks, shits happens"'!zen-close'
			yad_warn=$( win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
			if [ -f $failure_log ]; then
				if [ $yad_warn = 0 ]; then
					IFS=$(echo -en "\n\b")
					log_txt=$"${j}$(new_version)${end} compilation log text"
					log_brief=$failure_log
					cancel_lbl=$"Exit"'!gtk-close'; ok_lbl=$"Back to main"'!zen-back'
					w_formatted=1; w_wrap=1; w_width='720'; w_height='400'; all_btn=1; colors=1
					read_view=$(win_yad_text "$log_brief" 0 "")
					if [ $read_view = 0 ]; then base_menu; else exit 0; fi
				fi
				[[ -d /var/lib/dkms/${compilation_error[0]}/$(new_version)/build ]] && rm -rf /var/lib/dkms/${compilation_error[0]}/$(new_version)/build
				[ $process_type = 0 ] && restore_broken_install
				[ ${#compilation_error[@]} -eq 0 ] && exit 1
			else
				[ ${#compilation_error[@]} -eq 0 ] && die 3 ${LINENO} "$failure_log not found\nBack to main menu" "base_menu"
			fi
		fi
		if [ $pass = 2 ]; then
	# 		if [ "$timeout" != '' ];then
			if [ $from_install = 0 ];then
				echo $"# Modules already build and present in $kernel_path."; sleep 2
			else
				echo $"# ${y}${j}${nf}($n%)${end}${end} - Modules already build and present in $kernel_path.${end}"; sleep 2
			fi
			warn_log=$"$( cat <<-ERROR
				${r}<b>MODULES ALREADY BUILD</b>${end}
				$(new_version) is the same as in kernel path.

				<b>IMPORTANTE NOTE</b> : Nvidia-installer remove all DKMS tree dedicated
				to the current used modules. this is an Nvidia issue.
				Use libraries install replay with caution.
				<small>dkms driver tree will be saved and restore if needed.</small>

				If you decide to continue anyway, consider the section
				${j}update driver${end} > ${j}update driver only${end} or
				restoring $(new_version) backup, if you experience any issue.

				What do you want to do ?
			ERROR
			)"
			ok_lbl=$"Continue"'!zen-ok'; cancel_lbl=$"Abort installation"'!zen-close'
			yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
			if [ $yad_warn -ge 1 ]; then
				[ $process_type = 0 ] && restore_broken_install
				list_kill_parent_pids
	 			exit 1
				base_menu
			fi
			lib_overwrite=1
		fi
	fi
	## realtime report messages.
	if [ $(is_RT) -eq 1 ]; then
		report_log+=($"\t\t\t\t${gB} kernel option ${end}>${y} Kernel $KERNEL is REALTIME${end}.\n")
	fi
	## open driver install report messages.
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -eq 1 ]; then append=$"open driver loaded"; else append=$"close source loaded"; fi
		report_log+=($"${vB}Open Driver:\t\t\t${end}${gB} compiled\t${end}>${y} $append${end}\n")
	fi
}
install_report_log(){ # WATCH
	## display final message depends of exit status.
	$d_yad --title="$WIN_TITLE" --window-icon=$img_zen_desktop --width=500 --borders=20 --center \
	--text=$"${j}${bf}Install Report${end}${end}${v}\n\n $(cat <<< ${report_log[*]})${end}\n$rep_msg" \
	--button=$"edit later"'!zen-undo:1' --button=$"edit now"'!zen-warning:0'
	log_exit=$?
	xorg_check
	if [ $log_exit = 0 ]; then
		edit_xorg_conf
	fi
}
xorg_check(){
	## prevent user xorg config overwrite.
	local yad_warn is_nv
	if [ -e /etc/X11/xorg.conf ]; then
		[ -f /etc/X11/xorg.conf.nvidia ] && is_nv=$" for Nvidia drivers" || is_nv=""
		warn_log=$"$( cat <<-WARN
				${y}<b>Xorg configuration file${is_nv} has been change</b>${end}

				<b>WARNING</b> : <b>Xorg file already exist</b>.
				Validating will overwrite this file by a fresh one.
				<small><i>A backup of previous will be made in /etc/X11 (xorg.conf.[nvidia]~)</i></small>

				Do you want to overwrite ?
			WARN
		)"
		ok_lbl=$"Overwrite"'!zen-ok' ; cancel_lbl=$"Keep"'!zen-close'
		yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
		# if yes overwrite, if no pass.
		if [ $yad_warn = 0 ]; then
			install -bm644 $x_tmp /etc/X11/xorg.conf.nvidia
			ln -sfr /etc/X11/xorg.conf.nvidia /etc/X11/xorg.conf
		fi
	fi
}
## INITIAL OR UPGRADE INSTALL PROCESS
INSTALL_DRIVER(){
	local warn_log yad_warn report_log compiled_driver='' final_installed_mod_version=''
	## tell script that all POST_INSTALL process came from global install. Needed in some cases.
	from_install=1
	## check for for patch in new version.
	nv_build_options
	rt_options
	# win_yad_warns
	warn_log=$"$( cat <<-WRN
		$menu_msg
		${v}Installing driver ${j}$(new_version)${end} for hardware : ${j}$install_dev${end}${end}.
	WRN
	)"
	ok_lbl=$"Install"'!zen-ok' ; cancel_lbl=$"Back to main"'!zen-close'
	yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
	if [ $yad_warn -ge 1 ]; then base_menu; fi

	### REAL START HERE
	if [[ -s $run_pkg ]] ; then
	y_text=$"Installing ${j}$(new_version)${end} driver version for ${y}$dev_name${end}."
	local pulse=0 log=1 hold=0 hide_txt=1
	win_log_options
	## set timout to 0 for install_log_messages
	## reset pass ctrl in case of killing insallation or compilation process.
	local timeout=0 pass=''
	{	## set start count
		n=1
		## check compatiblity files before executng anything. (4)
		echo $"# ${v}${j}($n%)${end} - <u>Compat check and package extraction</u>${end}"; sleep 2
		n=$[ $n+1 ] ; echo "$n"
		echo $"# ${v}${j}($n%)${end} - Checking compatibility data files${end}"; sleep 1
		# DRV is used by hardware_compat function.
		DRV=$(new_version)

		for e in ${dev_n[@]}; do
			if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
				hardware_compat
				. $tmp_vars
			fi
		done
		echo "$install_msg" ; n=$[ $n+5 ]; echo "$n"; sleep 2 # 1
		## ctrl if kernel is in the issue list of nv_build_options
		uncompatible_kernel_alert
		## extract .run package for install processes (22)
		extract_build
		[ -e $tmp_count ] && . $tmp_count
		echo "$n"
		## at install only, nvidia-installer is located in temp rep.
		install_bin="./nvidia-installer"
		if [ ${backup_prev} = 1 ]; then
			echo $"# ${v}${j}($n%)${end} - Backing up old driver version, if any${end}"; sleep 2
			#
			# backup driver repository (shits happens!)
			if [ -d $nv_root/nvidia.$(old_version) ]; then
				bak_version=$(old_version)
				if [[ -s $nv_backup_dir/nvidia.$bak_version.tar$zip_ex ]]; then
					echo $"# ${y}${j}($n%)${end} - Driver already backed up. Skipped.${end}"; sleep 1
					report_log+=($"${vB}Previous version:\t\t${end}${gB} passed\t${end}> ${y}previously backed up${end}\n")
				else
					y_text=$"Backup : $bak_version backup archive creation"
					local pulse=1 log=0 hold=0 hide_txt=0
					win_log_options
					{ timeout=30; {
					backup_old_version; } & eval lpid=$!; y_pulse; } | win_yad_progress
					report_log+=($"${vB}Previous version:\t\t${end}${gB} success\t${end}> ${y}$bak_version normal backup process${end}\n")
					log=1
				fi
			else
				report_log+=($"${vB}Previous version:\t\t${end}${jB} warning\t${end}> ${y}no directory to archive.${end}\n")
			fi
		fi
		n=$[ $n+5 ] ; echo "$n"
		## temp value to n
		p=$n
		echo "# "
		echo $"# ${v}${j}($n%)${end} - <u>Starting install</u>${end}"; sleep 1

		cd $nv_root
		# nv_cmd processes (install without X crash )
		echo $"# ${v}${j}($n%)${end} - Package compil and install${end}"; sleep 1

		## backup previous drivers in case of compilation or libs install failure.
		if [ -f $kernel_path/nvidia.ko* ]; then
			[ $(/sbin/modinfo -F license nvidia -k $KERNEL| grep -ic "nvidia") -gt 0 ] && compiled_driver=nvidia || compiled_driver=open-nvidia
			mkdir -p $nvtmp/old_kernel/dkms/$compiled_driver
			cp -f $kernel_path/nvidia* $nvtmp/old_kernel/
			cp -rf /var/lib/dkms/$compiled_driver/* $nvtmp/old_kernel/dkms/$compiled_driver/
		fi
		## ALERT REVERSE PROCESS FOR 396 SERIE AND OLDER.
		if [ $(chk_family) -gt 396 ]; then
			process_type=1
			# install driver first, then control if everything ok
			nv_cmd_install_driver
			. $tmp_vars
			n=$[ $n+5 ]; echo "$n" # 3
			install_log_messages
			echo "$n"
			# then install libs.
			nv_cmd_install_libs
			final_installed_mod_version=$(/sbin/modinfo -F version nvidia -k $KERNEL)
			if [ $lib_overwrite = 1 ]; then
				## Nvidia-installer, no matter what, remove dkms used driver three in case
				## of a libraries reinstall only. sometime in conjonction with installed kernel modules.
				if [[ $(nv_modules_presence) = 0 || ! -d /var/lib/dkms/$compiled_driver ]]; then
				echo $"# ${nf}${y}${j}($n%)${end} - Nvidia-installer has deleted the installed modules !? O_o${end}${end}"; sleep 1
					if [ -f $nvtmp/new_kernel/nvidia.ko* ]; then
						back_drive=$"new compiled and dkms folder"
						func_option=new_kernel
						exec_mod_tool=0
					else
						back_drive=$"previous drivers and dkms folder"
						func_option=old_kernel
					fi
					echo $"# ${nf}${y}${j}($n%)${end} - Restoring ${back_drive} from backup.${end}${end}"; sleep 1
					restore__driver "${func_option}"
				fi
			fi
		else
			process_type=0
			# Older serie remove any driver installed no matter what.
			# so, install lib first, then drivers.
			nv_cmd_install_libs
			# then install drivers
			nv_cmd_install_driver
			. $tmp_vars
			n=$[ $n+5 ]; echo "$n" # 3
			install_log_messages
			echo "$n"
			final_installed_mod_version=$(/sbin/modinfo -F version nvidia -k $KERNEL)
		fi
		## control if libraries are properly installed
		if [ $(ls -Ub1 $nv_root/nvidia.$(new_version)/$master$ELF_64 | wc -l) -lt 40 ]; then
			die 1 ${LINENO} $"${v}${r}LIBS INSTALL CONTROL RETURN ERRORS.${end}.\nCheck $lib_logfile for more details.${end}" ""
		else
			report_log+=($"${vB}Libraries install:\t\t${end}${gB} success\t${end}> ${y}normal install process${end}.\n")
			lib_pass=0
		fi
		n=$[ $n+5 ]; echo "$n" # 4
		if [ "$pass" != '' ]; then
			if [ $pass -eq 0 ]; then
				echo $"# ${v}${j}($n%)${end} - <u>Linking ${y}$(new_version)${end} directory to the system.</u>${end}"; sleep 1
				## link to sys.
				ln -sfr -T $nv_root/nvidia.$(new_version) $nv_root/nvidia
				n=$[ $n+1 ]; echo "$n"
				## rebuild initramfs or modprobe reload.
				if [ $exec_mod_tool = 1 ]; then
					echo -e $"# ${v}${j}($n%)${end} - Exec $KERNEL modules reload ${end}"; sleep 2
					exec_mod_load
				else
					if [ $(dkms_version) -lt 32 ]; then
						echo $"# ${v}${j}($n%)${end} - <u>Re-create ${j}$KERNEL${end} initramfs.</u>${end}"; sleep 1
						m=0; do_slp=1; exec_initramfs $"\${ge}\${sf} * (\$m%) Exec $KERNEL modules init/reload\${end}\${end}" "$m"
					fi
				fi
				n=$[ $n+20]; echo "$n"
				if [ ${use_cuda} -gt 0 ]; then
					echo "cuda script"
				fi
			fi
		fi
		echo $"# ${v}${j}($n%)${end} - Update new driver version file${end}"; sleep 2
		#
		printf "$(new_version)" > $nvdir/version.txt
		printf "$(new_version)" > $(user_CF_DIR)/version.txt
		n=$[ $n+2 ]; echo "$n" # 7
		# create xorg temp here to take care of further needs in process.
		POST_INSTALL
		echo "99"; sleep 2
		echo "100"
		## Install report display.
		if [ "$pass" != '' ]; then
			if [[ $pass -eq 0 || $pass -eq 2 && $lib_pass -eq 0 ]]; then
				if [ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| wc -l) -gt 40 ]|| \
				[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| wc -l) -gt 40 ]; then
					rep_msg=$"$( cat <<-RPT
					${v}<small>${j}<b>Nvidia-settings user profile warning</b>${end}
					${y}Default nvidia profile rc file${end} is always overwritten during driver isntallation/update. Keep in mind that the ${y}user profile rc file${end} is the
					only one you can edit as you wish for your applications. <u>Do not never ever edit ~/.nv/nvidia-application-profiles-rc !</u>
					<i>(user profile rc location : ~/.nv/nvidia-application-profiles-rc.d/user-application-profiles-rc)</i></small>

					<b><big><i>Congratulations !</i></big></b>
					<b>${j}$(new_version)${end} driver is now succefully installed</b>.

					You may now configure your ${j}xorg.conf${end} file to fit with your current default display before restarting
					your computer with the new installed drivers.
					You may also do it later if you like, but it's not really recommanded.

					What do you want to do ?${end}
					RPT
					)"
					install_report_log
				fi
			else
				warn_log=$"$(
				cat <<-RPT
					${r}<b><big>Unexpected ERROR.</big></b>${end}
					${j}<b>$final_installed_mod_version isn't $(new_version)</b>${end}.
					Really weird. ${jB}O_o${end} !
					Some unknown bug pops up during driver installation.
					Or developper fucked out something ?
					Can't tell.
				RPT
				)"
				die 1 ${LINENO} "$warn_log" ""
			fi
		else
			die 3 ${LINENO} "Installation process died from parents kill." "base_menu"
		fi
		} | win_yad_progress
		. $tmp_vars
		if [ "$pass" != '' ]; then
			if [ $pass -eq 0 ]; then
				if [ $(/sbin/lsmod | grep -c "nouveau") = 0 ]&&[ -e $systemd_dir/$(dm_serv).service ]; then
					warn_log_title=$"${j}<big>$(new_version) installed ended</big>${end}"
					restart_dm_warn
				else
				## nouveau is still loaded, reboot to take effect.
					warn_log=$"$(
					cat <<-RPT
						${y}<b><big>Driver installation complete</big></b>${end}

						Because <b>Nouveau driver</b> is still loaded you need
						to reboot the system for change to take effects.

					RPT
					)"
					cancel_lbl=$"Got it"'!zen-close'; ok_lbl=''
					win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "zen-warning"
				fi
			fi
			from_install=0
			base_menu
		else
			return 0
		fi
	else
		DIE_TXT=$"$(
			cat <<-TXT
				${jB}No proper Nvidia package found.${end}
				<b>Main INSTALL process has died !</b>

				You may to download the driver package manually for your ${dev_name}.
				Got to the Nvidia site : <b>http://www.nvidia.fr/Download"</b>,
				or directly to the NVIDIA ftp repository <b>https://download.nvidia.com/XFree86</b>.
			TXT
			)"
		die 1 ${LINENO} "$DIE_TXT" ""
	fi
}

extract_build(){
	pushd $nvtmp
	extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
	if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version) ]; then
		echo $"# ${v}${j}($n%)${end} - $(new_version) package already extracted${end}"; sleep 2
		n=$[ $n+30 ]
	else
		[ ! -d NVIDIA-Linux-$ARCH-* ]|| rm -Rf NVIDIA-Linux-$ARCH-*
		## save dir name for install and post install process.
		echo $"# ${v}${j}($n%)${end} - Primary package extraction${end}"; sleep 2
		m=$n; do_slp=1
		progress "$run_pkg -x" $"\${v}\${j}(\$m%)\${end}\${ge}\${sf} * (\$m%) Extracting $extracted_release\${end}\${end}\${end}" "$m"
		sleep 1
		if [ -d $extracted_release ]; then
			cp -f $nvtmp/$extracted_release/nvidia-installer .
 			echo -e "$(new_version)" > $nvdir/new_version.txt
		else
			warn_log=$"${j}${bf}Nvidia repository not found${end}${end}.${v} Extraction failure.${end}"
			die 3 ${LINENO} "$warn_log" "base_menu"
		fi
	fi
	popd
}
## temporary download/install directory
tmp_dir(){
	## create default install/update temp dirs & files
	# in case of interrupt, check first if zenvidia tmp dir exist.
	if [ -d $zen_tmp_dir ]; then
		# set temp file for re_sued fonction variables
		tmp_vars=$(mktemp $zen_tmp_dir/zn_vars.XXXX)
		# set temp file for old-version backup when new modules installed
		tmp_old=$(mktemp $zen_tmp_dir/zn_old.XXXX)
		# set temp dir for extract & build processes
		nvtmp=$(mktemp -d $zen_tmp_dir/nv_extract.XXXX)
		mkdir -p $nvtmp/build
		buildtmp=$nvtmp/build

		# set tmp_old content for following use.
		if [ $(version) ]; then echo "$(version)" > $tmp_old; else echo "0" > $tmp_old; fi
	fi
}
## BACKUP & PROGRESS COUNT
## progress counters.
fix_odd_number(){
	bc -l <<< "scale=0; x=$m; i = x/1; f = x - i; \
		if (x>=0) { if (f>=0.5) i+1 else i } \
		else { if (f<=-0.5) i-1 else i } \
		"
}
tar_count(){
	tar_cmd(){
		eval "${cmd} ${file} ${object}" &>/dev/null
		if [ $? = 0 ]; then
			clean_object=$(sed -n 's/\///p' <<< ${object})
			tar -tvf ${file} ${clean_object} &>/dev/null
			[ $? = 0 ] || \
			if [ -f ${object} ]; then
				echo -e $"line ${fail_line} - ${object} : not save in tar ball." >> fail.log
				return 0
			fi
		else
			echo -e $"line ${fail_line} - ${object} : not found in system tree." >> fail.log
			return 0
		fi
	}
	wait_count(){
		echo -e $"# ($timer s) - Backup : ${bak_version} tar ball creation"
		sleep $do_slp
		wait $pid
	}
	local cmd file object fail_line clean_object prt
	cmd=${1} ; file=${2} ; object=${3} fail_line=${4}
	timer=$(echo "$m" | fix_odd_number )
	$(tar_cmd) & pid=$! wait_count
	m=$(bc -l <<< "$m+$do_slp")
 	echo "$m"
 	return
}
progress(){
	tmp_count=$(mktemp $zen_tmp_dir/zn_count.XXX)
	local m p_msg pid exitval
	p_msg="${2}"
	m=$((${3}+1))
	if [[ ${1} ]]; then
		progress_msg(){
			local msg=${1} cnt=${2}
			if [ $(x_check) -gt 0 ]; then
				echo -en "${msg}"
			else
				echo -e "# ${msg}"; echo "${cnt}"
			fi
		}
		eval_pid(){
			while [ -d /proc/$pid ]; do
				( eval "progress_msg \"${p_msg}\" ${m}" ) || die 1 "${LINENO}" "Progress tool failed to parse message patterns" ""
				sleep $do_slp &
				wait $!
				m=$((m+1))
			done
			echo -e "n=$m" > $tmp_count
			echo -e "p_pid=$pid"  > $tmp_count
		}
 		( eval "${1}" &>/dev/null ) & pid=$! eval_pid
		. ${tmp_count}
		wait $p_pid 2>/dev/null
		exitval=$?
   fi
   return $exitval
}
y_pulse(){
	while [ -d /proc/$lpid ]; do
		for ((i=1; i<=$timeout; i++)) {
			echo $i 2>/dev/null
			sleep 0.096
			}
	done
 	return
}
## previous version backup command.
backup_old_version(){
	[ -d $nv_backup_dir ]|| mkdir -p $nv_backup_dir
	if [ -d $nv_root/nvidia.$bak_version ]; then
		pushd $nv_backup_dir
		## make the archive.
 		local zip_cmd warn_log
		[ -f fail.log ] && echo "" > fail.log || touch fail.log
		local m='0.25'
		local do_slp=$m
		local tar_synt='tar -r -f'
		tar_count "tar -c -f" "nvidia.$bak_version.tar" "/etc/OpenCL" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/default/grub" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/ld.so.conf.d/nvidia-*" ${LINENO}
		test -f /etc/udev/rules.d/01-nvidia-driver.rules && \
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/udev/rules.d/01-nvidia-driver.rules" ${LINENO}
		## save modules conf if exist.
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/modprobe.d/blacklist-nouveau.conf" ${LINENO}
		#tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/modprobe.d/blacklist-bisou.conf"  ${LINENO} # FAIL TEST LINE
		test -f /etc/modprobe.d/nvidia-blacklist.conf && tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/modprobe.d/nvidia-blacklist.conf" ${LINENO}
		test -f /etc/modprobe.d/nvidia-drm.conf && tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/modprobe.d/nvidia-drm.conf" ${LINENO}
		test -f /etc/modprobe.d/open-NVIDIA.conf && tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/modprobe.d/open-NVIDIA.conf" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/vulkan/icd.d/nvidia_icd.json" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/vulkan/implicit_layer.d/nvidia_layers.json" ${LINENO}
		## if backup is create with a use_open var to 1 and the present driver config is different,
		## open-NVIDIA.conf file is not enought to tell the right way of use. User's use_open var must be saved too.
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/home/$(def_user)/.zenvidia/basic.conf" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/X11/xorg.conf" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/X11/xorg.conf.nvidia" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/systemd/system/systemd-hibernate.service.wants" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/systemd/system/systemd-suspend.service.wants" ${LINENO}
		## take care of dkms auto install behaviour upon open source driver installation.
		test -f /etc/dkms/no-autoinstall && tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/etc/dkms/no-autoinstall" ${LINENO}
 		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/lib/modules/$KERNEL/$(module_dest_location)/nvidia*" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/lib/firmware/nvidia/$bak_version" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "$nv_root/nvidia" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "$nv_root/nvidia.$bak_version" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/lib/systemd/system/nvidia-*" ${LINENO}
 		[ -d /usr/$master$ELF_32/nvidia ]&& tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/$master$ELF_32/nvidia" ${LINENO}
 		[ -d /usr/$master$ELF_64/nvidia ]&& tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/$master$ELF_64/nvidia" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/share/X11/xorg.conf.d/nvidia-drm-outputclass.conf" ${LINENO}

		make -C /usr/src/nvidia-$bak_version clean
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/src/nvidia-$bak_version" ${LINENO}
		if [ -d /usr/src/open-nvidia-$bak_version ]; then
			make -C /usr/src/open-nvidia-$bak_version clean
			tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/usr/src/open-nvidia-$bak_version" ${LINENO}
		fi
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "$install_dir/bin/nvidia-*" ${LINENO}
		if [ $(ls -1 /usr/local/$master$ELF_32/ | grep -c "libnvidia") -gt 0 ]; then
			tar_count "${tar_synt}" "nvidia.$bak_version.tar" "$install_dir/$master$ELF_32/libnvidia-{fbc{.so,.so.1},*.$bak_version}" ${LINENO}
			tar_count "${tar_synt}" "nvidia.$bak_version.tar" "$install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}" ${LINENO}
		else
			tar_count "${tar_synt}" "nvidia.$bak_version.tar" "$install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}" ${LINENO}
 		fi
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/var/lib/dkms/nvidia/$bak_version/{source,$KERNEL}" ${LINENO}
		[ -d /var/lib/dkms/open-nvidia/$bak_version ] && \
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/var/lib/dkms/open-nvidia/$bak_version/{source,$KERNEL}" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "/var/lib/nvidia/{dirs,log}" ${LINENO}
		tar_count "${tar_synt}" "nvidia.$bak_version.tar" "$nvdir/version.txt" ${LINENO}

		if [ "$ZIP" = "ZST" ]; then # ZST is not used, but kept for the future.
			## compress in zst zstd -q -f -T0 -20 --ultra *
			zip_cmd='zstd -q -f -T0 -20 --ultra'
		elif [ "$ZIP" = "XZ" ]; then
			zip_cmd='xz -z -f -T'$proc
		elif [ "$ZIP" = "GZIP" ]; then
			## compress in gz.
			zip_cmd='gzip -fc'
		fi
		local m=$(echo $m | fix_odd_number)
		local do_slp=1
		progress "${zip_cmd} nvidia.$bak_version.tar > nvidia.$bak_version.tar$zip_ex" $"(\$m s) - Backup : $bak_version $ZIP archive creation" "$m"

		[ -f nvidia.$bak_version.tar$zip_ex ] && \
		{ rm -f $nv_backup_dir/nvidia.$bak_version.tar ; echo $"# Backup: $bak_version $ZIP archive created";} || \
		die 2 ${LINENO} $"$ZIP archive not created.\n This is not fatal for other process." ""
		sleep 1
		if [ $(wc -l fail.log| grep -o "[0-9]") -gt 1 ]; then
			die 4 ${LINENO} $"<b>Compression tool report fail state</b>""$(cat fail.log)\n\n"$"This not fatal to other processes." ""
		fi
		popd
	fi

}

## UPDATE DRIVER SECTION
upgrade_new_kernel(){
	local kern_list NEW_KERNEL up_version=$(version)
	ls_kern=$(ls -1 /boot| grep -v "rescue\|$(uname -r)"| grep "vmlinuz"| sed -n 's/^[[:alpha:]]*-//p')
	for linuz in ${ls_kern}; do
		kern_list+=("false")
		kern_list+=("$linuz")
	done
	w_text=$"$( cat <<-MSG
		$menu_msg
		Driver install ${j}$up_version${end} for hardware ${j}${dev_name}${end}.
		Select the kernel to update.
	MSG
	)"
	l_text=$w_text
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b")
	NEW_KERNEL=( $(win_yad_list "${kern_list[*]}" "") )
	if [[ "$NEW_KERNEL"  =~ \. ]]; then
		KERNEL=$NEW_KERNEL
		kernel_path="/lib/modules/$KERNEL/$(module_dest_location)/"
		upgrade_kernel
	else
		if [ ${NEW_KERNEL} = 200 ]; then base_menu; else menu_update; fi
	fi
# 	}
}
upgrade_kernel(){
 	local yad_warn
	warn_log=$"${j}<b>Kernel driver update</b>${end}\n${y}$KERNEL${end} drivers will be update."
	ok_lbl=$"Update"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back'
	yad_warn=$(	win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
	if [ $yad_warn -ge 1 ]; then menu_update; else
		y_text=$"${v}Kernel ${j}$KERNEL${end} driver update${end}"
		local pulse=1 log=0 hold=0 hide_txt=0
		win_log_options
		## tell yad that basic pusle win is pulse
		{ timeout=30 ;{
		echo -e $"# Kernel update $KERNEL ..."
		cd $nvdl/
		nv_cmd_update
# 		[ $pass -gt 0 ] && return 0
		new_version=$(version)
		}& eval lpid=$!; y_pulse; } | win_yad_progress
		if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/update-$KERNEL.log; fi
		base_menu
	fi
}
## FROM A REMOTE/USER DIRECTORY
net_version_selector(){
	local menu_select LAST_PACK LAST_OFFI older_pack list_array
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP

		${v}<b>Select the driver version type to install</b>${end}
		${sf}
		   - <b>Look up for latest</b>:
		   Look for the last available packges from Nvidia repos site.
		   - <b>Look up for older version</b>:
		   Look for a previous packages available in Nvidia repos site.
		${end}
		HLP
		)"
	else
		hlp_tip=$"\n${v}<b>Select the driver version type to install</b>${end}"
	fi
	IFS=$(echo -en "\n\b")
	list_array=( true 1 $"Look for latest version" false 2 $"Look for older version" )
	l_text=$"${j}${bf}Driver version type to install${end}\n${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	menu_select=( $( win_yad_list "${list_array[*]}" "") )
	case $menu_select in
		1) check_for_newer ;;
		2) check_for_older ;;
		200) exit 1 ;;
		100|*) base_menu ;;
	esac
	if [ "$LAST_DRV" != '' ]; then check_update; fi
}
check_dl_command(){
	y_text=$"NVIDIA Download center data check"
	local pulse=1 log=0 hold=0 hide_txt=1
	win_log_options
	{	timeout=30
	{	$p_wget -q -O $upt_compat_dir/last_update https://$nvidia_ftp-$ARCH/latest.txt
	}& eval lpid=$! ; y_pulse ;} | win_yad_progress
}
check_for_older(){
	check_dl_command
	local older_pack rem_packages_list old_pack_list
	local rem_packages_list=( $(sort -Vr $(remove_drv_list)) )
	LAST_OFFI=$(cat $upt_compat_dir/last_update | awk '{ print $1 }')
	ln=0
	for pack_list in "${rem_packages_list[@]}"; do
		[ ${ln} = 0 ] && old_pack_list+=("true") || old_pack_list+=("false")
		old_pack_list+=("$pack_list")
		ln=$(($ln+1))
	done

	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Driver version type to install${end}\n${end}${v}$hlp_tip${end}"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	older_pack=( $( win_yad_list "${old_pack_list[*]}" "") )
	if [ ${#older_pack[*]} -gt 0 ]&&[[ "$older_pack"  =~ \. ]]; then
		LAST_DRV=$older_pack; legacy_drv=1
	else
		LAST_DRV=''
		evac $older_pack "base_menu" 1
	fi
}
check_for_newer(){
	check_dl_command
	LAST_DRV=$(cat $upt_compat_dir/last_update | awk '{ print $1 }')
	legacy_drv=0
}
## UPDATED RELEASE & CUDA CHECK
hardware_compat(){
	local upt_compat_list upt_local_conf COMPAT class_list drv_class line drv_end
	local family_last='' family='' legacy_drv='' family_compat=0

	## check remote site file if netwok connection is available.
	if [ $(connected) = 0 ]; then
		y_text=$"NVIDIA Download center compatibility check (${j}$DRV${end})..."
		local pulse=1 log=0 hold=0 hide_txt=1
		win_log_options
		{	timeout=30
		{	$p_wget -q -O $upt_compat_dir/upt_compat https://$nvidia_ftp-$ARCH/$DRV/README/supportedchips.html
		}& eval lpid=$!; y_pulse; } | win_yad_progress

		cat $upt_compat_dir/upt_compat | sed -n "/<h3>/,/Below are the legacy/{;/<tr\|<td\|<\/tr>/p}"| \
		perl -n -pe "s|(<(/\|)t[r,d](>\| id=\"))||,s|(\">\|</td>)\n|,|p" > $nv_compat_dir/compat.$DRV

		## build a genaral compatibility list for series drivers classes.
		upt_compat_list=$(user_CF_DIR)/updates/upt_compat_list
		upt_local_conf=$(remove_drv_list)

		cat $upt_compat_dir/upt_compat | sed -n "/<h3>/,/name=\"subsys/p"| \
		perl -n -pe "s|(<(/)?t[r,d,a,b](ble\|ody)?(>\| id=\")?)||;s|(\">\|</td>)\n|,|; \
		s|.*legacy_(.*.xx)\">.*|* \1|;s|.*<[/]?[dtpc].*$||p"| \
		sed -n "/^[[:space:]]*$/d;s/^\ //i;p" > $upt_compat_list
		## add a separator at the end.
		echo -e "------" >> $upt_compat_list

		## here start the compatibility tool.
		[ -d $nv_compat_dir ]|| mkdir -p $nv_compat_dir/series
		IFS=$(echo -en "\n\b")
		## define the separation chapter series section.
		COMPAT+=("<h3>")
		COMPAT+=("$(grep -E "\* *[0-9]{2,4}((.xx)|(\.*[0-9]{2,3}.xx))" $upt_compat_list)")
		if [ $(ls -1 $nv_compat_dir/series/ | grep -E -c "^[0-9]*\.[0-9]*\.[0-9]*$") -gt 0 ]; then
			rm -f $nv_compat_dir/series/* | grep -E "^[0-9]*\.[0-9]*\.[0-9]*$"
		fi
		for line in ${COMPAT[@]}; do
			if [[ $line =~ ".xx" ]]; then
				drv_class=$(echo -e "$line"| sed -En "s/\* (.*).xx$/\1/p")
				line=$(cut -d' ' -f2 <<< $line)
			else
				drv_class=$(echo "$DRV"| cut -d. -f1)
			fi
			drv_end=$(cat <<< ${COMPAT[*]}| grep -A1 "$line"| sed -En "s/^\* (.*).xx$/\1/g;\$p")
			test "$drv_end" = "$drv_class" && drv_end='-----'
			## send result in separate compat files.
			sed -En "/$line/,/$drv_end.xx/{/^(0x|devid).*/p}" $upt_compat_list > $nv_compat_dir/series/$drv_class
		done
		IFS=$ifs
	fi

	## build compat file list from created.
	class_list=("$(ls -1 $nv_compat_dir/series/| sort -V)")
	## dig for device id and usual name.
	pci_class=${dev[$e]}
	pci_brand=${slot_id[$e]}
	## check compat.
	# if match, proceed to install.
	if [ $(grep -ic "^[0x|devid]*${pci_brand}," $nv_compat_dir/series/$(echo "$DRV"| cut -d. -f1)) -gt 0 ]; then
		## send message for the INSTALL_DRIVER section.
		if [ $from_install = 1 ]; then
			echo -e $"install_msg='# ${v}${j}($n%)${end} - Compatiblity found in ${y}$(echo "$DRV"| cut -d. -f1)${end} serie, proceed to install${end}'" > $tmp_vars
		fi
	else
	## UNCOMPATIBLE HARDWARE OR DRIVER
	# if not match, check in driver series files if there is a compâttible one.
		for comp_file in ${class_list[@]}; do
			if [ $(grep -ic "^[0x|devid]*${pci_brand}," $nv_compat_dir/series/$comp_file) -gt 0 ]; then
				## message for INSTALL_DRIVER section.
				if [ $from_install = 1 ]; then
					warn_log=$"$(cat <<-ERR
						${rB}${bf}<i>UNCOMPATIBLE DRIVER</i>${end}${end}
						${v}The ${j}$pci_class${end} is not compatible with ${j}$DRV${end} driver.
						Check in ${j}$comp_file${end} serie or greater instead.
						Abort.${end}
					ERR
					)"
					# if met during insttallation process, warn, then go back to main menu.
					die 3 ${LINENO} "$warn_log" "base_menu"
				fi
				## serie driver class for the update/install section.
				# if met during the update process, set serie to family var and continue until win_update section.
				family=$comp_file
			fi
		done
		## define vars for the update/install section.
		if [ $family ]; then
			# family is constantly greater that 0
			if [ $(chk_family) = 0 ]||[ $family -le $(chk_family) ]; then
				# if not (no driver installed) or at least lower or equal to installed version (if any),
				# looks for compatible driver in drv list.
				family_last=$(cat $upt_local_conf | grep "$family" | sed -n '$p')
				legacy_drv=1
				legacy_display_indicator=$((legacy_display_indicator+1))
			else
				# in other case driver is not legacy anymore, proceed as usual.
				legacy_drv=0
			fi
			# mark compatible family as found.
			family_compat=1
		else
			## send fatal if no driver support.
			if [ $from_install = 1 ]; then
				warn_log=$"$(cat <<-ERR
					${rB}${bf}<i>UNCOMPATIBILITY ISSUE</i>${end}${end}
					${v}The ${j}$pci_class${end} is not supported by ${j}NIVDIA${end} driver
					and there's no solution here except reverse to ${j}Nouveau${end} driver.
					Abort.${end}
				ERR
				)"
				die 3 ${LINENO} "$warn_log" "base_menu"
			fi
		fi
		echo -e "family_last=$family_last" >> $upt_comp_tmp # use by legacy check.
		echo -e "family=$family" >> $upt_comp_tmp # use by legacy check.
		echo -e "legacy_result=$legacy_drv" >> $upt_comp_tmp
		echo -e "family_compat=$family_compat" >> $upt_comp_tmp # use by legacy check.
		echo -e "legacy_display_indicator=$legacy_display_indicator" >> $upt_comp_tmp
	fi
}
check_update(){
	## set local vars to default
	local DIFF_list LOCAL_DRV legacy_result=''
	local DEV_filter='' dev_compat='' VDPAU_class=''
	local LOCAL_DRV=()

	LAST_IN=$(version)
	LAST_BETA=$(tac $(remove_drv_list) | sed -n 1p)
	upt_comp_tmp=$(mktemp $zen_tmp_dir/zn_vars.XXXX )
	## COMPATIBILTY SECTION
	# first chack if alpha = beta or not.
	if [[ $LAST_DRV == $LAST_BETA ]] ; then
			DIFF_list+=("$LAST_DRV")
			LAST_UPT=$LAST_DRV
	else
			DIFF_list+=("$LAST_DRV")
			DIFF_list+=("$LAST_BETA")
			LAST_UPT=$LAST_BETA
	fi
	family_check=0 legacy=0 family_compat=0 legacy_display_indicator=0

	## desktop could have more than one device managed. So check.
	for e in ${dev_n[@]}; do # ALERT TODO CHECK
		if [[ "${vnd_id[$e]}" =~ "10de" ]]; then
			for DRV in ${DIFF_list[@]}; do
				## test existence of the new driver version in remote tree and compatibilities.
				hardware_compat
				. $upt_comp_tmp
				## and prepare optional messages to display.
				if [ $(cat $(remove_drv_list)| grep -c $DRV) -gt 0 ]; then
					dl_allow=1
				else
					dl_allow=0
				fi
				# mark driver stocked in local repos.
				local in_pack=$(ls -1 $nvdl/ | grep -c "$DRV")
				test "$DRV" == "$LAST_IN" && _installed=1 || _installed=0
				if [ "$LAST_BETA" ]&&[ "$LAST_BETA" != "$LAST_DRV" ]; then
					if [ $legacy_drv = 1 ]; then
						test "$DRV" == "$LAST_BETA" && _is_beta=0 || _is_beta=1
					else
						test "$DRV" == "$LAST_BETA" && _is_beta=1 || _is_beta=0
					fi
					test $legacy_drv -gt 0 && _is_beta=0
				else
					_is_beta=0
				fi
				if [ $(grep -oic "^[0x|devid]*${slot_id[$e]}" $nv_compat_dir/compat.$DRV) -gt 0 ]; then
				# comp_result in upt_comp_tmp
					DEV_filter=$(grep -wi "^[0x|devid]*${slot_id[$e]}" $nv_compat_dir/compat.$DRV)
					dev_compat=1
					VDPAU_class=$(printf "$DEV_filter"|cut -d"," -f4) # J
				else
					dev_compat=0
				fi
				LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow,$legacy_result")
			done
		fi
	done
	## write it in default script directory for further use.
	echo -e "${COMP_I[@]}" > $nv_compat_dir/compat.update
	sed -i "/^[[:space:]]*$/d;s/^\ //g" $nv_compat_dir/compat.update
	win_update
}
win_update(){
	# reset list and messages
	local COMP_L main_msg more_msg compat_msg ui_mod in_repos
	local reroute=0 sel_cmd=0
	local in_installed=0 in_compat_list=0 in_local_repos=0 in_dl_repos=0 un_compat_list=0 DOWN_list=()
# 	eval in_installed=0 in_compat_list=0 in_local_repos=0 in_dl_repos=0 un_compat_list=0

	## get driver list from check_update to define local presence and what to display.
	# LOCAL_DRV+=("$DRV,$in_pack,$_installed,$_is_beta,$dev_compat,${dev[$e]},$VDPAU_class,$dl_allow,legacy_result")
	# '364.12,0,0,0,"0",GeForce RTX 2060,,1'
	# '525.85.05,1,0,0,"1",GeForce RTX 2060,J,1'
	IFS=$(echo -en "\n\b")
	for local_drv in ${LOCAL_DRV[@]}; do
		_drive=$(echo "$local_drv"|cut -d',' -f1)
		_exist=$(echo "$local_drv"|cut -d',' -f2)
		_insta=$(echo "$local_drv"|cut -d',' -f3)
		_beta=$(echo "$local_drv"|cut -d',' -f4)
		_dev_comp=$(echo "$local_drv"|cut -d',' -f5)
		_name=$(echo "$local_drv"|cut -d',' -f6)
		_vclass=$(echo "$local_drv"|cut -d',' -f7)
		_dl_ok=$(echo "$local_drv"|cut -d',' -f8)
		## messageries
		end_msg=$"What do you want to do ?"

		case $_insta in
			0) set_in='' ;;
			1) set_in=$" (installed)"; in_installed=$((in_installed+1)) ;;
		esac
		if [ "$_vclass" ]; then comp_v=$"(VDPAU class $_vclass)"; fi
		case $_dl_ok in
			0) dl_warn=$"\n${y}but is not downloadable yet (wont be list)${end}" ;;
			1) dl_warn='' ;;
		esac

		case $_dev_comp in
			0) comp_a=$"${vB}uncompatible${end}"
				comp_b=$"${y}$_drive${end} ${rB} driver doesn't manage your hardware${end}\n"
				un_compat_list=$((un_compat_list+1))
			;;
			1) comp_a=$"compatible"
				comp_b=$"${j}$_drive${end} ${v} driver fit your hardware${end} ${y}$(echo -e '\u2764')${end}\n" # or 2714
				in_compat_list=$((in_compat_list+1))
			;;
		esac
		case $_beta in
			0)
			if [ $legacy_drv = 0 ]; then
				set_beta=$"official"; _drv_title=$"official"; tab=''
			else
				if [ "$_drive" == "$LAST_BETA" ]; then
					if [ $LAST_OFFI != '' ]; then
					set_beta=$"beta"; _drv_title=$"beta"; tab='- -'
					else
					set_beta=$"official"; _drv_title=$"last release"; tab=''
					fi
				else
					set_beta=$"legacy" ; _drv_title=$"legacy"; tab=''
				fi
			fi
			;;
			1) set_beta=$"beta"; _drv_title=$"beta"; tab='- -';;
		esac
		case $_exist in
			0) in_repos=$"is not in your repository"
				DOWN_list+=("false"); DOWN_list+=("$_drive"); DOWN_list+=("($_drv_title)"); in_dl_repos=$((in_dl_repos+1))
			;;
			1) in_repos=$"is in your repository"; in_local_repos=$((in_local_repos+1))
			;;
		esac

		COMP_L+=($"${j}$_name${end} ${v}($_drive), $comp_a${end}")
		COMP_L+=("$comp_b")
		main_msg+=($"\n${v}The $set_beta version is :${end}${ge} ${tab} - - - - - - ${end}${y}$_drive${end}")
		more_msg+=($"\n${j}$_drive${end}${vB} $in_repos.${end}${v}$set_in${end}$dl_warn")
		## define the appropriate UI.
		case $in_local_repos in
			0|1) ui_mod=1		# dl/inst selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg=$"Nothing to do." ;;
					1) if [ $un_compat_list -ge 1 ]; then
							ui_mod=2
						elif [ $in_dl_repos -eq 0 ]; then
								ui_mod=2
						fi
						if [ $in_installed -eq 1 ]&&[ ${#DOWN_list[*]} -eq 0 ]; then
							ui_mod=0; end_msg=$"Nothing to do."
						fi
					;;
				esac
			;;
			2|3) ui_mod=2		# inst local selector
				start_msg="${more_msg[@]}"
				case $_dev_comp in
					0) ui_mod=0; end_msg=$"Nothing to do." ;;
					1) if [ $in_dl_repos -gt 0 ]; then
							ui_mod=1
						fi
					;;
				esac
			;;
		esac
	done
	## this section is for lagacy driver part and has to be display only once.
	if [ $legacy_display_indicator -ge 1 ]; then
		if [ $family_compat -gt 0 ]; then
			case $family_compat in
				0) comp_c=$"${y}this driver is not supported anymore${end}"
					test $legacy_result -gt 0 && comp_d='\n'
				;;
				1) # be sure that driver is not already downloaded.
					if [ $family_last != $(new_version) ]; then
						# if exist in path, do nothing.
						if [ $(ls -1 $nvdl/ | grep -c "$family_last") = 1 ]; then
							in_repos=$"is in your repository"
							ui_mod=2
							comp_d=''
						else
							# if doesn't exist in path add it to the download list.
							in_repos=$"is not in your repository"
							DOWN_list+=("false")
							DOWN_list+=("$family_last")
							DOWN_list+=($"(last legacy)")
							comp_d=$"\n${v}Last ${y}$family_last${end} will be list.${end}"
						fi
						comp_c=$"\n${v}Devices compatibility found in ${y}$family${end} serie${end}$comp_d"
					else
						comp_c=$"\n${v}Compatible driver for ${y}$family${end} serie already installed.${end}"
						in_repos=$"is in your repository"
						ui_mod=2
					fi
					more_msg+=($"\n${j}$family_last${end}${vB} $in_repos.${end}")
					end_msg=$"What do you want to do ?"
			esac
			COMP_L+=("$comp_c")
		fi
	fi
	compat_msg=$(cat <<< ${COMP_L[*]})
	IFS=$ifs
	extra_msg="\n${more_msg[@]}\n\n${v}$end_msg${end}"
	ok_lbl=$"Select"; cancel_lbl=$"Abort"
	case $ui_mod in
		0)	zen_opts="--image=zen-warning --borders=15 --button=$cancel_lbl!zen-back:1"
			table_opts=''
			list_opts=''
			;;
		1)	zen_opts="--list --radiolist --no-headers --borders=15 --button=$cancel_lbl!zen-back:1 --button=$ok_lbl!zen-ok:0"
			table_opts='--column set --column 2 --column action --separator= --hide-column=2 --print-column=2'
			list_opts="true 1 Install false 2 Download ";;
		2)	zen_opts="--image=zen-question --borders=15 --button=$cancel_lbl!zen-back:1 --button=$ok_lbl!zen-ok:0"
			table_opts=''
			list_opts=''
			;;
	esac
	case $ui_mod in
		0|2) w_height='--height=100' ;;
		1)   w_height='--height=200' ;;
	esac
	w_text=$"$(cat <<-MSG
		${jB}${bf}Available drivers${end}${end}

		${v}Driver version installed :${end}${ge} - - - - - ${end}${j}$(drv_installed)${end}
		$(cat <<< ${main_msg[@]})

		$compat_msg
		$extra_msg
	MSG
	)"
	# we don't use yad window function for this.
	sel_cmd=$($d_yad --width=300 $w_height --window-icon=$img_zen_desktop --title="$WIN_TITLE" --center \
	$zen_opts --text="$w_text" $table_opts $list_opts || if [ $? = 252 ]; then echo 200; else echo 100; fi)
	case ${sel_cmd} in
		200) exit 1;;
		100) [ $task_opt -gt 0 ] && exit 0 || base_menu ;;
		*) case $ui_mod in
			0) [ $task_opt -gt 0 ] && exit 0 || base_menu ;; # sel_cmd echo 0, ici.
			1) case $sel_cmd in
					"1") ok_label=$"install"; from_net ;;
					"2") ok_label=$"download"; download_only ;;
				esac ;;
			2) win_update_reroute ;;
		esac ;;
	esac
}
win_update_reroute(){
	local n help_tip reroute_list ins_list menu_reroute
	reroute_list=($"Install last $LAST_UPT" $"Check again Nvidia server" $"Check for a local package")
	n=1
	for ins_cmd in "${reroute_list[@]}"; do
		ins_list+=("false")
		ins_list+=("$n")
		ins_list+=("$ins_cmd")
		n=$[ $n+1 ]
	done
	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Select an operation in the list${end}\n${end}"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_reroute=$( win_yad_list "${ins_list[*]}" "")
	case ${menu_reroute} in
		1) menu_msg=$"${vB}Direct Driver Upgrade.${end}"; LAST_PACK=$LAST_UPT; reroute=1; from_net;; #last_pack ;;
		2) menu_msg=$"${vB}NVIDIA package update from NVIDIA server.${end}"; net_version_selector ;;
		3) menu_msg=$"${vB}NVIDIA package update from local dir.${end}"; from_directory ;;
		200) base_menu ;;
		100|*) menu_update ;;
	esac
}
from_directory(){
	nv_dir(){
		local list_drv drv_pick
		cd $nvdl; n=1
		for local_drv in ${nvdl_list[@]}; do
			list_drv+=("false")
			list_drv+=("$local_drv")
		done
		l_text=$"$(
		cat <<-INFO
			${j}${bf}Install from stock${end}${end}

			Driver list in $nvdl

			$loaded
		INFO
		)"
		IFS=$(echo -en "\n\b")
# 		local drv_pick
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
		ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		drv_pick=( $( win_yad_list "${list_drv[*]}" "") )
		if [ ${#drv_pick[*]} -gt 0 ]&&[[ "$drv_pick"  =~ [a-z] ]]; then
			IFS=$ifs; eval run_pkg=$nvdl/$drv_pick
		else
			evac "$drv_pick" "menu_install" "base_menu"
		fi
	}
	home_dir(){
		local list_drv drv_pick
		for local_drv in ${home_list[@]}; do
			list_drv+=("false")
			list_drv+=("$local_drv")
			list_drv+=("$(sed -En "s|^.*\/||g;p" <<< $local_drv)")
		done
		l_text=$"$(
		cat <<-INFO
			${j}${bf}Install from user directory${end}${end}

			Select a driver from ${j}$(def_user)${end} download directory

			$loaded
		INFO
		)"
		IFS=$(echo -en "\n\b")
		cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		drv_pick=( $( win_yad_list "${list_drv[*]}" "") )
		if [ ${#drv_pick[*]} -gt 0 ]&&[[ "$drv_pick"  =~ [a-z] ]]; then
			IFS=$ifs; chmod a+x $drv_pick; eval run_pkg=$drv_pick
		else
			evac "$drv_pick" "menu_install" "base_menu"
		fi
	}
	local nvdl_list home_list list_array list_type from_cmd
	local drv_pick='' run_pkg=''

	test $(version) && loaded=$"${v}<i>${y}$(version)${end} actually installed and loaded.</i>${end}"
# 	nvdl_list=( $(ls -1 $nvdl| grep -v ".sum"| tac) )
	nvdl_list=( $(ls -1 $nvdl| grep -v ".sum"| sort -Vr) )
	home_list=( $(find $(user_DL_DIR)/ -regextype sed -regex "^.*NVIDIA-Linux-.*\.run"| sort -Vr) )
	if [ $ui_mod = 1 ]; then
# 		unset list_array
		list_array=( false 1 $"Use Zenvidia stock directory" false 2 $"Use a user local directory" )
		l_text=$"$(
		cat <<-INFO
			${j}<b>Local NVIDIA drivers STOCK</b>${end}

			Zenvidia release stock :	${j}<b>${#nvdl_list[*]}</b>${end} object(s) found.
			User home directory :		${j}<b>${#home_list[*]}</b>${end} object(s) found.

			${v}<b>Select the directory to install from.</b>${end}
		INFO
		)"

		IFS=$(echo -en "\n\b")
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
		ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='220'
		from_cmd=$( win_yad_list "${list_array[*]}" "")
		case ${from_cmd} in
			1) [ ${#nvdl_list[@]} -gt 0 ] && nv_dir ;;
			2) [ ${#home_list[@]} -gt 0 ] && home_dir ;;
			200) base_menu ;;
			100|*) [ $task_opt -gt 0 ] && exit 1 || menu_install ;;
		esac
	elif [ $ui_mod = 2 ]; then
		[ ${#nvdl_list[@]} -gt 0 ] && nv_dir
	fi
	[ ${from_cmd} -gt 0 ] && ( [ $run_pkg ] && INSTALL_DRIVER )
}
from_net(){
# download functions
		local yad_warn
		pushd $buildtmp
		# if the instruction come from win_update_reroute, do only last_pack.
		[ ${reroute} -gt 0 ] && last_pack || download_menu
		run_pkg=$nvdl/nv-update-$LAST_PACK
		if [ -f $buildtmp/$run_pack ]; then
			warn_log=$"${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
			ok_lbl=''; cancel_lbl=$"Close"'!gtk-close'
			yad_warn=$(win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "zen-emblem")
			if [ $yad_warn -ge 1 ]; then base_menu; else
				mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
				chmod 755 $nvdl/nv-update-$LAST_PACK
			fi
		fi
		popd
		if [ ${from_cmd} -gt 0 ]; then new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p"); INSTALL_DRIVER; fi \
		|| die 1 ${LINENO} "Remote package check/install failed." ""
}
download_menu(){
	local dl_cmd yad_warn
	l_text=$"$( cat <<-INFO
		${jB}${bf}Downloads${end}${end}
		Select the drivers version you wish to $ok_label.
		in the list below
	INFO
	)"
	output_type=1
	if [ ${#DOWN_list[*]} -gt 3 ]; then
		IFS=$(echo -en "\n\b")
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
		ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
		list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='300'; w_height='0'
		dl_cmd=( $( win_yad_list "${DOWN_list[*]}" "") )
		evac ${dl_cmd} "base_menu" 1
	else
		dl_cmd=${DOWN_list[1]}
		warn_log=$"$( cat <<-MSG
			${jB}${bf}Downloads${end}${end}
			NVIDIA ${y}$dl_cmd${end} driver is going to be $ok_label.

			${v}Are you sure ?${end}
		MSG
		)"
		ok_lbl=$"Ok"'!zen-ok'; cancel_lbl=$"Back to main"'!zen-back'
		yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
		if  [ ${yad_warn} = 1 ]; then base_menu; elif [ ${yad_warn} = 2 ]; then return 1; fi
	fi
	if [ "$dl_cmd" ]&&[[ "${dl_cmd}" =~ \. ]]; then
		LAST_PACK=$dl_cmd
	else
		warn_log=$"${r}Driver download failure${end}\nOutput is empty."
		die 3 ${LINENO} "$warn_log" "base_menu"
	fi
	last_pack
}
download_only(){
	cd $buildtmp
# 	pushd $buildtmp
	download_menu
	local yad_warn
	if [ -f $buildtmp/$run_pack ]; then
		warn_log=$"${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
		ok_lbl='';cancel_lbl=$"Close"'!zen-close'
		yad_warn=$( win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "zen-emblem" && return 0 )

# 		[ $rem_extract = 0 ] || test -f $buildtmp/$run_pack.sha256sum && rm -f $buildtmp/$run_pack.sha256sum
		mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
		chmod 755 $nvdl/nv-update-$LAST_PACK
		[ $task_opt -gt 0 ] && exit 0 || base_menu
	else
		warn_log=$"${v}Driver download ${j}$LAST_PACK${end} failure.\n The package ${j}$run_pack${end} doesn't exist.${end}"
		die 3 ${LINENO} "$warn_log" "base_menu"
	fi
}
last_pack(){
	track(){
		sleep 1
		while [ -d /proc/${wpid} ]; do
			file_down=$(du -h -BM $buildtmp/NVIDIA-Linux-x86_64-$LAST_PACK.run | awk '{print $1}'| grep -Eo "[0-9]+")
			echo -e $"# Downloading $file_down of $file_up $file_ex."
			echo "$(( $((100*$file_down))/$file_up ))"
			sleep 0.5
		done
		return
	}
	local drv_list=() # run_pack is not a local var

	y_text=$"${v}Remote content control...${end}"
	local pulse=1 log=0 hold=0 hide_txt=1
	win_log_options
	{ timeout=30
	{	$p_wget -q -O $nvtmp/dl_list https://$nvidia_ftp-$ARCH/$LAST_PACK/
		cat $nvtmp/dl_list | grep -E -o "href='NVIDIA.*[0-9]+.*'"| sed -En "s/^.*'(.*)'/\1/p" > $nvtmp/dl_selector
	} & eval lpid=$!; y_pulse; } | win_yad_progress

	if [ -s $nvtmp/dl_list ]; then
		## check if driver pack is really in the DL list (empty happens).
		if [ $(cat $nvtmp/dl_selector| grep -cv "[0-9]sum") -gt 0 ] ; then
			if [ $(cat $nvtmp/dl_selector | grep -c "$LAST_PACK") -gt 0 ] ; then
				RUN_PACK=$(cat $nvtmp/dl_selector| grep -v "[0-9]sum")
			fi
		else
			warn_log="${j}<b>Remote directory empty</b>${end}\n${v}Remote directory has not been update with ${LAST_PACK} data files.\nTransaction aborted.${end}"
			die 3 ${LINENO} "$warn_log" "base_menu"
		fi
		for line in $RUN_PACK; do
			drv_list+=("false")
			drv_list+=("$line")
		done
		IFS=$(echo -en "\n\b")
		l_text=$"${v}Choose the version to install${end}"
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
		ok_lbl=$"Select"'!zen-ok'; l_tail=0; w_head=0 ; col_name=''
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='500'; w_height='100'
		run_pack=( $(win_yad_list "${drv_list[*]}" "") )
		evac "$run_pack" "base_menu" 1

		## from there, look into 'selector' file for sha256sum file.
		if [ -e $nvtmp/dl_selector ]; then
			if [ $(cat $nvtmp/dl_selector| grep -c "sha256sum") -gt 0 ]; then
				run_pack_sha=$run_pack.sha256sum
			fi
		fi
		file_size=$(cat $nvtmp/dl_list | grep -A1 -E "NVIDIA-Linux-x86_64-$LAST_PACK.run" | sed -En "s/^.*>(.*)<.*$/\1/;s/^([0-9]+)([A-Z]*)$/\1;\2/p")
		test $run_pack_sha && $p_wget -c -P $buildtmp/ https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack_sha &>/dev/null
		local file_down=0 file_up=$(cut -d';' -f1 <<< $file_size) file_ex=$(cut -d';' -f2 <<< $file_size)

		y_text=$"<b>Downlaoding ${j}$LAST_PACK${end} driver from ${y}$nvidia_ftp${end}</b>"
		local pulse=0 log=0 hold=0 hide_txt=0
		win_log_options
		( $p_wget -c -P $buildtmp/ https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack & eval wpid=$!; track ;) | win_yad_progress
		if [ "$(pgrep wget)" ]; then
			kill -9 $(pgrep wget)
			die 3 ${LINENO} $"User aborted download killing wget and parent processes (if any)." "base_menu"
		fi
		# get weight of the pack in ko.
		_local=$(du -h $buildtmp/$run_pack | awk '{print $1}'| grep -o "[0-9]*")
		_remote=$(cat $nvtmp/dl_list | grep -A1 "$run_pack<"|sed -En "s/^.*>(.*)<\/.*>.*$/\1/g;2p"| grep -o "[0-9]*")
		if [ -f $buildtmp/$run_pack.sha256sum ]; then
			pushd $buildtmp &>/dev/null
			sha256sum $run_pack
			sha256sum --status -c $run_pack.sha256sum
			if [ $? = 1 ]; then
				warn_log=$"${j}<b>Download check sum error</b>${end}.\nTransaction aborted\nTry to restart driver download from <b>Update menu</b>"
				die 3 ${LINENO} "$warn_log" "base_menu"
			fi
			popd &>/dev/null
		fi
		if [ $_remote -ne $_local ]; then
			warn_log=$"${j}<b>Download unexpected end</b>${end}.\nPlease restart driver download from <b>Update menu</b>"
			die 3 ${LINENO} "$warn_log" "base_menu"
		fi
   else
		warn_log=$"$( cat <<-WRN
			${r}<b>Remote directory is empty.</b>${end}
			Nvidia devs have probably forgoten to upload data.
			Feel free to try at a later time.
		WRN
		)"
		die 3 ${LINENO} "$warn_log" "base_menu"
	fi
}
## CUDA PART
update_cuda(){
	DEV "CUDA Tools Function" "menu_update"
}
check_remote_cuda(){
	DEV "CUDA Tools Function" "menu_update"
	## Check cuda toolkit last remote version
	local BUILDS
	# cuda_version_url="https://developer.download.nvidia.com/compute/cuda/redist/index.html"
	# cuda_base_url="https://developer.download.nvidia.com/compute/cuda/"
	cuda_tmp=${zen_tmp_dir}/tmp_countuda.txt
	wget -O ${cuda_tmp} "${cuda_version_url}" 2>/dev/null

	[ ${from_install} = 0 ] && BUILDS+=("$(new_version)")
# 	[ -f $(user_CF_DIR)/cuda_version ] && BUILDS+=("$(cat $(user_CF_DIR)/cuda_version)") || BUILDS+=("$(ls -1 $(user_CF_DIR)/release/ | sed -n "s/^.*-//p" | sort -Vr)")
	# read from saved cuda version file first, if empty or not existant explore already downloaded release versions
	[ -f $(user_CF_DIR)/cuda_version ] && BUILDS=("$(cat $(user_CF_DIR)/cuda_version)") || \
	mapfile -t BUILDS < <(ls -1 $(user_CF_DIR)/release/ | sed -n "s/^.*-//p" | sort -Vr)

	local VERSION=$(sed -n "s/^.*href='redistrib_\(.*\).json'.*$/\1/p" ${cuda_tmp} | sed -n '$p')

	cuda_short_ver=$(echo "$VERSION" | sed -n "s/^\(.*\)\..*$/\1/p" )

	for B in "${BUILDS[@]}"; do
		cuda_url="${cuda_base_url}/${VERSION}/local_installers/cuda_${VERSION}_${B}_linux.run"
		if wget -q --spider --tries=1 --timeout=8 "$cuda_url" 2>/dev/null; then echo "cuda_${VERSION}_${B}_linux.run" > ${cuda_tmp}/cuda_new_version; break; fi
	done
	echo -e "cuda_${VERSION}_${B}_linux.run"
}
cuda_new_version(){
	DEV "CUDA Tools Function" "menu_update"
}
### TOOLS ###
## common windows.
## available icons.
#	zen-back			red ltr arrow		|	zen-preferences	zenvidia config		|	zen-emblem		swiss_knife
#	zen-close		dialog-close		|	zen-xorg				xorg config				|	zen-emblem-gr	swiss_knife green
# 	zen-ok			dialog-apply		|	zen-swap				driver switch			|	zen-kill			xkill
# 	zen-undo			yellow ltr arrow	|	zen-refresh			driver update			|	zen-docs			gtk-Documentation
#	zen-stop			gtk-quit				|	zen-question		nvidia docs				|	zen-restore		gtk-restore
# 	zen-warning		dialog-warning		|	zen-info				nvidia changelog		|	zen-settings	nvidia-settings
#  zen-question	dialog-question	|	zen-warning			zenvidia changelog
#	zen-error		gtk-error			|	zen-stop				menu quit
# 	zen-info			gtk-info				|	zen-color			yad color config

win_log_options(){
	x_sleep='' x_hold='' x_button=''
	if [ $hold = 1 ]&&[ $xt_hold = 1 ]; then
		esc_message=$"# ${nr}*****  Close window to escape *****${end}"
		x_hold=''
		x_button=''
		if [ ${xt_delay} -gt 0 ]; then
			esc_message=$"# ${nr}*****  Window will auto-close in ${xt_delay} seconds *****${end}"
			x_sleep="sleep ${xt_delay}"
			x_hold='--auto-close'
		fi
	else
		esc_message=''
		x_hold='--auto-close'
		x_button='--no-buttons'
	fi
}
win_yad_dev(){
	local err_image err_txt
	err_image=zen-warning
	err_txt=$(cat <<-ERR
			${jB}Developper message${end}

			${vB}" ${1} "${end}

			This function is not available yet or is under rewrite/inspection.
			It will be hopefuly available soon.
		ERR
	)
	$d_yad --width=420 --height=100 --title="$WIN_TITLE" --window-icon=$img_zen_desktop --center \
	--image=$err_image --borders=20 --text="${err_txt}" --button=$"Exit"'!zen-close:0'
}
win_yad_ret(){
	local err_image err_txt line_ex links
	links=$(cat <<-REPORT
			${ge}If you'd like, open an issue report at :
			https://github.com/wildtruc/zenvidia/issues.
			or
			https://gitlab.com/Wildtruc/zenvidia/-/issues${end}
		REPORT
	)
	if [ ${ret} -ge 2 ]; then
		[ ${ret} = 2 ] && line_ex='' links='' # just warn
		[ ${ret} = 3 ] && line_ex=" at ${vB}${line}${end}" links='' # warn with line number not links
		[ ${ret} = 4 ] && line_ex='' # warn no line but links
		err_image=zen-warning
		ret_warn_msg="Script sent warning${line_ex} with :"
		err_txt=$(cat <<-ERR
				${jB}SCRIPT WARN${end}
				${ret_warn_msg}

				${y}${2}${end}
				${links}
			ERR
		)
	else
		err_image=zen-error
		err_txt=$(cat <<-ERR
				${jB}SCRIPT FAILURE${end}

				Script code breaks at line ${vB}${1}${end} with :

				${y}${2}${end}
				${links}
			ERR
	)
	fi
	$d_yad --width=420 --height=100 --title="$WIN_TITLE" --window-icon=$img_zen_desktop --center \
	--image=$err_image --borders=20 --text="${err_txt}" --button=$"Exit"'!zen-close:0'
	return
}
win_yad_warns(){
	# warn_log ${1} : "[warn message string]"
	# qst ${2} : 1/0 < is dialog a question ?
	# ok_lbl ${3} : '[string]!icon'
	# cancel_lbl ${4} : "'[string]!icon'"
	# kill_yad ${5} : 0/1 < do we need to kill parent window ?
	# warn_image ${6} : '[image]' #> specific image
	# form :
	# $1 > "[warn message string]", $2 > "qst 0/1", $3 > ok_lbl "'[string]!icon'", $4 > cancel_lbl "'[string]!icon'", $5 > kill_yad=0/1, $6 > '[image]'
	# ex :
	# 	ok_lbl=$"Yes"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back'
	# 	win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "zen-error" #$1 $2 $3 $4 $5 $6

	local warn_image="$6"
 	eval YAD_PID=$(pgrep -n yad)
	IFS=$(echo -en "\n\b")
	if [ ${2} = 1 ]; then
		cancel_btn="--button=${4}:1"
		ok_btn="--button=${3}:0"
		[ "${6}" != '' ] || warn_image=zen-question
	else
		cancel_btn="--button=${4}:1"
		ok_btn=''
		[ "${6}" != '' ] || warn_image=zen-warning
	fi
	$d_yad --width=420 --height=100 --title="$WIN_TITLE" --window-icon=$img_zen_desktop --center \
	--image=$warn_image --borders=20 --text="${1}" $cancel_btn $ok_btn
	_exit=$?
	[ ${5} = 0 ] || if [ $YAD_PID ]&&[ $YAD_PID -gt 0 ]; then kill $YAD_PID; fi
	[ ${#parent[@]} -gt 0 ] && parent+=( $YAD_PID )
	if [ $_exit -eq 1 ]; then echo 1; elif [ $_exit -eq 252 ]; then echo 2 ; else echo 0 ; fi
}
win_yad_progress(){
	# syntax :
	# with pulse :	{ timeout=xx ;{ [script] ;}& eval lpid=$!; y_pulse; } | win_yad_progress
	# progress :	{ [script] } | win_yad_progress
	# y_text="[string]"
	# pulse=0/1		#> do pulse or not
	# log=0/1		#> display log window or not
	# hold=0/1		#> Hold window or not
	# hide_txt=0/1	#> Hide progress bar txt or not
	# extra options : hold options need other strings and depend of base script predefine option.
	# >> echo -e $esc_message" (without '' arround text var) inside script string shell '{...}'
	# ex : with hold >> pulse=1; log=1; hold=1 ; hide_txt=1
	#		 autoclose with no progress bar text	>> pulse=1; log=1; hold=0 ; hide_txt=1
	#		 autoclose with progres bar text			>> pulse=1; log=0; hold=0 ; hide_txt=0

	local height='' autoclose do_pulse nobutton log_hid='' log_en='' log_ex='' log_h=''
# 	win_log_options

	if [ $log = 1 ]; then
		log_hid='--hide-text'; log_en='--enable-log='; log_ex='--log-expanded'; log_h='--log-height=300'; height='--height=300' #; log_hold=${x_hold}
	fi
	autoclose="$x_hold"; nobutton="$x_button"
	[ $hide_txt = 1 ] && hide_txt='--hide-text' || hide_txt=''
	[ $pulse = 1 ] && do_pulse='--pulsate' || do_pulse=''

	( $d_yad --width=600 $height --window-icon=$img_zen_desktop --title="$WIN_TITLE" --center \
	--progress $do_pulse $nobutton $autoclose $hide_txt --borders=15 --text="${v}$y_text${end}" \
	${log_hid} ${log_en} ${log_ex} ${log_h} )
	_exit=$?
	if [ $_exit -eq 1 ]; then echo 1;
	elif [ $_exit -eq 252 ]; then echo 2 ;
	else echo 0; fi
	if [ $_exit -ge 1 ]; then
		if [ $(pgrep wget) ]; then exit 0 ; else exit 1; fi
	fi
	return
}
win_yad_list(){
	# exit code list:
	# 0 : true success
	# 1 : false failed
	# 2 : permission denied
	# 126 : not executable
	# 127 : wrong exec PATH
	# 130 : ctrl+c
	# 255 : general failure, but not really known.

	# 	synbtax : IFS=$(echo -en "\n\b"); win_yad_list "${[list_array][*]}"; IFS=$ifs
	# 	options :
	#	l_text="[string]"
	# 	cancel_lbl="[string]"
	# 	ok_lbl="[string]"
	#	list_type='radiolist/checklist'
	# 	columns='1/2/3/etc'
	# 	col_name=( "[string]" "[string]" "etc") 	#> may not be filled.
	# 	sep=',/;/etc'
	# 	sel_col='0/1/2/etc' 		#> wich columns in the output
	# 	hid_col='0/1/2/1,2' 		#> unvisible columns
	# 	edit_col='0/1/2/1,2' 	#> editable columns
	# 	col_tip='0/1/2/etc' 		#> wich column to be used as tool tip text, must be set in hid_col var.
	#  l_tail='0/1'				#> tail at the end of the list.
	#
	# ex : col_name=( "[string]" "[string]")
	#  cancel_lbl='Back to main!zen-back'; ok_lbl='Select!zen-ok'; l_tail=0
	# 	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='600'; w_height='420'
	# or : list_type='checklist'; columns=5; col_name=( 'Set' 'Definition' 'Conf Set' 'Extra' '5' );
	# 	sel_col='0'; sep=';' ;hid_col='3,5'; edit_col=0; col_tip=3; w_width='550'; w_height='400'; l_tail=0

	# NOTE : si la valeur rapporte 1 ou 252, la valeur défini en aval est 0.
	local tip_col='' col_list=() w_dim=() editable='' output=''
	for ((i=0; i<=$(($columns-1)); i++)) {
		if [ $w_head = 1 ]&&[ ${#col_name[*]} -gt 0 ]; then id=${col_name[$i]}; no_head=''; else id=$i; no_head='--no-headers'; fi
		[[ "$hid_col" =~ $(($i+1)) ]] && EXTRA=':HD' || EXTRA=''
		col_list+=("--column=$id$EXTRA");
	}
	[ $w_width -gt 0 ] && w_dim+=( '--width='$w_width )
	[ $w_height -gt 0 ] && w_dim+=( '--height='$w_height )
	[ "$edit_col" != 0 ] && { edit_col='--editable-cols='$edit_col; editable='--editable'; } || edit_col=''
	[ $col_tip -gt 0 ] && tip_col='--tooltip-column='$col_tip || col_tip=''
	[ $sel_col -gt 0 ] && sel_col='--print-column='$sel_col || sel_col=''
	[ $l_tail -gt 0 ] && l_tail='--tail' || l_tail=''
	[[ "$list_type" =~ "checklist" ]] && list_type=( --checklist --multiple $editable ) || list_type='--radiolist'
	buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" )
	# an additional option could be pass in $2.
	$d_yad ${w_dim[*]} --window-icon=${img_zen_desktop} --title="$WIN_TITLE" --borders=15 --center \
	--list ${list_type[*]} $no_head --separator=$sep $tip_col $sel_col $edit_col $l_tail \
	${col_list[*]} --text="$l_text" ${buttons[*]} ${1} ${2}
 	_exit=$?
 	# function will not return proper exit code in descedant operation,
 	# setting response in echo allow to inform the value of the previous exit code.
 	if [ $_exit -eq 1 ]; then echo 100; elif [ $_exit -eq 252 ]; then echo 200; fi
 	if [ $task_opt -eq 1 ]; then if [ $_exit -eq 1 ]||[ $_exit -eq 252 ]; then exit 1 ;fi; fi
}
win_yad_text(){
	## NOTE: if yad text output is send in a variable, the EXIT value stay in this variable and cant be check by next test.
	## It is needed in this case to test the content of variable output : empty/full.
	## Here 'wc' is the helper: [ $(wc -l <<< $var_output) -gt 1 ] # wc will count 1 if data doesn't come from a file.
	# 	log_brief="[output]"
	# 	syntax : win_yad_text "$log_brief" "0/1"(editable) "--image=imagename/''"
	# 	options :
	# 	log_txt="[string]"
	# 	cancel_lbl="[string]"
	# 	ok_lbl="[string]"
	# 	w_formatted=0/1	#> dispkay markup formats.
	# 	w_wrap=0/1			#> wrap text to window.
	# 	w_width='bool'		#> window width.
	# 	w_height='bool'	#> window height.
	# 	all_btn=0/1			#> display cancel button only (0) or both (1).
	#  colors=0/1			#> set foreground, background colours.
	# 	ex : w_formatted=1; w_wrap=0; _width='600'; w_height='400'; all_btn=0
	#
	#  log_txt="[string]"; cancel_lbl="Exit!gtk-close"; ok_lbl="Back!zen-undo"
	#	w_formatted=1; w_wrap=1; w_width='600'; w_height='400'; all_btn=1; colors=1
	#	win_yad_text "$log_brief"

	local w_dim buttons w_colors editable='' emb_image=''
	if [ -f "$1" ]; then
		if [ $(grep -c ".txt" <<< "${1}") -gt 0 ]; then
		input_way=$(. ${1})
		else
		input_way=$(< "${1}")
		fi
	else
		input_way=$(cat <<< "${1}")
	fi
	fore_c='#000'
	back_c='#B6AB99'
	[ $w_wrap = 1 ] && w_wrap='--wrap' || w_wrap=''
	[ $w_formatted = 1 ] && w_formatted='--formatted' || w_formatted=''
	[ $w_width -gt 0 ] && w_dim+=( '--width='$w_width )
	[ $w_height -gt 0 ] && w_dim+=( '--height='$w_height )
	[ $all_btn = 1 ] && buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" ) || buttons="--button=$cancel_lbl:1"
	[ $colors = 1 ] && w_colors=( "--fore=$fg_xterm" "--back=$bg_xterm" )
	[[ -n ${2} && ${2} -gt 0 ]] && editable='--editable'
	[[ -n ${3} && "${3}" != '' ]] && emb_image=${3}
	$d_yad ${w_dim[*]} --title="$WIN_TITLE" --window-icon=$img_zen_desktop --text="$log_txt" --borders=15 --center $editable \
	--text-info $w_formatted --margins=10 $w_wrap --hscroll-policy=never ${w_colors[*]} ${buttons[*]} $emb_image <<< "$input_way"
	_exit=$?
	if [ $_exit -eq 1 ]; then echo 1;
	elif [ $_exit -eq 252 ]; then echo 2 ;
	else [[ -n ${2} && ${2} = 0 ]] && echo 0 || return $_exit ; fi
}
win_yad_pid(){ # Depracated ?
	echo "$(pgrep -n yad)"
}
win_open_switch(){
	if [ $open_drv -gt 0 ]; then
		local list_array driver_swt drv_swt_message yad_warn
		if [[ $task_opt = 1 && -s $(user_CF_DIR)/old_basic.conf ]]; then
			## if the driver switch come from a modification of the script basic.conf
			## which do not have privileges to perform switch by itself, but prepare
			## the old_basic.conf.
			## Execute switch after test existence and content of the old_basic conf.
			. $(user_CF_DIR)/old_basic.conf
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					drv_swt_message=$"${y}<b>Open Source driver</b>${end} will apply."
				else
					drv_swt_message=$"${y}<b>Closed Source driver</b>${end} will apply."
				fi
			else
				drv_swt_message=$"${j}<b>Open Source Driver</b>${end} will be removed."
			fi
			warn_log=$"$( cat <<-SPW
				${j}${bf}Task bar Driver switch${end}${end}

				<b>Nvidia Open driver configuration sets has been change</b>.
				$drv_swt_message
				${sf}<i>(driver license $(/sbin/modinfo -F license nvidia -k $KERNEL) actualy loaded)</i>${end}

				Press button to apply.
				Confirmation window will be displayed.
			SPW
			)"
			yad_warn=$(win_yad_warns "${warn_log}" 1 $"Apply"'!zen-ok' $"Abort"'!zen-close' 0 "")
			case $yad_warn in
				0) nv_open_switch; rm -f $(user_CF_DIR)/old_basic.conf; exit 0 ;;
				1|2)
					[ $use_open = $old_use_open ] || sed -Ei "s/^use_open=.*$/use_open=$old_use_open/" $basic_conf
					rm -f $(user_CF_DIR)/old_basic.conf
					[ $task_opt -gt 0 ] && exit 0 || menu_modif
				;;
			esac

		else
			## if old_basic.conf doesn't exist and/or the commande comes from menu_modif.
			## Executte swith in a classic way.
			old_open_drv=$open_drv
			old_use_open=$use_open
			if [ $use_open -gt 0 ]; then OPEN='TRUE'; PROP='FALSE'; else OPEN='FALSE'; PROP='TRUE'; fi
			l_text=$"$( cat <<-MSG
				${v}${j}${bf}Driver switch${end}${end}

				<b>Driver type selection (open source / proprietary)</b>.

				<i>( ${y}driver with license $(/sbin/modinfo -F license nvidia -k $KERNEL) actualy loaded${end} )</i>${end}
			MSG
			)"
			list_array=( $PROP "0" $"Load proprietary drivers" $OPEN "1" $"Load Open Source Drivers" )
			cancel_lbl=$"Cancel"'!zen-back'; ok_lbl=$"Select"'!zen-ok'; l_tail=0; w_head=0 ; col_name=''
			list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='500'; w_height='0'
			IFS=$(echo -en "\n\b")
			driver_swt=( $(win_yad_list "${list_array[*]}" "") )
			if [ ${driver_swt} -ge 100 ]; then [ $task_opt -gt 0 ] && exit 0 || menu_modif; else
				use_open=$driver_swt
				if [ $use_open -ne $old_use_open ]; then
					nv_open_switch
					[ $task_opt -gt 0 ] && exit 0 || menu_modif
				fi
			fi
		fi
	fi
}

## PACKAGE MANAGING
manage_pcks(){
	hlp_tip=''
	w_text=$"$( cat <<-MSG


		${v}<u>Note</u>${end} : <i>In case of issue after restoration (ex: driver not loading),
		try command line tools in first place after reboot in case of failure.
		Many distro auto reload desktop manager at boot. If you meet this issue,
		you have to disable the desktop manager with systemcl before operating with
		"zenvidia rebuild [version]" command line</i>.
		MSG
	)"
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(cat <<-HLP

		${sf}
		- <b>Remove downloaded packages</b>:
			Manage downloaded packages in Zenvidia directory.
		- <b>Backup tools</b>:
			Make a drivers and libraries backup of the current version.
		- <b>Restore tool</b>:
			Make a restoration of previously backed up drivers installation.
		- <b>Remove Nvidia and restore to default</b>:
			Remove completly Nvidia Drivers installation and restore default Nouveau drivers.
		${end}
		HLP
		)"
	fi
	local list_array menu_packs
	l_text=$"${j}${bf}Manage drivers packages${end}${end}$w_text$hlp_tip"
	list_array=( false 1 $"Remove downloaded package" false 2 $"Backup tools" false 3 $"Restore a backup" false 4 $"Remove Nvidia and restore to default" )
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; l_tail=0; w_head=0 ; col_name=''
	hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b")
	menu_packs=$(win_yad_list "${list_array[*]}" "")
	case $menu_packs in
		1) remove_pcks ;;
		2) backup_tools ;;
		3) restore_pcks ;;
		4) remove_nvidia ;;
		200) base_menu ;;
		100|*) menu_modif ;;
	esac
}
remove_pcks(){
	# list package in release directory
	local nv_packs_list=$(ls -1 $nvdl| sort -V)
	local rm_packs packs_list yad_warn
	for pack in ${nv_packs_list[@]}; do
		packs_list+=("false")
		packs_list+=("$pack")
	done
	w_text=$"$( cat <<-MSG
		${j}<b>Remove downloaded package</b>${end}
		Select one or more packages to be removed.
	MSG
	)"
	# win_yad_list
	l_text=$w_text
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='checklist'; columns=2; sel_col=2; sep=''; l_tail=0; w_head=0 ; col_name=''
	hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	IFS=$(echo -en "\n\b")
	rm_packs=( $(win_yad_list "${packs_list[*]}" "") )
	# check that list not empty before proceed.
	if [ ${#rm_packs[*]} -gt 0 ]&&[[ "$rm_packs"  =~ [a-z] ]]; then
		warn_log=$"$( cat <<-MSG
			Selected to be removed:
			${j}${rm_packs[*]}${end} driver(s).

			Please, confirm.
		MSG
		)"
		# win_yad_warns
		ok_lbl=$"Yes"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back'
		yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "") #$1 $2 $3 $4 $5 $6
		if [ $yad_warn = 1 ]; then manage_pcks; elif [ $yad_warn = 2 ]; then base_menu; else
			for vers in ${rm_packs[@]}; do
				pack_version=$(printf "$vers"|sed -n "s/^.*-//g;p")
				if [ -d /var/lib/dkms/nvidia/$pack_version ]; then
					w_text=$"$(cat <<-INFO
						${j}<b>$pack_version still exist in DKMS tree</b>.${end}

						Remove all associated package and directory ?
						<i>(All reference in $nv_root will be also removed if found)</i>

						Please, confirm.
					INFO
					)"
					# win_yad_warns
					warn_log="$w_text"
					ok_lbl=$"Yes"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back'
					yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
					if [ $yad_warn = 1 ]; then manage_pcks; elif [ $yad_warn = 2 ]; then base_menu; else
						if [ "$pack_version" = "$(version)" ]; then
							w_text=$"$( cat <<-WRN
							<b>WARNING</b>
							The associated directory you're about to remove is the same as the actually running.

							This action will fataly break ${j}$pack_version${end} installation
							You don't want to do this.

							Action skipped.
							WRN
							)"
							# win_yad_warns
							warn_log="$w_text"
							ok_lbl='' ; cancel_lbl=$"I understand my mistake"'!zen-ok'
							yad_warn=$(win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "")
							if [ $yad_warn = 1 ]; then manage_pcks; elif [ $yad_warn = 2 ]; then base_menu; fi
						else
							test -d $nv_root/nvidia.$pack_version && rm -Rf $nv_root/nvidia.$pack_version
							rm -f $nvdl/nv-update-$pack_version
							$p_dkms remove nvidia/$pack_version --all
							test -d /var/lib/dkms/open-nvidia/$pack_version && $p_dkms remove open-nvidia/$pack_version --all
						fi
					fi
				else
					test -d $nv_root/nvidia.$pack_version && rm -Rf $nv_root/nvidia.$pack_version
					test -f $nvdl/nv-update-$pack_version && rm -f $nvdl/nv-update-$pack_version
				fi
			done
			# win_yad_warns
			warn_log=$"$( cat <<-MSG
				${v}<b>Driver(s)</b>:${end}
				${j}${rm_packs[*]}${end} package(s) removed.
			MSG
			)"
			ok_lbl='' ; cancel_lbl=$"Ok"'!zen-ok'
			yad_warn=$(win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "")
			if [ $yad_warn = 1 ]; then manage_pcks; elif [ $yad_warn = 2 ]; then base_menu; fi
		fi
	else
		if [ ${rm_packs} = 200 ]; then base_menu; else manage_pcks; fi
	fi
}
remove_baks(){
	# list package in release directory
	local rm_bak bak_list yad_warn
	for back in $(ls -1 $nv_backup_dir | sort -V); do
		bak_list+=("false")
		bak_list+=("$back")
	done
	w_text=$"$( cat <<-MSG
		${j}<b>Remove backed up package</b>${end}
		Select one or more archives to be removed.
	MSG
	)"
	# win_yad_list
	l_text=$w_text
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='checklist'; columns=2; sel_col=2; sep=''; l_tail=0; w_head=0 ; col_name=''
	hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	IFS=$(echo -en "\n\b")
	rm_bak=( $( win_yad_list "${bak_list[*]}" "") )
	if [ ${#rm_bak[*]} -gt 0 ]&&[[ "${rm_bak}" =~ [a-z] ]]; then
		warn_log=$"$( cat <<-MSG
			Selected driver(s) to be removed:
			${j}${rm_bak[*]}${end}

			Please, confirm.
		MSG
		)"
		# win_yad_warns
		ok_lbl=$"Got it"'!zen-ok' ; cancel_lbl=$"Back to menu"'!zen-back'
		yad_warn=$( win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
		if [ $yad_warn = 1 ]; then manage_pcks; elif [ $yad_warn = 2 ]; then base_menu; else
			for vers in ${rm_bak[@]}; do
				test -f $nv_backup_dir/$vers && rm -f $nv_backup_dir/$vers
			done
			warn_log=$"${vB}Driver(s) Archive(s) removed.${end}"
			qst=0; ok_lbl='' ; cancel_lbl=$"Got it"'!zen-ok' ; kill_yad=0
			manage_pcks
		fi
	else
		if [ ${rm_bak} = 200 ]; then base_menu; else manage_pcks; fi
	fi
}
remove_nvidia_cmd(){
	rm -f /etc/OpenCL/vendors/nvidia.icd
	rm -f /etc/ld.so.conf.d/nvidia-*
	test -f /etc/modprobe.d/open-NVIDIA.conf && rm -f /etc/modprobe.d/open-NVIDIA.conf
	test -f /etc/udev.d/rules.d/01-nvidia-driver.rules && rm -f /etc/udev.d/rules.d/01-nvidia-driver.rules
	rm -f /etc/modprobe.d/blacklist-nouveau.conf
	test -f /etc/modprobe.d/nvidia-drm.conf && rm -f /etc/modprobe.d/nvidia-drm.conf
	test -f /etc/modprobe.d/nvidia-blacklist.conf && rm -f /etc/modprobe.d/nvidia-blacklist.conf
	rm -f /etc/X11/xorg.conf
	rm -f /etc/X11/xorg.conf.nvidia
	rm -f /etc/systemd/system/systemd-hibernate.service.wants
	rm -f /etc/systemd/system/systemd-suspend.service.wants
	rm -f /lib/modules/$KERNEL/$(module_dest_location)/nvidia*
	rm -f /lib/firmware/nvidia/$(version)
	rm -f $nv_root/nvidia
	rm -Rf $nv_root/nvidia.$(version)
	rm -f /usr/lib/systemd/system/nvidia-*
	test -f $systemd_dir/$(dm_serv).service.bak && cp -f $systemd_dir/$(dm_serv).service.bak $systemd_dir/$(dm_serv).service
	[ -d /usr/$master$ELF_32/nvidia ]&& rm -Rf /usr/$master$ELF_32/nvidia
	[ -d /usr/$master$ELF_64/nvidia ]&& rm -Rf /usr/$master$ELF_64/nvidia
	rm -f /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so
	rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*
	rm -Rf /usr/src/nvidia-$(version)
	if [ -d /usr/src/open-nvidia-$(version) ]; then
		rm -Rf /usr/src/open-nvidia-$(version)
	fi
	rm -f $install_dir/bin/nvidia-*
	if [[ $(ls -1 $install_dir/$master$ELF_32/libnvidia-*| grep -c $(version)) -gt 0 ]]; then
		rm -f $install_dir/$master$ELF_32/libnvidia-*
		rm -f $install_dir/$master$ELF_64/libnvidia-*
	else
		rm -f $install_dir/$master$ELF_64/libnvidia-*
	fi
	rm -Rf $install_dir/share/nvidia
	rm -f /usr/share/nvidia
	rm -Rf /var/lib/dkms/nvidia
	[ -d /var/lib/dkms/open-nvidia ] && rm -Rf /var/lib/dkms/open-nvidia
	rm -Rf /var/lib/nvidia*
	rm -f $nvdir/version.txt
}
remove_nvidia(){
## clean remove of nvidia packeges and nouveau restoration.
	local yad_warn
	## display warn before process. Zenity hare.
	w_text=$"$( cat <<-MSG
		${j}<b>NVIDIA driver installation will be completaly removed.</b>${end}
		Only Nouveau driver will be usable after reboot.

		${y}Please, confirm.${end}
	MSG
	)"
	# win_yad_warns
	warn_log="$w_text"
	ok_lbl=$"Got it"'!zen-ok' ; cancel_lbl=$"Panic Button"'!zen-back'
	yad_warn=$( win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
	if [ $yad_warn = 1 ]; then manage_pcks; elif [ $yad_warn = 2 ]; then base_menu; else
		y_text=$"${j}<b>Nvidia drivers complete removal</b>${end}"
		local pulse=1 log=0 hold=0 hide_txt=0
		{ timeout=30 ;{
		## nvidia version backup.
		if [ ! -f $nv_backup_dir/nvidia.$(version).tar$zip_ex ]; then
			echo -e $"# Making security $(version) backup."; sleep 2
			y_text=$"Backup : ${j}$bak_version${end} backup archive creation"
			local pulse=1 log=0 hold=0 hide_txt=0
			win_log_options
			{ timeout=60;
			{ backup_old_version; } & eval lpid=$!; y_pulse; } | win_yad_progress
		fi
		echo -e $"# Nvidia Installation removal ..."; sleep 2
		## then remove nvidia files.
		remove_nvidia_cmd || die 1 $(LINENO) "Remove command failed." ""

		echo -e $"# Libraries registry update."; sleep 2
		## retore library path to default.
		ldconfig
		echo -e $"# Grub update."; sleep 2
		test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='rhgb quiet'
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)\"$/\1=\"$grub_orig\"/" $grub_def
		$d_grub-mkconfig -o $grub_cfg
		echo -e $"# Perform modules dependencies and initramfs update."; sleep 2
		## restore kernel sys link to default.
		m=0; do_slp=1
		progress "( exec_depmod "$KERNEL" )" $"Depmod $KERNEL modules (\$m sec.)" "$m"
		echo -e $"# Exec $KERNEL modules reload "; sleep 2
		exec_mod_load
		}& eval lpid=$!; y_pulse; } | win_yad_progress
		warn_log=$"$( cat <<-MSG
			${j}<b>NVIDIA driver installation is now completaly removed</b>${end}.

			Restart the computer for change to take effect.

		MSG
		)"
		# win_yad_warns
		ok_lbl='' ; cancel_lbl=$"Got it"'!zen-undo'
		yad_warn=$( win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "" )
		if [ $yad_warn -ge 1 ]; then base_menu; fi
	fi
}
backup_tools(){
	hlp_tip=''
	w_text=$"$( cat <<-MSG

		${v}Select the driver tool to use.${end}
	MSG
	)"
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-INFO

			${sf}
			<b>Make a backup</b> :
			- Back up the current isntalled driver installation.
			<b>Remove a backup</b> :
			- Remove archived installation driver packages.
			${end}
		INFO
		)"
	fi
	local list_array menu_backup
	l_text=$"${j}${bf}Backup manager${end}${end}$hlp_tip$w_text"
	list_array=( false 1 $"Make a backup" false 2 $"Remove a backup" )
	cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; l_tail=0; w_head=0 ; col_name=''
	hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b")
	menu_backup=$(win_yad_list "${list_array[*]}" "")
		case ${menu_backup} in
			1) backup_pcks ;;
			2) remove_baks ;;
			200) base_menu ;;
			100|*) manage_pcks ;;
		esac
}
backup_pcks(){
	local yad_warn bak_version pgrs_out
	bak_version=$(version)
	if [ -f $nv_backup_dir/nvidia.$bak_version.tar$zip_ex ]; then
		warn_log=$"$(cat <<-MSG
			${j}$bak_version${end} is already backed up.
			No reason to do it again.

			Do you want to overwrite ?
		MSG
		)"
		ok_lbl=$"Overwrite"'!zen-ok' ; cancel_lbl=$"No"'!zen-close'
		yad_warn=$( win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
		if [ $yad_warn = 1 ]; then menu_modif; elif [ $yad_warn = 2 ]; then base_menu; fi
	else
		warn_log=$"$( cat <<-WRN
			You are going to backup ${j}$bak_version${end} driver installation

			Please, confirm.
		WRN
		)"
		ok_lbl=$"Ok"'!zen-ok' ; cancel_lbl=$"Close"'!zen-close'
		yad_warn=$( win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
		if [ $yad_warn = 1 ]; then menu_modif; elif [ $yad_warn = 2 ]; then base_menu; fi
	fi
	if [ $yad_warn = 0 ]; then
		y_text=$"Backup : ${j}$bak_version${end} backup archive creation"
		local pulse=1 log=0 hold=0 hide_txt=0
		win_log_options
		pgrs_out=$( { timeout=60; { backup_old_version; } & eval lpid=$!; y_pulse; } | win_yad_progress )
		case $pgrs_out in
			0|1) manage_pcks ;;
			2) base_menu ;;
		esac
	else
		manage_pcks
	fi
}
restore_pcks(){
	alert_message(){
	# current version overwrite ALERT message
		warn_log=$"$( cat <<-WRN
			${jB}Driver install overwrite${end}

			${v}The backup you are going to restore is the same as the one used by the system.

			In previous driver version before <b>libglxserver_nvidia.so</b> usage, overwrite
			libGL.so crash the X server.
			To prevent data loss when restoring and others ugly deasagrements, Zenvidia wont
			replace the actual install by overwriting ${j}$res_version${end} over itself.

			If you really wish to overwrite, use the command line tool with desktop manager
			service disabled, closed the actual desktop session and press ctrl+alt+F[1-4].
			And type : <i>zenvidia restore [version]</i> (help will display)

			(<i>Desktop Manager, ex: systemctl disable $(dm_serv).service</i>)${end}
		WRN
		)"
		ok_lbl='' ; cancel_lbl=$"Close"'!zen-close'
		yad_warn=$( win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "" )
		if [ $yad_warn -ge 1 ]; then base_menu; fi
	}
	nv_build_options
	# list package in release directory
	from_install=0
	local drive_list drive_packs yad_warn res_version res_suffix

	[ -d $nv_backup_dir ]|| mkdir -p $nv_backup_dir
	nv_root_repo=$(ls -1 $nv_backup_dir | grep ".tar.*$"| sort -rV)
	for drive in $nv_root_repo; do
		drive_list+=("false")
		drive_list+=("$drive")
	done
	l_text=$"$( cat <<-MSG
		${j}<b>Restoration tool</b>${end}

		Driver actually loaded $(drv_installed).

		${v}Select the driver you want to restore.${end}
	MSG
	)"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	IFS=$(echo -en "\n\b")
	drive_packs=( $(win_yad_list "${drive_list[*]}" "") )
	if [[ "$drive_packs"  =~ [a-z] ]]; then
		# check that list not empty before proceed.
		if [[ $drive_packs ]]; then
			res_version=$(printf "$drive_packs"|sed -n "s/nvidia.\(.*[0-9]*\).tar.*$/\1/p")
			res_suffix=$(printf "$drive_packs"|sed -n "s/.*\.//p")
			ls /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so &>/dev/null
			if [ $? -eq 0 ]||[ ! -d $nv_root/$drive_packs ]; then
				## win_yad_warns
				warn_log=$"${v}Restoring ${j}$res_version${end} will replace actual${end} ${j}$(version)${end}."
				ok_lbl=$"Yes, restore and replace"'!zen-ok' ; cancel_lbl=$"Abort"'!zen-back'
				yad_warn=$( win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
				if [ $yad_warn -ge 1 ]; then manage_pcks; else
					## win yad options
					y_text=$"${v}Restore driver ${j}$res_version${end} and missing modules, if any.${end}"
					local pulse=1 log=0 hold=0 hide_txt=0
					win_log_options
					## win_yad_progress
					{ timeout=30 ;{
					echo -e $"# Restoring from nvidia.$res_version.tar$zip_ex..."; sleep 2
					if [ "$res_version" != "$(version)" ]; then
						## many libs are not overwriten, then remove previous before restore.
						rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$(version)
						rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$(version)
						rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$(version)
					fi
					restore_pcks_cmd
					m=1; do_slp=1
					progress "( exec_depmod "$KERNEL" )" $"(\$m sec.) - Rebuild modules dependencies (depmod)" "$m"
					## restore or rebuild drivers.
					[ $(nv_modules_presence) -gt 0 ] && /sbin/modinfo -F version nvidia -k $KERNEL | grep "$res_version" &>/dev/null
					if [ $? -eq 1 ]; then
						echo -e $"# Rebuilding missing $res_version drivers for $KERNEL kernel.."
						sleep 2
						rt_options
						if [ -d /usr/src/nvidia-$res_version ]||[ -d /usr/src/open-nvidia-$res_version ]; then
							driver_logfile=$nvlog/$(version)-$KERNEL.log
							nv_cmd_dkms_conf
							# Compil and install DKMS modules
							nv_build_dkms
							. $tmp_vars
							if [ $pass -eq 1 ]; then
								die 3 ${LINENO} $"# FAILURE : DKMS compilation ERROR !!""\n"$"# FAILURE : See 'Update drivers or modules' > 'Update driver only (dkms/force)' to force build." "manage_pcks"
							fi
						else
							die 3 ${LINENO} $"# FAILURE : No source directory found for $res_version" "manage_pcks"
						fi
						## exec_mod_load is useless here, a modprobe reload all doesn't catch change on kernel init.
						m=1; do_slp=1
						exec_initramfs $"(\$m sec.) - Rebuilding INITRAMFS" "$m"
					else
						echo -e $"# Clear : $res_version modules checked in $KERNEL kernel."
						sleep 2
						echo -e $"# Restore $res_version modules system symlinks."
						# exec_mod_load seems to work here when archive modules are already build for active kernel.
						exec_mod_load
					fi
					## validate grub
					echo $"# Create GRUB conf for nouveau driver blacklisting and other options."; sleep 2
					$d_grub-mkconfig -o $grub_cfg 2>&1 | while read -r line; do echo "# * ${line}"; done

					## remove /opt/nvidia.prev_version for compatibility restore purpose
					## old_version var is use for compatibility with clean_old_version command.
					if [ "$res_version" != "$(version)" ]; then
						## update local version text to get old version function working on restore.
						echo -e "$res_version" > $(user_CF_DIR)/version.txt
						if [ -d $nv_root/nvidia.$(old_version) ]; then
							rm -Rf $nv_root/nvidia.$(old_version)
							clean_old_version
						fi
					fi
					} & eval lpid=$!; y_pulse; } | win_yad_progress
					restart_dm_warn
				fi
			else
				# current version overwrite ALERT message
				alert_message
			fi
		else
			manage_pcks
		fi
	fi
}

## EDITION TOOLS
edit_script_conf(){
	## building list
	local conf_list orig_conf cnf_list conf_base conf_chg yad_warn
	local IFS=$(echo -en "\n\b")
	local conf_list=( $(cat $basic_conf | sed -En "s/^# (.*):.*/\1/p") )



	old_conf=$(user_CF_DIR)/old_basic.conf # << COULD COME FROM AN OTHER SESSION.
	test -s $old_conf && rm -f $old_conf

	for conf_set in "${conf_list[@]}"; do
		cnf_text="$conf_set"
		setted=$(grep -A1 "$cnf_text" $basic_conf | sed -n "\$p" )
		set_id=$(awk -F"=" '{print $1}' <<< $setted)
		set_val=$(awk -F"=" '{print $2}' <<< $setted)
		case $set_val in
			[0-9]*)
				if [ $set_val -gt 0 ]; then setted='TRUE'; else setted='FALSE'; fi
				if [ $set_val -gt 1 ]; then set_val=$set_val; else set_val='none'; fi
			;;
			[Aa-Zz]*|[\"]*)
				if [[ "$set_val" =~ \" ]]; then set_val=`sed -n "s/\"//g;p" <<< $set_val`; fi
				setted='TRUE'
			;;
		esac
		cnf_list+=("$setted")
		cnf_list+=("$cnf_text")
		cnf_list+=("$set_id")
		cnf_list+=("$set_val")
		orig_conf+=("$setted;$set_id;$set_val")
	done
	help_tip=$"${v}\nDefine options and functions you would like to use or change\n${end}"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'

	ok_lbl=$"Apply"'!zen-ok'; list_type='checklist'; sel_col='0'; sep=';'
	columns=4; l_tail=0; w_head=1 ; col_name=( 'Set' 'Definition' 'Conf Set' 'Extra' )
	hid_col='3'; edit_col=4; col_tip=3; w_width='600'; w_height='500'

	l_text=$"${j}${bf}Zenvidia Configuration${end}$help_tip${end}"
	conf_base=( $( win_yad_list "${cnf_list[*]}" "") )
	if [[ ${#conf_base[*]} -gt 0 && "$conf_base" =~ [a-z] ]]; then
		## split ouput in readable list
		## and remove blank lines.
		conf_orig=( $orig_conf )

		## some previous set have to be saved before read and change.
		old_drm_modset=$drm_modset
		old_open_drv=$open_drv
		old_use_open=$use_open
		## modify new set value.
		for output in ${conf_base[@]}; do
				set=$(echo "$output"| cut -d';' -f3)
				value=$(echo "$output"| cut -d';' -f1)
				bis_value=$(echo "$output"| cut -d';' -f4)
				a=''
				# below filter is not necesary, but add for better reading understanding.
				if [[ "$value" =~ "TRUE" ]]; then value=1; else value=0; fi
				if [[ "$bis_value" ]]; then
					if [[ "$bis_value" != 'none' ]]; then
						[[ "$bis_value" =~ [Aa-Zz] ]] && a='\"'
						value=$bis_value
					else
						# lock special value to its list.
						set_list='xt_delay|render'
						if [[ "$set" =~ $set_list ]]; then
							# preset special bis_value below.
							[ "$set" = "xt_delay" ] && { [ $value = 1 ] && value=4 ;}
						fi
					fi
				fi
				if [ $(grep -E -c "$set=[\"]?$value[\"]?" $basic_conf) -eq 0 ];then
					sed -Ei "s/^($set)=.*$/\1=${a}$value${a}/" $basic_conf
					if [[ $set == "use_open" ]]; then eval use_open=$value; fi
					eval $set=$value
				fi
		done
		## modify unset value.
		for input in ${orig_conf[@]}; do
			value=$(echo "$input"| cut -d';' -f1)
			set=$(echo "$input"| cut -d';' -f2)
			if [ $(grep -c "$value.*$set" <<< ${conf_base[@]}) -eq 0 ]; then
				if [[ ! "$value" = "FALSE" ]]; then
					bis_value=$(echo "$input"| cut -d';' -f3)
					[[ -n "$bis_value" && "$bis_value" =~ [Aa-Zz] && "$bis_value" != 'none' ]] && a='\"' || a=''
					value=0
					# add special set below.
					[ "$set" = "render" ] && value='NONE'
					if [ $(grep -E -c "$set=[\"]?$value[\"]?" $basic_conf) -eq 0 ];then
						sed -Ei "s/^($set)=.*$/\1=${a}$value${a}/" $basic_conf
						if [[ $set == "use_open" ]]; then eval use_open=$value; fi
						eval $set=$value
					fi
				fi
			fi
		done
		IFS=$ifs
	else
		if [ ${conf_base} -ge 100 ]; then
			[ $task_opt -gt 0 ] && exit 0
			if [ ${conf_base} = 200 ]; then base_menu; else menu_modif; fi
		fi
	fi
	if [[ $UID = 0 || $task_opt = 0 ]]; then
		## if drm_modset is change nivdia modprobe options has to be change accordingly.
		if [ $drm_modset -ne $old_drm_modset ]; then
			y_text=$"Reconfigure grub and/or modules options sets"
			local pulse=1 log=1 hold=0 hide_txt=1
			win_log_options
			{ timeout=30; { blacklist_and_grub_set; } & eval lpid=$!; y_pulse; } | win_yad_progress
		fi
		if [ $use_open -ne $old_use_open ]; then
			ok_lbl=$"Yes, apply"'!zen-ok'; cancel_lbl=$"No, I'll apply later"'!gtk-close'
			warn_log=$"$( cat <<-WRN
				${jB}Open Driver Switch${end}
				${v}<b>Open driver settings have been change</b>.

				Do you want to apply now ?${end}
			WRN
			)"
			yad_warn=$( win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "" )
			if [ $yad_warn = 1 ]; then menu_modif; elif [ $yad_warn = 2 ]; then exit 1; else
				## if open_drv is change, DKMS autoinstall boot time command has to be change by adding the blank file
				## 'no-autoinstall' in /etc/dkms directory. Method seems to work without issue except for package manager
				## udpate program that apprently need 'autoinstall all' to be set (fedora here).
				if [ $open_drv -ne $old_open_drv ]; then
					if [ $(dkms_version) -lt 31 ]; then
						if [ $open_drv = 1 ]; then
							touch /etc/dkms/no-autoinstall
						else
							test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall || return 0
						fi
					fi
					## if use_open is change, then apply open/close source switch.
					nv_open_switch
				fi
			fi
		fi
	else
		echo -e "old_drm_modset=$old_drm_modset" > $old_conf
		echo -e "old_open_drv=$old_open_drv" >> $old_conf
		echo -e "old_use_open=$old_use_open" >> $old_conf
		echo -e "drm_modset=$drm_modset" >> $old_conf
		echo -e "open_drv=$open_drv" >> $old_conf
		echo -e "use_open=$use_open" >> $old_conf
		if [[ $old_open_drv -ne $open_drv || $old_use_open -ne $use_open ]]; then
			ok_lbl=''; cancel_lbl=$"Got it"'!zen-ok'
			warn_log=$"$( cat <<-WRN
				${jB}Driver Switch${end}
				${v}<b>Open driver settings have been change.</b>

				${j}You don't have superuser privileges${end}.
				Please launch ${y}Open Driver switch${end} task bar menu entry to apply.${end}
			WRN
			)"
			yad_warn=$( win_yad_warns "${warn_log}" 0 "${ok_lbl}" "${cancel_lbl}" 0 "" )
			if [ $yad_warn -ge 1 ]; then [ $task_opt -gt 0 ] && exit 0 || base_menu ; fi
		else
			rm -f $old_conf
		fi
		exit 1
	fi
	## then go back to Section Menu.
	[ $task_opt -gt 0 ] && exit 0 || menu_modif
}
edit_color_conf(){
	## color tmep file test preview and vars reset
	local TMP_conf input_colors output_colors font_button output_conf
	local TMP_gui=$(mktemp $zen_tmp_dir/nv_color_set.XXXX)
	if [ -s $zen_tmp_dir/nv_color_tmp.* ]; then
		local TMP_conf=$zen_tmp_dir/nv_color_tmp.*
	else
		local TMP_conf=$(mktemp $zen_tmp_dir/nv_color_tmp.XXXX); cat $color_conf > $TMP_conf
		chmod 644 $TMP_conf
	fi
	yad_gui(){
		$d_yad --width=620 --height=600 --title "$WIN_TITLE" --center \
			--scroll --vscroll-policy=auto --hscroll_policy=none \
			--window-icon=$img_zen_desktop --text "$w_text" \
			--form --separator="|" --item-separator=";" --borders=15 --field="":LBL '' \
			--field=$" Title and warning messages font color":CLR "$title" \
			--field=$" Sub window title font color":CLR "$sub" \
			--field=$" Comment font color\t\t":CLR "$main" \
			--field=$" Sub comment font color\t\t":CLR "$log_msg" \
			--field=$" Log clear font color\t\t":CLR "$log_grn" \
			--field=$" Log warning font color\t\t":CLR "$log_warn" \
			--field=$" Log error font color\t\t":CLR "$log_err" \
			--field=$" Sub Titles font type":FN "$font1 $style1 $size1" \
			--field=$" Normal font type":FN "$font0 $style0 $size0" \
			--field="":LBL '' \
			--field=$" Xterm and log forground color":CLR "$fg_xterm" \
			--field=$" Xterm and log background color":CLR "$bg_xterm" \
			--field="":LBL '' \
			--field="$w_tip":LBL '' \
			--field="":LBL '' \
			--field="$test_text":LBL '' \
			--button=$"Preview"';zen-refresh;'$"Reload with newly setted values"':2' \
			--button=$"Abort"';zen-close:1' --button=$"Done"';zen-ok:0' > $TMP_gui
			_exit=$?
			if [ $_exit = 2 ]; then echo 2
			elif [ $_exit = 1 ]; then echo 100
			elif [ $_exit = 252 ]; then echo 200
			else echo 0; fi
	}
	edit_color_text(){
		test_text=$"$(
		cat <<-SPL
			DISPLAY PREVIEW :
			${rBB}TITLE${end}
			${j}${bf}Sub TITLE${end}${end}
			TEXT, comment and sub comment :
			Main is desktop default text color
			${v}Once upon a time in south west ? I don't care !${end}.
			${y}But I can alternate between East and West,
			but I still don't care ...${end}
			LOGS :
			${vB}Command cleared${end}		${gB}passed${end}		> ${y}log message values.${end}
			${vB}Command issue warning${end}	${jB}warning${end}	> ${y}log message values.${end}
			${vB}Command non fatal error${end} ${rB}error${end}		> ${y}log message values.${end}
		SPL
		)"
		w_text=$"$(
		cat <<-TXT
			${j}${bf}Basic font colors and style${end}${end}
			${v}Change GUI font colors to fit your desktop theme.${end}
		TXT
		)"
		sample=$"$(
		cat <<-SPL
			${rBB}TITLE${end}\t${j}${bf}Sub TITLE${end}${end}
			${v}main text${end} ${y}Log messages${end}
			${gB}Log cleared${end} ${jB}Log warnings${end} ${rB}Log Errors${end}
		SPL
		)"
		w_tip=$"$(
		cat <<-TIP
			${j}* NOTICE *${end}
			${sf}Colors will apply immediatly after validation.
			Do not forget Xterm only support a limited type of colors.
			${y}Xterm colors are also applied to Yad's text windows.${end}${end}
		TIP
		)"
		style1=$(grep -E -io "[a-z]*$" <<< $font1)
		style0=$(grep -E -io "[a-z]*$" <<< $font0)
	}
	color_config(){
		IFS=$(echo -en "\n\b")
		input_colors=$(cat $TMP_conf | cut -d'=' -f1)
		output_colors=( $(cat $TMP_gui| sed -En "s/^\||[\|]{3}$//g;s/\|/\n/g;p") )
		C=0
		for type in ${input_colors[@]}; do
			if [[ $type =~ font* ]]; then
				font_n=$(echo "$type"| grep -o "[0-9]")
				eval style=\$'style'$font_n
				new_font=$(echo "${output_colors[$C]}"|grep -E -io ".*[a-z]")
				new_style=$(echo "$new_font"|awk '{print $3}')
				if [[ $new_style == '' ]]; then stylish=' '$style; else stylish=''; fi
				output_conf+=("$type;$new_font$stylish")
				shift 0
			elif [[ $type =~ size* ]]; then
				output_conf+=("$type;$(echo "${output_colors[$C]}"|grep -E -o "[0-9].*$")")
				C=$((C+1))
			else
				output_conf+=("$type;${output_colors[$C]}")
				C=$((C+1))
			fi
		done
		for sets in ${output_conf[@]}; do
			setting=$(printf "$sets"| cut -d';' -f1)
			value=$(printf "$sets"| cut -d';' -f2)
			if [ $(grep -c "$setting='$value'" $TMP_conf) -eq 0 ]; then
				sed -Ei "s/^($setting)=.*$/\1='$value'/g" $TMP_conf
			fi
		done
		IFS=$ifs
	}
		edit_color_text
		font_button=$(yad_gui)
		case $font_button in
			0) color_config; mv -f $TMP_conf $color_conf; chown $(def_user):$(def_user) $color_conf; zen_colors; menu_modif ;;
			2) color_config; . $TMP_conf; zen_colors; edit_color_conf ;;
			100) menu_modif ;;
			200) base_menu ;;
		esac
}
## This section is dedicated to Xorg config edition.
# Here the full xorg editor GUI with specific functions.
x_check_nv_doc(){
	brief=$(cat $nv_doc | sed -n "/<${1}>/,/<\/${1}>/{;s/<[^>]*>//g;p}"| sed -r '/^\s*$/d')
	if [ $(echo -e "${brief}"| wc -w) -gt 4 ]; then
		cat <<-TIP
		<b>NVIDIA TIP</b> :
		${y}<small>${brief}</small>${end}
		TIP
	fi
}
x_check_man(){
	brief=$(cat $x_doc | sed -n "/<DEV:${1}>/,/<\/DEV:${1}>/{;/<${2}>/,/<\/${2}>/{;s/<[^>]*>//g;p}}"| sed -r '/^\s*$/d'|sort -u)
	if [ $(echo -e "${brief}"| wc -w) -gt 4 ]; then
		cat <<-TIP
		<b>$DEV TIP</b> :
		${y}<small>${brief}</small>${end}
		TIP
	else
		echo -e $"${r}<small>$DEV TIP not found, undocumented or obsolete option.</small>${end}"
	fi
}
x_yad_extract(){
 	local DEVICE device_D section_D DEVICE_section_orig=() DEVICE_section_file #device_section_list
	local xorg_cfg_mod=$xorg_cfg
 	local INPUT_options I_option_def I_setted I_option_type I_option I_value \
 	OUTPUT_line O_option_type O_option O_value O_option_line_ log_on log_prefix prefix

	cp -f $xorg_cfg $xorg_cfg~
	[ -f $xorg_conf_log ] || touch $xorg_conf_log && echo '' > $xorg_conf_log
	echo -e "+++ ${red}${DEVICE_section_list[@]}${nc} +++"

	for DEVICE in "${DEVICE_section_list[@]}"; do # retourne la liste : Xorg|ServerLayout Device0|Device Device0|Screen
	device_D=$(cut -d'|' -f1 <<< $DEVICE)
	section_D=$(cut -d'|' -f2 <<< $DEVICE)
	## ne retourne que la device et section dédié ex : Xorg|ServerLayout Device0|Device Device0|Screen
	## Device0|Device;TRUE|Option|AllowIndirectGLXProtocol|true
	## Device0|Device;FALSE|Option|AllowGLXWithComposite|true
	## Device0|Device;TRUE|Option|TripleBuffer|true
 	DEVICE_section_orig=( $(grep "$DEVICE" $tmp_orig) ) # ex : Xorg|ServerLayout Device0|Device Device0|Screen
 	DEVICE_section_file=$xorg_tmp_dir/$device_D.$section_D.* # ex de sortie crée par TAB et capturée : Device0.Device.2.xxxx

		for PREV in ${DEVICE_section_orig[@]}; do
			## vars in device_section_orig line are always TRUE (despite the values true/false)
			device=$device_D
			section=$section_D
			## check per one line in orig config file
			## orig line ex : Device0|Device;TRUE|Option|TripleBuffer|true
			INPUT_options=$(cut -d';' -f2 <<< $PREV) # ex : TRUE|Option|TripleBuffer|true
			I_option_def=$(awk -F '|' '{print $2"|"$3}' <<< $INPUT_options) # ex : Option|TripleBuffer
			I_setted=$(cut -d'|' -f1 <<< $INPUT_options) # ex : TRUE
			I_option_type=$(cut -d'|' -f2 <<< $INPUT_options) # ex : Option
			I_option=$(cut -d'|' -f3 <<< $INPUT_options) # ex : TripleBuffer
			I_value=$(cut -d'|' -f4 <<< $INPUT_options) # ex : true

			# define if value exist and is quoted. Then set quote if needed.
			[ "$I_value" != '' ] && a='"' || a=''
			if	[[ "$I_value" =~ [0-9]{2}$|[0-9]\ [0-9]$ ]]&&[ "$I_option" != "DPI" ]; then
				a=''
			fi
			# quotes for log only
			[[ "$I_option_type" =~ Option|Screen|Inactive ]] && b='"' || b=''
			case $I_setted in
				TRUE) prefix='' ;;
				FALSE) prefix='#' ;;
			esac
			case "$I_value" in
				true|false) echo -e "${red}1 A true/false${nc}";;
				on|off) echo -e "${red}1 B on/off${nc}";;
				[0-9]*x[0-9]*) echo -e "${red} NUM DISPLAY de XXX à XXXX${nc}" ;;
				[0-9]*\ x\ [0-9]*) echo -e "${red} NUM+ -DPI A x A${nc}" ;;
				[0-9]\ [0-9]) echo -e "${red} NUM 1 + 1 - UNQUOTE VALUE${nc}" ;;
				[0-9]) echo -e "${red} NUM une unitées. 1${nc}" ;;
				[0-9]*) echo -e "${red} NUM deux unitées et plus. 2+${nc}" ;;
				[A-Z]*) echo -e "${red} ALPHA MAJ+${nc}" ;;
				[a-z]*) echo -e "${red} ALPHA MINUS+${nc}" ;;
				'') echo -e "${red}8 RIEN${nc}" ;;
			esac
			if [ $(grep -c "$I_option_def" $DEVICE_section_file) -gt 0 ]; then
				## TRUE : unchanged or set
				## inspect values in device_section_file except TRUE/FALSE, if in file, line obviously TRUE.
				OUTPUT_line=$(grep "$I_option_def" $DEVICE_section_file)
				O_option_type=$(cut -d'|' -f2 <<< $OUTPUT_line)
				O_option=$(cut -d'|' -f3 <<< $OUTPUT_line)
				O_value=$(cut -d'|' -f4 <<< $OUTPUT_line)
				case $I_setted in
					TRUE) log_prefix='ALREADY TRUE'
						if [[ -n $I_value && "$O_value" != "$I_value" ]]; then
							log_on='MODIFIED'
							O_write=1
						else
							## unchanged > log
							log_on='UNCHANGED'
							O_write=0
						fi
					;;
					FALSE) log_prefix='FALSE TO TRUE'
 						## changed > write
						log_on='SWITCH'
						O_write=1
					;;
				esac
				if [ ${O_write} = 1 ]; then
					## changed > write
					case $O_option_type in
						Option|Screen|Inactive) O_option_line="   $O_option_type\t\"$O_option\" ${a}$O_value${a}" ;; # 3 arguments.
						*) O_option_line="   $O_option\t${a}$O_value${a}" ;; # 2 arguments.
					esac
					sed -Ei "s|^[#]?.*${I_option_type}.*${b}${I_option}${b}.*$|${O_option_line}|" $xorg_cfg_mod
				fi
				log_option_line="-> $I_option_type ${b}$I_option${b} ${a}$O_value${a}"
				echo -e "$log_prefix $device $section :\t$log_option_line -> ($log_on)" >> $xorg_conf_log
			else
				## FALSE : Unchanged or set
				case $I_setted in
					FALSE) # already FALSE, log only
					log_prefix='ALREADY FALSE'
					;;
					TRUE) # set to FALSE, write # at the beginning of the O_option_line.
						log_prefix='TRUE TO FALSE'
						case $I_option_type in
							Option|Screen|Inactive) O_option_line="#   $I_option_type\t${b}$I_option${b} ${a}$I_value${a}" ;;
							*) O_option_line="#   $I_option\t${a}$I_value${a}";;
						esac
						sed -Ei "s|^.*${I_option_type}.*${b}${I_option}${b}.*$|${O_option_line}|" $xorg_cfg_mod
					;;
				esac
				log_option_line="-> $I_option_type ${b}$I_option${b} ${a}$I_value${a}"
				echo -e "$log_prefix $device $section :\t$log_option_line" >> $xorg_conf_log # we don't write, log only.
			fi
		done
	done
}
x_yad_tab(){
# 	local section_list=() options_list=()
# 	local section section_names track section_block \
# 	vendor_id section_line option_line option_type option_reg screen_reg option_bis_reg \
# 	option value option_line section_line o_tip
		local section section_names track section_block \
		vendor_id section_line option_line option_type option_reg screen_reg option_bis_reg \
		option value option_line section_line o_tip

	## tab window
	for para in ${device_options[@]}; do
 		local section_list=() options_list=()

		section=$(cut -d';' -f1 <<< $para)
		section_names=$(cut -d';' -f2 <<< $para)
		track=$(cut -d';' -f3 <<< $para)
		if [ $(grep -c "$section" $xorg_cfg) -gt 0 ]; then
		# create and trap tmp files.
		tab_tmp=$(mktemp $xorg_tmp_dir/$device.$section.$n.XXXX)
			# catch Xorg Section containing 'word' or without.
			if [ $track -gt 0 ]; then
				section_block=$(sed -n -e '/Section "'$section'"/,/EndSection/{H;$!d;}' \
				-e 'x;/Identifier.*Device'$e'/!d;/Section/,/EndSection/p' $xorg_cfg)
			else
				section_block=$(sed -En '/Section "'$section'"/,/EndSection/p' $xorg_cfg)
			fi
			section_list=( $(tr ',' '\n' <<< $section_names) )
			## catch array vnd_id variable
			vendor_id=${4}
			for section_line in ${section_list[@]}; do
				if [ $(grep -wc "$section_line" <<< $section_block) -gt 0 ]; then
					#unset option_line # options_list
					option_line=( $(grep -w "$section_line" <<< $section_block) )
					for line in ${option_line[@]}; do
						if [[ $line =~ \#{1}.*$ ]]; then setted='FALSE'; else setted='TRUE'; fi
						option_type=$section_line
						option_reg="^.*$section_line.*(\".*\") (\".*\")$"
						screen_reg="^.*$section_line [0-9].*(\".*\") (.*)$"
						option_bis_reg="^.*$section_line.*(\".*\")$"

						if [[ "$line" =~ $option_reg ]]; then
							option=$(echo "$line"| sed -En "s/$option_reg/\1/p"|sed -n "s/\"//g;p")
							value=$(echo "$line"| sed -En "s/$option_reg/\2/p"|sed -n "s/\"//g;p")
						else
							if [[ "$line" =~ $screen_reg ]]; then
								option_type=$(echo "$line"| sed -En "s/^.*(Screen [0-9]).*$/\1/p")
								option=$(echo "$line"| sed -En "s/$screen_reg/\1/p"|sed -n "s/\"//g;p")
								value=$(echo "$line"| sed -En "s/$screen_reg/\2/p"|sed -n "s/\"//g;p")
							elif [[ "$line" =~ $option_bis_reg ]]; then
								option=$(echo "$line"| sed -En "s/$option_bis_reg/\1/p"|sed -n "s/\"//g;p")
								value=''
							else
								option_type=''
								option=$section_line
								value=$(echo "$line"| awk '{print $2}'|sed -n "s/\"//g;p")
							fi
						fi
						options_list+=("$setted")
						options_list+=("$option_type")
						options_list+=("$option")
						options_list+=("$value")
						## define tips per object.
						if [[ "10de|layout" =~ "${4}" ]]; then
							DEV='NVIDIA '$section
							o_tip=$(x_check_nv_doc "$option")
							if [ $(echo $o_tip | wc -w) -le 4 ]; then
								o_tip=$"$(
									cat <<-TIP
										${r}<small>$DEV TIP not found, undocumented or obsolete option.</small>${end}
									TIP
								)"
								if [[ "${4}" =~ "layout" ]]; then
									DEV='XORG '$section
									o_tip=$(x_check_man "xorg.conf" "$option")
								fi
								if [[ "$section" =~ "Screen" ]]; then
									DEV='NVIDIA '$section
									o_tip=$(x_check_man "xorg.conf" "$option")
								fi
							fi
						fi
						if [[ "8086|1002|1022" =~ "${4}" ]]; then
							if [ $opti_preset = 1 ]; then
								if [[ "8086|1002|1022" =~ "${4}" ]]; then
									DEV='OPTIMUS '$section
									o_tip=$(x_check_man "modesetting" "$option")
								fi
							else
								if [[ "${4}" =~ "8086" ]]; then
									DEV='INTEL '$section
									o_tip=$(x_check_man "intel" "$option")
								elif [[ "1002|1022" =~ "${4}" ]]; then
									DEV='AMD '$section
									o_tip=$(x_check_man "amdgpu" "$option")
								fi
							fi
							if [ $(wc -l <<< $o_tip) -le 1 ]; then
								if [[ "$section" =~ "Screen" ]]; then
									DEV='NVIDIA '$section
									o_tip=$(x_check_man "xorg.conf" "$option")
								fi
							fi
						fi
						options_list+=("$o_tip")
						echo -e "$device|$section;$setted|$option_type|$option|$value" >> $tmp_orig
						[[ "${DEVICE_section_list[*]}" =~ "$device|$section" ]] || DEVICE_section_list+=("$device|$section")
					done
				fi
			done
			if [ ${#options_list[*]} -gt 0 ]; then
				t=$n
				tab_text=$"<b>${3} :</b> ${c}${2}${end} - Section \"$section\""
				tab_names+=(--tab="${sf}${c}$(echo -e "${2}\n$section")${end}${end}")
				## create tab.
				$d_yad --plug=${1} --tabnum="$t" --list --checklist --editable --editable-cols=4 --text="$tab_text" \
				--column=1 --column=2 --column=3 --column=4 --column=5 --no-headers \
				--tooltip-column=5 --hide-column=5 "${options_list[@]}" > $tab_tmp &
				n=$(($n+1))
			fi
		fi
	done
}
x_yad_block(){
	xorg_cfg=/etc/X11/xorg.conf.nvidia ### DEV to remove
	local tab_names KEY n device_options options_orig device mn_cmd DEVICE_section_list
	local xorg_tmp_dir server_sections device_sections xorg_conf_log=$(user_CF_DIR)/xorg_cfg.log
	nv_doc=$zen_docs/nv-tips
	x_doc=$zen_docs/x-tips

	## create a temp dir to remove at the end of the porcess.
	xorg_tmp_dir=$(mktemp -d $zen_tmp_dir/xorg.conf.XXXX)
	## main window
	server_sections="ServerLayout;Screen,Inactive,Option;0|Files;ModulePath;0|InputDevice;Option;0"
	device_sections="Device;Option;1|Screen;Option,DefaultDepth;1"
	IFS=$(echo -en "\n\b")
	w_text=$"$( cat <<-DEVICE
		${j}${bf}Graphic Display Configuration${end}${end}
		<i>From Xorg configuration file ($xorg_cfg)</i>
		${sf}
		<b>Full documentation can be found in</b> :
		> ${j}Help and Documentation${end} > ${j}Documentation Manual${end} - Appendice B. <i>X Config Options</i>
		${end}
		Device(s) detected :
		${y}${dev_name[*]}${end}
	DEVICE
	)"
	unset tab_names
	KEY=$RANDOM
	n=1
	device_options=($(tr '|' '\n' <<< $server_sections ))
	## xorg server part analyse.
	# create and trap temp file.
	tmp_orig=$(mktemp $xorg_tmp_dir/xorgconf.orig.XXXX)
	tmp_next=$(mktemp $xorg_tmp_dir/xorgconf.next.XXXX)
	c='<span color="#16BBC1">' # BLUE
	device='Xorg'
	x_yad_tab "$KEY" "Xorg" $"Xorg Server" "layout"
	device_options=($(tr '|' '\n' <<< $device_sections ))
	## device part analyses.
	for e in ${dev_n[@]}; do
		[ $e = 0 ] && c=${j} # YELLOW #FF9800
		[ $e = 1 ] && c=${v} # LIGHTGREEN #2CA900
		[ $e = 2 ] && c=${y} # LIGHTBLUE
		device='Device'$e
		x_yad_tab "$KEY" "${dev_name[$e]}" "${vnd[$e]}" "${vnd_id[$e]}"
		echo -en "*** ${grn}${tab_names[*]}${nc} ***"
	done
	cancel_lbl=$"Cancel"'!zen-close' ; ok_lbl=$"Ok"'!zen-ok'
	buttons=( "--button=$cancel_lbl:1" "--button=$ok_lbl:0" )
	{ mn_cmd=$( $d_yad --key=$KEY --notebook --tab-pos=top --width=550 --height=400 --title="$WIN_TITLE" --window-icon=$img_zen_desktop \
	"${tab_names[@]}" --center --borders=15 --text="$w_text" ${buttons[*]} \
	|| if [ $? = 252 ]; then echo 200; else echo 100; fi && return ); }
	case $mn_cmd in
		200) [ $task_opt -gt 0 ] && exit 0 || base_menu ;;
		100) [ $task_opt -gt 0 ] && exit 0 || edit_xorg_conf ;;
		0|*) x_yad_extract; [ $from_install = 0 ] && edit_xorg_conf ;;
	esac
}
# Here simple xorg editor and menu.
edit_xorg_full_text(){
	local edit_xorg
	IFS=$(echo -en "\n\b")
	log_txt="${j}Edit Xorg config file${end}\nThe <b>Save</b> button will overwrite the existing file."
	log_brief=$xorg_cfg
	## count number of caracter before edit
	cara_count=$(wc -c $log_brief| awk '{print $1}')
	cancel_lbl="Exit!zen-back"; ok_lbl="Save!zen-ok"
	w_formatted=1; w_wrap=1; w_width='620'; w_height='400'; all_btn=1; colors=1
	edit_xorg=$(win_yad_text "$log_brief" 1 "")
	case "$edit_xorg" in
		*[a-z]*)
			if [ $(wc -c <<< $edit_xorg| awk '{print $1}') -ne ${cara_count} ]; then
				echo -e "$edit_xorg" > $xorg_cfg
			else
				die 3 $"Xorg config file do not differ from previous. Abort" "base_menu"
			fi
			menu_modif
		;;
		1|2) [ $task_opt -gt 0 ] && exit 0 || base_menu; ;;
	esac
}
edit_xorg_conf(){
	## check and alerte of xorg.conf presence.
	if [ ! -e /etc/X11/xorg.conf ]; then
		warn_log=$"$(cat <<-WARN
			${j}<b>Xorg config file missing</b>${end}

			No xorg configuration file found.
			There is nothing to edit.
			WARN
		)"
		die 3 ${LINENO} "$warn_log" "base_menu"
	fi
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP
		${sf}
		- <b>Edit full Xorg (GUI)</b>
			Edit all non sensitives Xorg option and sets in tabed GUI.
		- <b>Edit full Xorg (text)</b>
			Edit Xorg configuration file in a text editor.
		- <b>Execute Xorg auto config</b>
			Re-create Zenvidia Xorg configuration file creation automation.
		${end}

		HLP
		)"
	else
		hlp_tip=''
	fi
	local menu_xorg list_array
	xorg_cfg=/etc/X11/xorg.conf.nvidia

	list_array=( TRUE 1 $"Edit full Xorg (GUI)" FALSE 2 $"Edit full Xorg (text)" FALSE 3 $"Execute Xorg auto config" )
	l_text=$"${j}${bf}Edit Xorg Config File${end}${end}\n${v}Edit or manage Xorg config and options.${end}\n$hlp_tip"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'
	ok_lbl=$"Select"'!zen-ok'; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='450'; w_height='0'
	IFS=$(echo -en "\n\b")
	menu_xorg=$(win_yad_list "${list_array[*]}" "")
		case $menu_xorg in
			1) x_yad_block ;;
			2) edit_xorg_full_text;;
			3) xorg_conf; xorg_check; edit_xorg_conf ;;
			200) [ $task_opt -gt 0 ] && exit 0 || base_menu ;;
			100|*) [ $task_opt -gt 0 ] && exit 0 || menu_modif ;;
		esac
}
edit_distro_conf(){
	## warn about no config file
	warn_log=$"$(cat <<-WRN
	${j}<b>You are going to modify $(distro_version) configuration file</b>${end}

	Variables and datas from this file are very sensitives and could potentialy
	breaks Zenvidia.

	${r}<i>Are you sure about what you are doing ?</i>${end}

	WRN
	)"
	# warn
	local yad_warn edit_plug_conf cara_count
	ok_lbl=$"I live dangerously"'!zen-ok' ; cancel_lbl=$"Well, I'm finally a coward"'!zen-back'
	yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
	if [ $yad_warn = 1 ]; then menu_modif; elif [ $yad_warn = 2 ]; then base_menu; fi
	## edit config file.
	log_brief="$(user_CF_DIR)/distro.conf"
	## count number of caracter before edit
	cara_count=$(wc -c $log_brief| awk '{print $1}')
	# set text IFS
	IFS=$(echo -en "\n\b")
	log_txt=$"${j}<b>$(distro_version) configuration file</b>${end}"
	cancel_lbl=$"Abort (panic button)"'!zen-back'; ok_lbl=$"Write"'!zen-ok'
	w_formatted=1; w_wrap=1; w_width='800'; w_height='400'; all_btn=1; colors=0
	edit_plug_conf=$(win_yad_text "$log_brief" 1 "")
	case "$edit_plug_conf" in
		*[a-z]*)
			if [ $(wc -c <<< $edit_plug_conf| awk '{print $1}') -ne ${cara_count} ]; then
				echo -e "$edit_plug_conf" > $(user_CF_DIR)/distro.conf
			else
				die 3 $"Distribution config file do not differ from previous. Abort" "base_menu"
			fi
			menu_modif
		;;
		1|2) [ $task_opt -gt 0 ] && exit 0 || base_menu; ;;
	esac
}
read_help(){
	local read_view
	IFS=$(echo -en "\n\b")
	log_brief="$zen_docs/HELP.txt"
	log_txt=$"${j}<b>Zenvidia help and documentation</b>${end}"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=''
	w_formatted=1; w_wrap=1; w_width='780'; w_height='400'; all_btn=0; colors=1
	read_view=$(win_yad_text "$log_brief" 0 "")
	if [ ${read_view} -ge 1 ]; then ( [ $task_opt -gt 0 ] && exit 0 || base_menu; ); else menu_manage; fi

}
read_about(){
	log_txt=$"$(cat <<-ABOUT
		${v}${j}${bf}About Zenvidia${end}${end}
		Version :	${y}$(cat $nvdir/zen_version)${end}
		License :	${y}LGPLv3${end}
		Author :	${y}@PirateProd - 2020-2023${end}
		website :	${y}$zenvidia_git${end}
		contact :	${y}wildtruc@noneltd.net${end}
		${end}
	ABOUT
	)"
	local read_view
	IFS=$(echo -en "\n\b")
	log_brief="$zen_docs/ABOUT.txt"
	log_txt="$log_txt"
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'; ok_lbl=''
	w_formatted=1; w_wrap=1; w_width='700'; w_height='400'; all_btn=0; colors=1
	read_view=$(win_yad_text "$log_brief" 0 "--image=zen-emblem")
	if [ ${read_view} -ge 1 ]; then ( [ $task_opt -gt 0 ] && exit 0 || base_menu; ); else menu_manage; fi
}
read_nv_help(){
	local index read_view chapter_index chapters_list help_tip=''
	IFS=$(echo -en "\n\b")
		chapters_list=$(sed -En "/TABLE OF.*$/,/1A. ABOUT.*$/{/^___.*$/,/^___.*$/p}" $nvi_docs/README.txt | grep -E "^Chapter|^Appendix")
		for chapter in ${chapters_list[@]}; do
			chapter_index+=("FALSE")
			chapter_index+=("$chapter")
		done
	## display index first
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to main"'!zen-back'
	ok_lbl=$"Select"!'zen-ok'; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; w_width='750'; w_height='420'
	l_text=$"${j}${bf}Nvidia Documentation ${end}$help_tip${end}"
	index=( $( win_yad_list "${chapter_index[*]}" "") )
	case "$index" in
		*[a-z]*)
			chap_title=$(echo "$index"| sed -n "s/(.*)//g;p")
			chap_start=$(printf "$index"| sed -n "s/\(.*\)\..*$/\1/p")
			chap_end=$(sed -n "/$chap_start/{n;s/\(.*\)\..*$/\1/p}" <<< "$chapters_list")
			if [ "$chap_end" != '' ]; then
				chap_brief="$chap_title : "$(sed -En "/^$chap_start.*$/,/^$chap_end/{/^____.*$/,/^____/p}" $nvi_docs/README.txt )
			else
				chap_end=$(grep -nF "${chap_start}"  $nvi_docs/README.txt | tail -n1 | cut -d: -f1)
				chap_brief="$chap_title : "$(awk "NR>=${chap_end}{print}" $nvi_docs/README.txt)
			fi
			log_txt=$"${j}Nvidia $(version) Documentation - ${y}$chap_title${end}${end}"
			[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'
			ok_lbl=$"Back to index"'!zen-undo'
			w_formatted=0; w_wrap=1; w_width='750'; w_height='400'; all_btn=1; colors=1
			read_view=$(win_yad_text "$chap_brief" 0 "")
			case "$read_view" in
				0) read_nv_help ;;
				1) [ $task_opt -gt 0 ] && exit 0 || menu_manage; ;;
				2) [ $task_opt -gt 0 ] && exit 0 || base_menu; ;;
			esac
		;;
		100) [ $task_opt -gt 0 ] && exit 0 || menu_manage; ;;
		200) [ $task_opt -gt 0 ] && exit 0 || base_menu; ;;
	esac
}
read_changelog(){
	local entry_list entry_catch
	# define entry null data.
	local relist_title='' catch_title='' log_list='' txt_val=0 entrylog_list=() log_brief='' entrylog=()
	IFS=$(echo -en "\n\b")
	brief(){
		local read_view
		if [ $(echo -e "$log_brief"| grep -c . 2>/dev/null"") -gt 0 ]; then
			log_brief=$( cat <<-BRIEF
			$log_brief
			BRIEF
			)
		else
			log_brief=$(echo -e $"\n\nNothing to display here.\n\nLog file empty.")
		fi
		log_txt=$"${bf}${j}Changelog : ${y}$entrylog${end}${end}${end}"
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
		ok_lbl=$"Back to index"'!zen-undo'
		w_formatted=0; w_wrap=1; w_width='750'; w_height='400'; all_btn=1; colors=1
		read_view=$(win_yad_text "$log_brief" 0 "")
		if [ $read_view -ge 1 ]; then [ $task_opt -gt 0 ] && exit 1; menu_manage; else
			if [[ $relist_title != '' ]]; then
				list_relist
			else
				read_changelog
			fi
		fi
	}
	list_relist(){
		if [[ $relist_title != '' ]]; then
			cancel_lbl=$"Back to list"'!zen-undo'
			ok_lbl=$"Read"'!zen-ok'
		else
			[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
			ok_lbl=$"Select"'!zen-ok'
		fi
		if [ ${#entrylog_list[@]} -le 1 ]; then
			ln=0
			for log_line in ${entry_list[@]}; do
				[ ${ln} = 0 ] && entrylog_list+=("TRUE") || entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
				ln=$(($ln+1))
			done
		fi
		list_type='radiolist'; columns=2; sel_col=2; sep=''; hid_col=0; edit_col=0; col_tip=0; l_tail=0; w_head=0 ; col_name=''
		w_width='550'; w_height='420'
		l_text=$"${j}${bf}Nvidia Change Logs list $relist_title${end}${end}"
		entrylog=( $( win_yad_list "${entrylog_list[*]}" "") )

		if [[ "$entrylog" =~ [a-z] ]]; then
			if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
				log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
				log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
				sed -n "s/^===.*$//g;p")
			else
				log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
				[ "$log_end" != '' ] || log_end="====.*$"
				log_list=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
				sed -n "s/^===.*$//g;p")
			fi

			if [[ $relist_title != '' ]]; then
				if [ $txt_val = 1 ]&&[ $(grep -E -c ".*[0-9]{4}-[0-9]{2}-[0-9]{2}" <<< $entrylog) -eq 0 ]; then
					log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$catch_title/,/$log_end/p"| \
					sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
				else
					log_brief=$(cat $zen_docs/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
					sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
				fi
				brief
			else
				log_brief=$(cat <<< $log_list | sed -En "s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}" )
			fi
		else
			if [ "$catch_title" != '' ]; then
				if [ ${entrylog} = 200 ]; then [ $task_opt -gt 0 ] && exit 1; menu_manage; else read_changelog; fi
			else
				if [ ${entrylog} -ge 100 ]; then [ $task_opt -gt 0 ] && exit 1; menu_manage; fi
			fi
		fi
	}
	entry_list=$(grep -E -e "=====" $zen_docs/NVIDIA_Changelog | sed -En "s/[ ]?={8}[ ]?//g;p")
	list_relist
	if [[ $log_list =~ .*[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
 		local entry_list entry_catch entrylog_list=()
		if [ $(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$") -gt 0 ]; then
			txt_key="$(cat <<< $log_brief | sed -n '1p' | grep "\* [A-Z].*$"|sed -n "s/\* //g;p")"
			txt_val=$(cat <<< $log_brief | sed -n '1p' | grep -c "\* [A-Z].*$")
			entry_list+=("First $entrylog Log")
		fi
		entry_list=( $(printf "$log_list" 2>/dev/null | grep -E ".*[0-9]{4}-[0-9]{2}-[0-9]{2}"| sed -En "s/ ([0-9]{4})/\1/g;p" | sort -nr) )

		relist_title=": ${y}$entrylog${end}"; catch_title=$entrylog
		list_relist
	else
		brief
	fi
	IFS=$ifs
}
read_zen_changelog(){
	local entry_list entrylog_list entrylog
	# define entry null data.
	local log_list='' entrylog_list=() log_brief='' entrylog=()

	if [[ "$notif_desk_opt" =~ 'z' ]]; then log_from_local=1; else log_from_local=0; fi
	if [ $log_from_local = 1 ]; then
		log_pages=$(user_CF_DIR)/src/zen_git.log # from user dir
	else
		log_pages=$zen_docs/Changelog.txt # from install dir
	fi
	IFS=$(echo -en "\n\b")

	brief(){
		log_version=$(echo "$entrylog"| grep -E -o "v[0-9].[0-9](.[0-9]{1,2})?")
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$"$( cat <<-BRIEF
			Zenvidia changelog : ( $log_version )

			$log_brief
			BRIEF
			)"
		else
			log_brief=$(echo -e $"Zenvidia changelog ( $log_verion ) :\n\nNothing to display here.\nLog file empty.")
		fi

		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!gtk-close' || cancel_lbl=$"Back to menu"'!zen-back'
		log_txt=$"${v}<b>Zenvidia changelog : ${y}$log_version${end}</b>${end}"
		w_formatted=1; w_wrap=1; w_width='750'; w_height='400'; all_btn=1; colors=1; ok_lbl=$"Back to list"'!zen-undo'
		read_view=$(win_yad_text "$log_brief" 0 "")
		if [ $read_view -ge 1 ]; then [ $task_opt -gt 0 ] && exit 1; menu_manage; else read_zen_changelog; fi
	}
	list_relist(){
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			ln=0
			for log_line in ${entry_list[@]}; do
				[ ${ln} = 0 ] && entrylog_list+=("TRUE") || entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
				ln=$(($ln+1))
			done
		fi
		l_text=$"${j}${bf}Zenvidia Change Logs list${end}${end}"
		col_name=( "" "Version")
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Back to menu"'!zen-back'
		list_type='radiolist'; columns=2; sel_col=2; sep=''; l_tail=0; w_head=1 ; col_name=''; ok_lbl='Read!zen-ok'
		hid_col=0; edit_col=0; col_tip=0; w_width='500'; w_height='300'
		entrylog=$( win_yad_list "${entrylog_list[*]}" "")
		if [[ "$entrylog" =~ [a-z] ]]; then
			if [ $log_from_local = 1 ]; then
				entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
			else
				entrylog=$(echo -e "$entrylog"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
			fi
			log_end=$(grep -E -A1 "$entrylog" <<< ${entry_list[*]}| sed -n 2p)
			if [ "$log_end" != '' ]; then
				if [ $log_from_local = 1 ]; then
					log_end=$(echo -e "$log_end"| sed -En "s/^(.*:.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from user dir
				else
					log_end=$(echo -e "$log_end"| sed -En "s/^(.*-.*v[0-9].[0-9](.[0-9]{1,2})?).*$/\1/p") # from install dir
				fi
			else
				log_end='^     $'
			fi
			log_list=$(cat $log_pages | sed -En "/$entrylog/,/$log_end/p")
			if [ $log_from_local = 1 ]; then
				log_brief=$(grep -E "^.*-" <<< $log_list) # from user dir
			else
				log_brief=$(grep -E "^[ ]{,3}-" <<< $log_list) # from install dir
			fi
		else
			if [ ${entrylog} -ge 100 ]; then [ $task_opt -gt 0 ] && exit 1; menu_manage; fi
		fi
	}
	if [ $log_from_local = 1 ]; then
		entry_list=$(grep -E -e "^[Aa-Zz]{3} [0-9]{1,2} [0-9]{4} :" $log_pages | sort -nr) # from user dir
	else
		entry_list=$(grep -E -e "^* [0-9]{4}-[0-9]{1,2}-[0-9]{2} -" $log_pages | sed -n "s/^* //p"| sort -nr) # from install dir
	fi
	list_relist
	brief
	IFS=$ifs
}
nv_config(){
	local gpu_set=''
	if [ -x $d_nv_settings ]; then
		gpu_set="$($d_nv_settings -q gpus | grep -i "nvidia" | sed -En "s/^.*\[gpu:([0-9])\].*(\(.*\)).*$/\"GPU \1 - \2\"/g;p")"
	# 	$(su_cmd) "$(def_user)" $d_nv_settings -p "$gpu_set"
		if [ $UID = 0 ]; then
			su_cmd "env XDG_RUNTIME_DIR=/run/user/$(def_user_id) $d_nv_settings --page=$gpu_set"
		else
			$d_nv_settings --page=$gpu_set
		fi
		menu_modif
 	else
		die 3 ${LINENO} $"Nvidia-setting not found.\nInstall it first !" "base_menu"
 	fi
}
zen_notif_setup(){
	local setup_list setup_option c_set_list menu_notif yad_warn
	setup_validation(){
		warn_log=$"${vB}Autostart launcher will be set to :\n<b>></b>${end} ${j}$_notif${end}"
		[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
		ok_lbl=$"Ok"'!zen-ok'
		yad_warn=$(win_yad_warns "${warn_log}" 1 "${ok_lbl}" "${cancel_lbl}" 0 "")
		case $yad_warn in
			0) sed -Ei "s/(Exec=zen_notify) -[a-z]/\1 $_set/" $notif_desk_file; menu_modif ;;
			1) [ $task_opt -gt 0 ] && exit 0 || menu_modif ;;
			2) [ $task_opt -gt 0 ] && exit 0 || base_menu ;;
		esac
	}
	setup_option=(
	$"Check driver update only;driver check only;n"
	$"Check zenvidia and driver update;driver and zenvidia check;z"
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP

		<i>You can leave it as it is or choose between
		one of the sets below</i>.
		HLP
		)"
	else
		hlp_tip=''
	fi
	st=1
	for n_set in "${setup_option[@]}"; do
		m_set=$(printf "$n_set"|cut -d';' -f1)
		c_set=$(printf "$n_set"|cut -d';' -f2)
		o_set=$(printf "$n_set"|cut -d';' -f3)
		if [[ $o_set == $notif_desk_opt ]]; then
			c_set_cnf=$c_set
			set_state='true'
		else
			set_state='false'
		fi
		setup_list+=("$set_state")
		setup_list+=("$st")
		setup_list+=("$m_set")
		st=$((st+1))
	done
	l_text=$"$(cat <<-MSG
		${j}${bf}Notifications config${end}${end}

		Notification is currently set to: ${y}$c_set_cnf${end}

	MSG
	)"

	IFS=$(echo -en "\n\b")
	[ $task_opt -gt 0 ] && cancel_lbl=$"Exit"'!zen-close' || cancel_lbl=$"Previous"'!zen-back'
	ok_lbl='Select!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='0'
	menu_notif=$( win_yad_list "${setup_list[*]}" "")
	case $menu_notif in
		1) _set='-n'; _notif=$"driver check only" ;;
		2) _set='-z'; _notif=$"driver and zenvidia check" ;;
		200) [ $task_opt -gt 0 ] && exit 0 || base_menu ;;
		100|*) [ $task_opt -gt 0 ] && exit 0 || menu_modif ;;
	esac
	setup_validation
}

## SUB MENU
menu_install(){
	local install_list ins_cmd ins_list
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$( cat <<-HLP

		${v}Select here the install type${end}
		${sf}
		- <b>From a local package</b>:
		   Install a new driver from a user directory local package
		   or a listed already downloaded with zenvidia.
		- <b>From Nvidia server</b>:
		   Will display the full drivers list from the Nvidia server.
		   Install and download will be executed in the next step.
		${end}
		HLP
		)"
	else
		hlp_tip=$"\n${v}Select here the install type${end}"
	fi
	install_list=($"From a local package" $"From NVIDIA server")
	n=1
	for ins_cmd in "${install_list[@]}"; do
		ins_list+=("false")
		ins_list+=("$n")
		ins_list+=("$ins_cmd")
		n=$[ $n+1 ]
	done
	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Install new drivers${end}\n${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_inst=$( win_yad_list "${ins_list[*]}" "")
	ui_mod=1
	force=''
	case $menu_inst in
		1) menu_msg=$"${vB}NVIDIA package update from local dir. ${end}"; from_install=1; from_directory ;;
		2) connection_check && ( menu_msg=$"${vB}NVIDIA package update from NVIDIA server.${end}"; from_install=0; net_version_selector ) ;; # base_menu ;;
		200) exit 1;;
		100|*) base_menu ;;
	esac
}
menu_update(){
	check_version
	local menu_upd up_list
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(cat <<-HLP

		${v}Select here the element to update or install${end}
		${sf}
		- <b>Driver upgrade</b>
		   Check for new driver update.
		   You can select during the process to download only or install directly.
		   If <i>download only</i> is chosen, for installation afterward
		   go back to : » ${j}main${end} menu » ${j}Install Drivers${end}
		   <u>Note</u> : All download are stored.
		- <b>Update driver only (dkms)</b>
		   Install nvidia dkms modules for a new running kernel.
		- <b>Update driver only (force)</b>
		   Optional command to force install from driver sources in case of
		   DKMS failure.
		- <b>Update driver for an other kernel (dkms)</b>
		   Optional command to update nvidia modules for an other kernel.
	${end}
		HLP
		)"
	else
		hlp_tip=''
	fi
	nu=1
	if [ $hlp_txt = 0 ]; then hlp_tip=$"\n${v}Select here the element to update or install${end}"; fi
		if [ $use_dkms = 1 ]; then
			up_cmd_list=($"Driver upgrade" $"Update driver only (dkms)" $"Update driver only (force)" $"Update driver for an other kernel (dkms)" $"Update Cuda Toolkit")
		else
			up_cmd_list=($"Driver upgrade" $"Update driver only" $"Update driver for an other kernel" $"Update Cuda Toolkit")
		fi
	for up_cmd in "${up_cmd_list[@]}"; do
		up_list+=("false")
		up_list+=("$nu")
		up_list+=("$up_cmd")
		nu=$[ $nu+1 ]
	done 
	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Update Drivers or kernel modules${end}${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_upd=$( win_yad_list "${up_list[*]}" "") || die 1 ${LINENO} "Menu listing failure" ""
	home=/home/$(def_user)
	force=''
	if [ $use_dkms = 1 ]; then
		case $menu_upd in
			1)	connection_check && ( menu_msg=$"${v}Check driver updates list${end}"; legacy_drv=0; check_for_newer; check_update; ) ; base_menu  ;;
			2)	menu_msg=$"${v}Build module for current kernel (dkms)${end}"; upgrade_other=0; force='--force'; upgrade_kernel ;;
			3)	menu_msg=$"${v}Build module for current kernel (force)${end}"; upgrade_other=0; use_dkms=0; upgrade_kernel ;;
			4)	menu_msg=$"${v}Build module for the selected kernel (dkms)${end}"; upgrade_other=1; upgrade_new_kernel ;;
			5) connection_check && update_cuda || base_menu ;;
			200) exit 0 ;;
			100|*) base_menu ;;
		esac
	fi
}
menu_modif(){
	check_version
	local m_menu_list mod_list case_line menu_mod
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(cat <<-HLP

		${v}Select here the element to modify or edit:${end}
		${sf}
		- <b>Edit Xorg config file</b>:
			Edit the current xorg configuration file in /etc/X11.
		- <b>Edit script config</b>:
			Edit Zenvidia basic user conf script to set or unset mostly everything.
		- <b>Edit GUI font colors</b>:
			Change defaults font colors.
		- <b>Nvidia settings</b>:
			Start Nvidia-setting graphic UI tool.
		- <b>Edit distro config</b>:
			Modify the distribution configation file.
			<u>Notice</u> : You can add here the very specifics distro's variables.
		- <b>Manage drivers packages</b>:
			This tool is to backup, restore and remove old or current driver install.
			It also manage dowloaded nvidia's .run pack.
			<u>Note</u> : if old installation is found during driver update,
			it is automatically backed up prior to new version installation.
		- <b>Notication settings</b>:
			Configuration tool for Zen_notify daily update checker.
		- <b>Open driver switch tool</b> (optional):
			When available, this tool allow to switch between
			open and proprietary source drivers.
		- <b>Prime Display Tool</b> (optional)
			When available, manage Prime Display behaviour.
			PRIME and PRIME render offload managed only.
		${end}
		HLP
		)"
	else
		hlp_tip=$"\n${v}Select here the element to modify or edit${end}"
	fi
	[ -e $zen_tmp_dir/nv_color_tmp.* ] && rm -f $zen_tmp_dir/nv_color_tmp.*
	nd=1
	open_switch(){ if [ $UID = 0 ]; then win_open_switch; else  is_SU; base_menu; fi;}
	prime_display(){ if [ $UID = 0 ]; then prime_setup; else  is_SU; base_menu; fi;}
	edit_distro(){ if [ $UID = 0 ]; then edit_distro_conf; else is_SU; base_menu; fi;}
 	#edit_xorg(){ from_install=0; if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; base_menu; fi;}
 	edit_xorg(){ if [ $UID = 0 ]; then edit_xorg_conf; else is_SU; base_menu; fi;}
	manage_drivers(){ if [ $UID = 0 ]; then manage_pcks; else is_SU; base_menu; fi;}
	m_menu_list+=( $"Edit xorg config file","edit_xorg" )
	m_menu_list+=( $"Edit Zenvidia config","edit_script_conf" )
	m_menu_list+=( $"Edit GUI Colors","edit_color_conf" )
	m_menu_list+=( $"Nvidia-settings","nv_config" )
	m_menu_list+=( $"Edit Distro config","edit_distro" )
	m_menu_list+=( $"Manage drivers packages","manage_drivers" )
	m_menu_list+=( $"Zenvidia notification config","zen_notif_setup" )
# 	m_menu_list+=(  )
	IFS=$(echo -en "\n\b")
	if [ $open_drv -gt 0 ]; then
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=($"Open driver switch tool")
		nd=$((nd+1))
		case_line+=("open_switch")
	fi
	if [ $opti_preset -gt 0 ]; then
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=($"PRIME Display config")
		nd=$((nd+1))
		case_line+=("prime_display")
	fi
	for mod_cmd in "${m_menu_list[@]}" ; do
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("$(printf $mod_cmd| cut -d',' -f1)")
		nd=$((nd+1))
		case_line+=("$(printf $mod_cmd| cut -d',' -f2)")
	done
# 	local menu_mod
	l_text=$"${j}${bf}Configuration and Tools${end}${end}$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; l_tail=0; w_head=0 ; col_name=''
	hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_mod=$( win_yad_list "${mod_list[*]}" "")
	case ${menu_mod} in
		1) ${case_line[0]};;
		2) ${case_line[1]};;
		3) ${case_line[2]};;
		4) ${case_line[3]};;
		5) ${case_line[4]};;
		6) ${case_line[5]};;
		7) ${case_line[6]};;
		8) ${case_line[7]};;
		9) ${case_line[8]};;
		10) ${case_line[9]};;
		200) exit 0 ;;
		100|*) base_menu ;;
	esac
}
menu_manage(){
	local mng_list menu_mng
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$"$(
		cat <<-TIP

			${v}README and Help file from Nvidia $(version) and other.${end}
			${sf}
			- <b>Documanetation</b>:	Read the current Nvidia help file.
			- <b>Change Logs</b>:		Read the current Nvidia changelog file.
			- <b>Zenvidia Logs</b>:		Read the Zenvidia changelog file.
			- <b>Zenvidia Help</b>:		Read Zenvidia doc file.
			- <b>About Zenvidia</b>:	Read current Zenvidia README file.
			${end}
		TIP
		)"
	else
		hlp_tip=$"\n${v}README and Help file from Nvidia $(version) and other.${end}"
		w_height='--height=300'
	fi
	nm=1
	for mng_cmd in $"Documention manual ($(version))" $"Change Logs ($(version))" $"Zenvidia Logs" $"Zenvidia Help and documentation" $"About Zenvidia"; do
		mng_list+=("false")
		mng_list+=("$nm")
		mng_list+=("$mng_cmd")
		nm=$[ $nm+1 ]
	done
	IFS=$(echo -en "\n\b")
	l_text=$"${j}${bf}Help and Documentation${end}${end}""$hlp_tip"
	cancel_lbl=$"Back to main"'!zen-back'; ok_lbl=$"Select"'!zen-ok' ; l_tail=0; w_head=0 ; col_name=''
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0; w_width='400'; w_height='300'
	menu_mng=$( win_yad_list "${mng_list[*]}" "")
	case $menu_mng in
		1) unset chapter_index chapters_list; read_nv_help ;;
		2) read_changelog ;;
		3) read_zen_changelog ;;
		4) read_help ;;
		5) read_about ;;
		200) exit 0 ;;
		100) base_menu ;;
	esac
}

### RESCUE COMMAND LINE ###
dm_serv_restore(){
	if [ $no_mod=0 ]; then
		if [ "$dkms_ins" == "$cmd_ver" ]; then
			for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
				if [[ $(ls -1 /etc/modprobe.d | grep -c "nvidia-blacklist") = 0 \
				|| $(grep -owc "$drv" /etc/modprobe.d/nvidia-blacklist.conf) -eq 0 ]]; then
					drv_list+=("$drv")
				fi
			done
			test $echec = 0 && ( echo -e "${nc}# ${yel}DM and $dkms_ins drivers re-init :${nc}" )
			echo -e "${nc}# ${yel}Unload $dkms_ins drivers if any${nc}."; sleep 2
			/sbin/modprobe -r -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Load $cmd_ver drivers${nc}."; sleep 2
			command -v restorecon &>/dev/null || /sbin/modprobe -a ${drv_list[*]}
			echo -e "${nc}# ${yel}Exec $KERNEL modules reload."; sleep 2
			exec_mod_load
			echo -e "${nc}# ${yel}Exec $KERNEL modules init."; sleep 2
			exec_initramfs "\\r\${nc}#\${cya} (\$m sec.) Exec $KERNEL modules initramfs." "$m"
			echo -e "\n${nc}# ${yel}Done.${nc}"
			echo -e "# ${yel}License is $license ${nc}."
			## catch console pid here
			if [ "$(dm_serv)" != "" ]; then
				test $($d_sys status $(dm_serv) | grep -c "disabled") -gt 0 && (
				echo -e "${nc}# ${yel}Restore $(dm_serv) service to 'enable'${nc}."; sleep 2; )
				$d_sys enable $(dm_serv).service
				echo -e "${nc}# ${yel}Start $(dm_serv) service${nc}."; sleep 2
				echo -e "${cya}(Press ENTER to start, CTRL-C to cancel)${nc}"; read
				$d_sys start $(dm_serv).service
			else
				echo -e "${nc}# ${yel}You can 'enable' and 'start' your Display Manager now.${nc}."
			fi
			## trying to kill console root's tty.
			if [ $(w | grep -c "root.*tty") -gt 0 ]; then
				sleep 40
				pkill -9 -t $(w | grep "root.*tty" | awk '{print $2}')
			fi
		else
			echo -e "${nc}# ${red} WARNING${yel}: $cmd_ver differ from installed driver ($dkms_ins); <rebuild> first.\nAbort.${nc}."
		fi
	else
		echo -e "${nc}# ${red} WARNING${yel}: No modules found for $KERNEL, install $cmd_ver first with <rebuild> option.\nAbort.${nc}."
	fi
}
restore_cmdline(){
	echec=0
	echo -e "# ${yel}Restoring $cmd_ver driver for $KERNEL${nc} :\n"
	sleep 2
	## clean old libraries
	if [ "$dkms_ins" != "" ]; then
		if [[ $cmd_ver != $dkms_ins ]]; then
			echo -e "# ${cya}Cleaning $dkms_ins old installation${nc} ..."
			sleep 2
			rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$dkms_ins
			rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$dkms_ins
			rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$dkms_ins
			test -d /var/lib/dkms/nvidia/$dkms_ins && $p_dkms remove nvidia/$dkms_ins --all
			test -d /var/lib/dkms/open-nvidia/$dkms_ins && $p_dkms remove open-nvidia/$dkms_ins --all
			rm -Rf /usr/src/nvidia-$dkms_ins
			test -d /usr/src/open-nvidia-$dkms_ins && rm -Rf /usr/src/open-nvidia-$dkms_ins
			sleep 2
		fi
	fi
	restore_pcks_cmd
# 	echo -e "\n# ${blu}- Registering $cmd_ver libraries (ldconfig)${nc} ..."
# 	ldconfig
	echo -e "# ${cya}- Depmod $cmd_ver modules ..."
# 	progress_msg(){ echo -en "\r${nc}#${cya} - Depmod $cmd_ver modules ($m sec.)"; }
	m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )" "\\r\${nc}#\${cya} - Depmod $cmd_ver modules (\$m sec.)" "$m"
	## check modules
	echo -e "\n${nc}# ${cya}- Testing $cmd_ver modules availbility${nc} ..."
	local vermagic=$(/sbin/modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	local license=$(/sbin/modinfo -F license nvidia -k $KERNEL)
	if [[ "$vermagic" =~ "$(uname -r)" ]]; then
		echo -e "# ${yel}Initramfs update${nc}."
	else
		echo -e "# ${red}Test failed${nc}."; echec=1; rebuild_cmdline
		# define again newly install dkms modules for DM restart section.
		dkms_ins=$(/sbin/modinfo -F version $libmod/nvidia.ko*)
	fi
# 	test $vermagic && echo -e "# ${yel}Initramfs update${nc}." || \
# 	( echo -e "# ${red}Test failed${nc}."; echec=1; rebuild_cmdline )
	sleep 2
	if [ $echec = 0 ]; then
		echo -e "\n${nc}# ${yel}Done.${nc}"
		echo -e "# ${yel}License is $license ${nc}.\n"
		dm_serv_restore
	fi
}
rebuild_cmdline(){
	if [ $echec = 1 ]; then
		echo -e "# ${red}WARNING ${yel}: No $cmd_ver modules set in the backup${nc}.\n"; sleep 2
	fi
	echo -e "# ${yel}Build & Install $cmd_ver DKMS $KERNEL modules ($license) :${cya}"; sleep 2
	if [ $($p_dkms status -m $module/$cmd_ver -k $KERNEL| grep -cv "added") -gt 0 ]; then
		$p_dkms remove -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms add -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	else
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	fi
	## recheck modules
	vermagic=$(/sbin/modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$(/sbin/modinfo -F license nvidia -k $KERNEL)
	if [[ "$vermagic" =~ "$(uname -r)" ]]; then
		echo -e "\n${nc}# ${yel}Initramfs update and other routines.${cya}"; sleep 2
		dm_serv_restore
	else
		echo -e "\n# ${red}Failed${nc}."
	fi
}
rescue_cmdline(){
	## modinfo will display error if modules is not found, just add comments.
	clear
	echo -e "# ${yel}Compling $module $cmd_ver sources${nc} :\n" ; sleep 2
	kernel_module_src=/usr/src/$module-$cmd_ver
	cd $kernel_module_src; make -j12
	## check again
	vermagic=$(/sbin/modinfo -F vermagic $kernel_module_src/nvidia.ko*| awk '{print $1}')
	license=$(/sbin/modinfo -F license nvidia -k $KERNEL)
	if [ $vermagic ]; then
		if [[ $vermagic == $KERNEL ]]; then
			cp -f *.ko $libmod/
			## compress modules.
			clear
			echo -e "# ${cya}- Compressing modules if needed${nc}."; sleep 2
# 			is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
			[ $(is_RT) = 0 ]|| xz -T12 $libmod/*.ko
			echo -e "# ${cya}- Depmod $cmd_ver modules ..."
# 			progress_msg(){ echo -en "\r${nc}#${cya} - Depmod $cmd_ver modules ($m sec.)"; }
			m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )" "\\r\${nc}#\${cya} - Depmod $cmd_ver modules (\$m sec.)" "$m"
			## rebuild initramfs in case of trouble booting.
			clear
			dm_serv_restore
		fi
	else
		echo -e "${nc}#${red} *** Something went wrong ! ***\n${nc}#${yel} Restoration script can't proceed, exit${nc}."
	fi
}
## root warning
is_SU(){
	warn_log=$"$(cat <<-WRN
	${y}${bf}Your are not superuser${end}${end}
	This command can't be executed without ${j}<b>administrator</b>${end} privilege.
	See ${j}<b>Zenvidia task bar</b>${end} to run as admin or
	${j}<i>Zenvidia (administrator)</i> desktop entry${end} instead.
	WRN
	)"
	die 2 ${LINENO} "$warn_log" ""
}

### MAIN MENUS ###
base_menu(){
	right_check(){
		if [ $UID = 0 ]; then echo "superadmin"; else echo $"$USER (write privilege not allowed)"; fi
	}
	hlp_tip_txt=$"$( cat <<-HLP
		${v}Help tips text is currently set${end}
		${sf}You can unset it at any moment in:
		${j}Configuration and Tools${end} menu » ${j}Edit script config${end}.
		${end}
	HLP
	)"
	[ $hlp_txt = 0 ] && hlp_wrn="\r" || hlp_wrn="$hlp_tip_txt"

	local menu_cmd menu_list sys_infos txt_render
	local spaces=0 n=0 more install_state
	IFS=$(echo -en "\n\b")

	nv_installer_check
	sys_infos+=($"Distribution"" : #|$(distro_name)")
	sys_infos+=($"Processor type"" : #|$ARCH")
	until [ $n -eq ${#dev_n[*]} ]; do
		sys_infos+=($"Card $((${dev_n[$n]}+1)) : #|${dev[$n]}")
		n=$((n+1))
	done
	sys_infos+=($"Driver version installed"" : #|$(drv_installed)")
	sys_infos+=($"Kernel version"" : #|$KERNEL")
	sys_infos+=($"GCC version"" : #|$GCC")
	sys_infos+=($"NVIDIA binary version"" : #|$NV_bin_ver")
	if [ $open_drv = 1 ]; then
		install_state=$"installed"
		if [ $use_open = 1 ]; then
			if [ $use_open = 1 ]; then open_used=$" and in use"; else open_used=$", but unused"; fi
		else
			open_used=$", closed source used"
		fi
		sys_infos+=($"Open Source modules"" : #|${install_state}${open_used}" )
		sys_infos+=($"Modules license"" : #|$(version_license)")
	fi
	sys_infos+=($"Rights"" : #|$(right_check)")

	for sys_line in ${sys_infos[@]}; do
		defi=$(cut -d'|' -f1 <<< $sys_line)
		cara=${defi%%#*}
		(( ${#cara} > spaces )) && spaces=${#cara}
	done
	for sys_line in ${sys_infos[@]}; do
		defi=$(cut -d'#' -f1 <<< $sys_line)
		cara=${defi%%#*}
		tab=$((spaces - ${#cara}))
		set=$(cut -d'|' -f2 <<< $sys_line)
		[ ${#cara} -lt 9 ] && more='\t\t' || more='\t'
		[ ${tab} -eq 5 ] && more=''
		txt_render+=( $(printf "\    ${vB}%s${end}%*s${more}${j}%s${end}\n" "$defi" "$tab" "" "$set") )
	done

	l_text=$"$( cat <<-MSG
		${r}<big><b>$(nv_pci_device)</b></big>${end}
		${y}Close and Open Source drivers management${end}

		$(echo -e "${txt_render[*]}")

		${hlp_wrn}
		${v}What do you want to do ?${end}
	MSG
	)"
	cancel_lbl=$"Exit"'!zen-stop'; ok_lbl=$"Select"'!zen-ok'
	list_type='radiolist'; columns=3; sel_col=2; sep=''; hid_col=2; edit_col=0; col_tip=0
	w_width='620'; w_height='300'; l_tail=0; w_head=0 ; col_name=''
	menu_list=( false 1 $"Install drivers" false 2 $"Update drivers or modules" false 3 $"Configuration and Tools" false 4 $"Help and Documentation" )
	menu_cmd=$( win_yad_list "${menu_list[*]}" "")
	[ $menu_cmd -ge 100 ] || tmp_dir
	case $menu_cmd in
		1) if_update=0; if [ $UID = 0 ]; then menu_install; else is_SU; base_menu; fi;;
		2) if_update=1; if [ $UID = 0 ]; then menu_update; else is_SU; base_menu; fi;;
		3) if_update=1; menu_modif ;;
		4) if_update=1; menu_manage ;;
		100|200|*) exit 0 ;;
	esac
# 	}
}
install_controls(){
	## migration de /usr/local/zenvidia à /usr/local/share/zenvidia
	if [ -d $install_dir/zenvidia ] ; then
		mkdir -p $nvdir
		cp -rf $install_dir/zenvidia/* $nvdir/
		rm -Rf $install_dir/zenvidia
	fi
}
set_graphical_env(){
	test -x "$d_yad" || exit 0 # security
	## check su command to allow root to get default user env.
	[[ -n "$(su_cmd)" ]] || set_su
	# cmdline tool doesn't need to read config, so skip the step if in console only.
	if [[ $(def_user) != "root" ]]; then
	# check if default user has conf file to load, or create it from shipped.
		for conf in {basic,color,distro}; do
			# reset list
			diff_list=()
			new_line=()
			if [ ! -e $(user_CF_DIR)/$conf.conf ]; then
				install -Cm644 -o $(def_user) -g $(def_user) -t $(user_CF_DIR) $nvdir/$conf.conf
			elif [ "$nvdir/$conf.conf" -nt "$(user_CF_DIR)/$conf.conf" ]; then
				cp -f $(user_CF_DIR)/$conf.conf $(user_CF_DIR)/$conf.conf~
				diff_list=( $(sed -En "s/^([a-z].*)=.*$/\1/p" $nvdir/$conf.conf) )
				if [ ${#diff_list[*]} -gt 0 ]; then
					# user_CF_DIR wont pass the IFS move, put it in a temp var.
					user_DIR=$(user_CF_DIR)
					IFS=$(echo -en "\n\b")
					for var in ${diff_list[@]}; do
						if [ $(grep -c "$var" $user_DIR/$conf.conf) -eq 0 ]; then
							case $conf in
								basic) new_line+=( $(grep -B1 "^$var" $nvdir/$conf.conf | sed -n '1p') )
										new_line+=( $(grep "^$var" $nvdir/$conf.conf) )
										sed -Ei "s|^(${prev_line}.*)$|\1\n${new_line[0]}\n${new_line[1]}|" $user_DIR/$conf.conf
										;;
								color) new_line=$(grep "^$var" $nvdir/$conf.conf)
										sed -Ei "s|^(${prev_line}.*)$|\1\n${new_line}|" $user_DIR/$conf.conf
										;;
							esac
						fi
						prev_line=$var
					done
	# 				IFS=$ifs
				fi
			fi
			eval ${conf}_conf=$(user_CF_DIR)/$conf.conf
		done
		# define necessary dirs in user config dir.
		nv_compat_dir="$(user_CF_DIR)/compats"
		upt_compat_dir="$(user_CF_DIR)/updates"
		nvdl="$(user_CF_DIR)/release"
		test -d $nvdl || mkdir -p $nvdl
		# check/change run packages permission
		nvdl_last=$(ls -1 $nvdl/|sed -n '$p')
		if [[ -s $nvdl/$nvdl_last ]] ; then
			for changes in $(ls -1 $nvdl ); do
				if [[ $(stat -c "%a" $nvdl/$changes) != 755 ]]; then
					chmod 755 $nvdl/$changes
				fi
			done
		fi
		[ $(chk_family) -gt 0 ] || { [ $optimus -gt 0 ] && opti_preset=1 ;}
		## zen notify desktop entry option (define zenvidia changelog reading behaviour)
		notif_desk_file=/home/$(def_user)/.config/autostart/zen_notify.desktop
		notif_desk_opt=$(cat $notif_desk_file| sed -En "s/^Exec=.*-(.*)/\1/p")
		## in case of first use, take care to launch zen_notify which is launching zen_task_menu
		[ -e $(user_CF_DIR)/notify/drvlist ] || su_cmd "zen_notify -n &>/dev/null"
		## then read script conf.
		. $basic_conf
		. $color_conf
		## force optimus check to off and unset opti_preset.
		[ $opti_preset_off = 1 ] && opti_preset=0
	else
		basic_conf=$conf_dir/basic.conf
		. $basic_conf
	fi
	## xterm dispaly details
	xterm_display_vars
	## check/install dependies.
	dep_control
	## define global temporary directory.
	if [ $temp_ramfs = 1 ]; then
		TMPDIR=/run/user/$(def_user_id)
		export TMPDIR
	fi
	## define backups directory.
	if [ $backup_to_user_dir = 1 ]; then
		[ $(ls -Ub1 $nv_backup_dir | wc -l) -gt 0 ] && mv -f -t $(user_CF_DIR)/backups/ $nv_backup_dir/*
		nv_backup_dir=$(user_CF_DIR)/backups
	else
		[ $(ls -Ub1 $(user_CF_DIR)/backups | wc -l) -gt 0 ] && mv -f -t $nv_backup_dir/ $(user_CF_DIR)/backups/*
	fi
	# load markup span font colors.
	zen_colors
	# pick all necessary env Definition
	gcc_compil_vars
	gcc_options_check
	proc_options
	## disto configuration file check warn if not set.
	if [ $distro_warn = 1 ]; then
		warn_log=$"$(cat <<-WRN
		${j}<b>No distribution special file found or configured</b>${end}

		If you distribution needs special variables or dependencies to be set,
		please relaunch Zenvidia and go to :
		<b>Configuration and Tools</b> menu » <b>Edit distro config</b>

		There edit the file as appropriate.
		WRN
		)"
		die 3 ${LINENO} "$warn_log" 0
	fi
	WIN_TITLE="Zenvidia - $(zen_version)"
# 	# test initramfs distro's tool.
# 	initramfs_warn
# 	base_menu
}
cmdline_help_text(){
# 	echo -e ${grn}
	cat <<-HT
		Command line : $(basename $0 ) [option] [driver version]
		Options are :
		.  restore	-> restore driver backup.
		.  rebuild	-> rebuild driver.
		.  rescue	-> force driver build from sources.
		.  reinit	-> Rebuild initramfs and start DM.
		.  help	-> Display help.
	HT
	if [[ -d $nv_backup_dir && $(ls -1 $nv_backup_dir | grep -c .) -gt 0 ]]; then
		echo -e "Driver version backups :"
		ls -1 $nv_backup_dir | sed -En "s/^nvidia.([0-9]*.*).tar$zip_ex/ - \1/p"
	fi
	file -E $libmod/nvidia.ko* &>/dev/null
	if [ $? -eq 0 ]; then
		echo -e "Installed driver version : $dkms_ins ($license)"
		echo -e "Available drivers : $(echo ${dkms_ver[@]}| tr '\n' ' ' )"
		no_mod=0
	else
		echo -e "Found dkms driver version : $module » $dkms_ver"
		no_mod=1
	fi
	echo -e "Display Manager : $(dm_serv)"
# 	echo -e ${nc}
}
## BASICS CHECK FUNCTIONS
default_sets(){
	## unfixed variables (could be change by user choice)
	nv_root=${nv_root:-/opt}						# Nvidia main driver directory
	nvlog=${nvlog:-${nvdir}/log}					# default logs directory
	nvdl=${nvdl:-${nvdir}/release}				# default download driver backups directory
	nv_backup_dir=${nv_backup_dir:-${nvdir}/backups}		# default backups archive directory
	nv_compat_dir=${nv_compat_dir:-${nvdir}/compats}		# default compat data files directory
	## building temporary files (could be change by user choice)
	nvtmp=${nvtmp:-${nvdir}/temp}					# default extract temp directory
	buildtmp=${buildtmp:-${nvdir}/build}		# default build temp directory
	## default main set value.
	temp_ramfs=${temp_ramfs:-1}
	backup_to_user_dir=${backup_to_user_dir:-0}
	backup_prev=${backup_prev:-1}
	distro_warn=${distro_warn:-0}
	drm_modset=${drm_modset:-1}
	GSP_firm=${GSP_firm:-1}
	opti_preset=${opti_preset:-0}
	from_install=${from_install:-0}
	rem_extract=${rem_extract:-1}
	use_dkms=${use_dkms:-1}
	open_drv=${open_drv:-0}
	use_open=${use_open:-0}
	use_persistenced=${use_persistenced:-0}
	fix_profiles=${fix_profiles:-0}
	use_gzip=${use_gzip:-0}
	exec_mod_tool=${exec_mod_tool:-0}
	ARCH=${ARCH:-$HOSTTYPE}
	xt_hold=${xt_hold:-0}
	xt_delay=${xt_delay:-4}
	## default PRIME values.
	opti_auto_set=${opti_auto_set:-0}
	opti_preset_off=${opti_preset_off:-0}
	offload=${offload:-0}
	render=${render:-'NONE'}
	enable_powerd=${enable_powerd:-0}
	## define if task bar menu entry are used
	task_opt=${task_opt:-0}
	## default warn display set is null.
	open_wrn=${open_wrn:-1}
	first_open=${first_open:-0}
	hlp_txt=${hlp_txt:-1}
	use_cuda=${use_cuda:-0}
}
default_zen_dir(){
	## Outside the "make install" process, for various reasons (restoration, fresh OS install, etc..)
	## user's directory existence and privileges may change. So, we check and fix it if necessary.
	test -d $(user_CF_DIR) || {
		mkdir -p $(user_CF_DIR)
		mkdir -p $(user_CF_DIR)/{compats/series,updates,release,backups}
	}
	## to prevent version.txt file to be wrong in case of command line restoration, or
	## in case version.txt for a reason or an other is not present, we test and fix if necessary.
	if [[ ! -f $(user_CF_DIR)/version.txt || $(cat $(user_CF_DIR)/version.txt| grep -c "$(version)") -eq 0 ]]; then
 		ctrl_mods=$(stat /usr/lib/modules/$(uname -r)/*|grep "$(module_dest_location)/nvidia.*" &>/dev/null && echo 1 || echo 0)
		[ ${ctrl_mods} -gt 0 ] && /sbin/modinfo -F version nvidia > $(user_CF_DIR)/version.txt || echo "" > $(user_CF_DIR)/version.txt
	fi
	[ "$(stat -c %U $(user_CF_DIR))" = "$(def_user)" ] || chown -R $(def_user):$(def_user) $(user_CF_DIR)
}
### SCRIPT INTRO ###
## all created file readable by everyone.
umask 022
## system bins path control and depencies list building if any.
dep_exec_check
## config distro elf type
libclass
## LD_LIBRARY_PATH definition (useless in Fedora).
export LD_LIBRARY_PATH=$install_dir/$master$ELF_32:$install_dir/$master$ELF_64

## controle install path.
install_controls
## main configuration file check and read mandatory vars config first.
if [ ! -s $script_conf ]; then #
	if [ -x $d_yad ]; then
		warn_log=$"<b>Script's config file missing.\n</b>"
		die 1 ${LINENO} "$warn_log" ""
	else
		die 1 ${LINENO} $"${red} # No zenvidia script conf file found. Abort.${nc}" ""
	fi
	exit 0
else
	## set the primary su_cmd var that doesn't exist in script conf at this state
	declare su_cmd_prompt=''
	## read script mandatory vars config first.
	. $script_conf
fi
# reset script root vars
declare dev_n dev slot slot_id vnd vnd_id dev_name
declare -a deplist=() dep_text=() parent=()
declare from_install='' NAME=''
## set default or null value after conf files reading in case reading failure or missing values.
default_sets
## for dkms 3.2 and higher, create the appropriete framework.conf for dracut.
if [ $(dkms_version) -ge 32 ]; then
	if [ ! -f $zen_framework_conf ]; then
	cat <<-CONF > $zen_framework_conf
		post_transaction="$(initramfs_tools) \$kernelver"
	CONF
	fi
fi
## ctrl if kernel headers are present, then add it to autoinstall list.
dep_lib_check
## define graphic devices data.
PCI_ID
## check users dirs privileges and load extra special distro config if any.
if [ "$(def_user)" != "root" ]; then
	## check user config dirs presence and privileges.
	default_zen_dir
	## load extra special distro config
	if test -f $(user_CF_DIR)/distro.conf; then
		. $(user_CF_DIR)/distro.conf
	else
		echo -e $"${red} # No distribution conf file found.${nc}"
		echo -e $"${cya} # If your distribution needs special variables or dependencies,${nc}"
		echo -e $"${cya} # please relaunch zenvidia and edit the special file as appropriate.${nc}"
		distro_warn=1
	fi
fi
## define global temporary folder
zen_tmp_dir=$(mktemp -d --tmpdir zen_temp.XXXX)
trap "IFS=\$ifs; rm -Rf \$zen_tmp_dir;" EXIT

## check if X server is off before lauching cmd line tools.
# x_check(){ echo 1;} # fake x not running.
if [ $(x_check) -gt 0 ]; then
	DEV "Command line tools" "0" # unavailable message
	# gcc, env, kernel, etc
	gcc_compil_vars
	proc_options
	libmod='/lib/modules/'$KERNEL'/'$(module_dest_location)
	no_mod=0
	echo -e "** ${red}X server is not runing, perfect! (◠‿◠)${nc} **"
	test -f $libmod/nvidia.ko* &>/dev/null || \
	{ echo -e "${red}** Nvidia driver is not installed yet, rescue tools are useless at this point (⌣_⌣) **${nc}"; exit 0 ;}
	if [ $(/sbin/modinfo -F license $libmod/nvidia.ko* | grep -ic "Dual") -gt 0 ]; then
		module='open-nvidia'
		license='Dual MIT/GPL'
	else
		module='nvidia'
		license='NVIDIA'
	fi
	## check realtime kernel.
	if [ $(is_RT) = 1 ]; then
		ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
		export IGNORE_PREEMPT_RT_PRESENCE=$(is_RT)
	fi
	## check dkms mods list.
	dkms_ins=$(/sbin/modinfo -F version $libmod/nvidia.ko*)
	dkms_ver=$(ls /var/lib/dkms/${module}/ | grep "^[0-9]\{3,\}")
	echec=0
	# start commande linetools
	if [ $# -gt 0 ]; then
		while (( $# > 0 )); do
			case ${1} in
				restore) restore_cmdline ;;
				rebuild) rebuild_cmdline ;;
				rescue) rescue_cmdline ;;
				reinit) dm_serv_restore;;
				help) cmdline_help_text ;;
				*) echo -e "${red}** Wrong option (o_o) **${nc}"; cmdline_help_text ;;
			esac
			shift
		done
	else
		cmdline_help_text
	fi
	exit 0
else
	set_graphical_env
	## from there, script need a runing X server
	## option are for zen_task_menu, rescue, degug and test.
	if [ $# -gt 0 ]; then
		while (( $# > 0 )); do
		# 't' is the dev test function option.
			task_opt=1
			case ${1} in
				-r) read_zen_changelog;;
				-s) read_help;;
				-d) read_changelog;;
				-h) read_nv_help;;
				-x) [ $UID = 0 ] && edit_xorg_conf;;
				-p) [ $UID = 0 ] && prime_setup;;
				-c) edit_color_conf;;
				-n) zen_notif_setup;;
				-z) edit_script_conf;;
				-o) [ $UID = 0 ] && win_open_switch;;
				-a) read_about;;
				-u) if [ $UID = 0 ]; then legacy_drv=0; tmp_dir; check_for_newer; check_update; fi ;;
				--rescue) echo "not available yet" ;;
				--trace) ## debug without unbound vars analysis but heading function name to trace errors.
					set -x -e -E +u -T -o pipefail
					export PS4='->$(tput setaf 5)${FUNCNAME[0]}$(tput setaf 6)-${LINENO}$(tput sgr 0)$(printf "\\t")-> '
					#trap 'debug_failure ${LINENO} "$BASH_COMMAND"' ERR
					task_opt=0
				;;
				--debug) ## debug full spectrum but without function name display.
					set -x -e -u -E -o functrace
					export PS4='->$(tput setaf 6)${LINENO}$(tput sgr 0)$(printf "\\t")-> '
					task_opt=0
	 				# trap 'debug_failure ${LINENO} "$BASH_COMMAND"' 1
				;;
				--harddebug) ## debug full spectrum but without function name display.
					set -x -e -E -u -T -o pipefail
					export PS4='->$(tput setaf 6)${LINENO}$(tput sgr 0)$(printf "\\t")-> '
					task_opt=0
					trap 'debug_failure ${LINENO} "$BASH_COMMAND"' ERR
				;;
				-t) task_opt=1 ; echo -e "What do you thing brother !" ;; # function direct test option. DANGEROUS
				-*) die 1 ${LINENO} "Option pipe failed.\nOption "${1}" is not a valid option." "" ;;
			esac
			shift
		done
	fi
	## ### LET'S START ###
	# test initramfs distro's tool.
	initramfs_warn
	base_menu
fi
