#! /bin/bash

#  Zenvidia
#  Sat Feb  6 16:58:20 2010
#  Copyright  2010-2016  PirateProd
#  <wildtruc@noneltd.net>
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with main.c;if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301,  USA

### ZENVIDIA VARS
install_dir=/usr/local							# default tools & system install directory
nvdir=$install_dir/zenvidia					# default Zenvidia directory
conf_dir=$nvdir
script_conf=$nvdir/script.conf				# Zenvidia conf file
nv_root=/opt											# Nvidia main driver directory
nvtmp="$nvdir/temp"								# extract temp directory
buildtmp="$nvdir/build"							# build temp directory
nvlog="$nvdir/log"								# logs directory
nvdl="$nvdir/release"							# downlaod driver backups directory
nvbackup="$nvdir/backups"
nvcompat="$nvdir/compats"
### NVIDIA-INSTALLER VARS ###					# nvidia-installer option: install temp dir
help_pages="$install_dir/share/doc/NVIDIA_GLX-1.0"
zen_docs="$install_dir/share/doc/zenvidia"
docs="--documentation-prefix=$install_dir"
profile="--application-profile-path=$install_dir/share/nvidia"
icon_stock=/usr/local/share/pixmaps
img_zen_desktop=$icon_stock/swiss_knife.png
img_zen_bar=swiss_knife
# user_DL_DIR=$(su "$(who | awk '{print $1}')" xdg-user-dir DOWNLOAD)
xt_hold=0
xt_delay=4

## clean depencies list if any.
unset deplist
## multi distro system bianries compatibilities.
d_lspci=$(find /usr/{bin,sbin,local/bin,local/sbin} -name lspci)
d_modinfo=$(find /usr/{bin,sbin,local/bin,local/sbin} -name modinfo)
d_sys=$(find /usr/{bin,sbin,local/bin,local/sbin} -name systemctl)
p_xterm=$(find /usr/{bin,sbin,local/bin,local/sbin} -name xterm) || deplist+=("xterm")
p_git=$(find /usr/{bin,sbin,local/bin,local/sbin} -name git) || deplist+=("git")
p_wget=$(find /usr/{bin,sbin,local/bin,local/sbin} -name wget) || deplist+=("wget")
p_gcc=$(find /usr/{bin,sbin,local/bin,local/sbin} -name gcc) || deplist+=("gcc")
p_dkms=$(find /usr/{bin,sbin,local/bin,local/sbin} -name dkms) || deplist+=("dkms")
# p_diff=$(find /usr/{bin,sbin,local/bin,local/sbin} -name diff) || deplist+=("")
d_yad=$(find /usr/{bin,local/bin} -name yad) || deplist+=("yad")
d_zen=$(find /usr/{bin,local/bin} -name zenity) || deplist+=("zenity")
d_nv_installer=$(find /usr/{bin,local/bin} -name "nvidia-installer")
d_nv_settings=$(find /usr/{bin,local/bin} -name "nvidia-settings")
d_grub=$(find /usr/{sbin,local/sbin} -regextype sed -regex ".*grub[0-9]\?-.*"| sed -n "s/-.*$//;1p")
i_sys=$(find /usr/{bin,sbin,local/bin,local/sbin} -name dracut)
i_init=$(find /usr/{bin,sbin,local/bin,local/sbin} -name update-initramfs)
i_cpio=$(find /usr/{bin,sbin,local/bin,local/sbin} -name mkinitcpio)
E="Download"
PM="Back to previous menu"
MM="Back to main menu"
I="Quit"
CC="Confirm"
R="Back to main"
GO="Go on"
## Classic answer
ansOK="OK"
ansNF="NOT PRESENT"
ansNA="NONE"
ansCF="Confirm your choice."
ansWN="What do you want to do ?"

## terminal fonts colors.
red='\e[1;31m'
yel='\e[0;33m'
grn='\e[0;32m'
blu='\e[0;34m'
cya='\e[0;36m'
pur='\e[0;35m'
nc='\e[0m'

## PROLOGUE ###
## check if X server is alive
ps -A | grep -i xorg &>/dev/null
eval x_alive=$?
## save sys IFS variable for restoration purpose.
## ex: IFS=$' \t\n'
ifs=$IFS
## read script mandatory vars config first.
. $script_conf

## find first default values for distro and desktop user
## define who is facing the screen.
def_user(){ echo "$(who | awk '{print $1}')" | sed -n "1p"; }  # var
if [ $x_alive -eq 0 ]; then
	if [[ $(whoami) == "root" ]]; then
	user_DL_DIR(){
		echo "$($su_cmd "$(def_user)" xdg-user-dir DOWNLOAD)"
	}
	user_CF_DIR(){
		echo "$($su_cmd "$(def_user)" xdg-user-dir)/.zenvidia"
	}
	else
	user_DL_DIR(){
		echo "$(xdg-user-dir DOWNLOAD)"
	}
	user_CF_DIR(){
		echo "/home/$USER/.zenvidia"
	}
	fi
fi
distro_version(){ # var # OK
	## taken from DKMS script for conformity with dkms queries.
	if [[ -r /etc/os-release ]]; then
		. /etc/os-release
		if [[ "$ID" = "ubuntu" ]]; then
			# ID_LIKE=debian in ubuntu
			echo $ID
		elif [[ ${#ID_LIKE[@]} != 0 ]]; then
			echo ${ID_LIKE[0]}
		else
			echo $ID
		fi
		return
	fi
	local DISTRIB_ID
	# Try the LSB-provided strings first
	if [ -r /etc/lsb-release ]; then
		. /etc/lsb-release
	elif type lsb_release &>/dev/null; then
		DISTRIB_ID=$(lsb_release -i -s)
	fi
	## fix case sensitive
	case ${DISTRIB_ID} in
		Fedora) echo fedora ;;
		RedHatEnterprise*|CentOS|ScientificSL) echo rhel ;;
		SUSE*) echo sles ;;
		Arch) echo arch ;;
		*) if [[ ${DISTRIB_ID} ]]; then
				echo "${DISTRIB_ID}"
			else
				echo unknown
			fi
		;;
	esac
}
set_su(){ # new # OK
	w_text=$(cat <<-WRN
	<b><big>Zenvida didn't find any Distro config file for $plug_version</big></b>

	Next window will ask for distribution <b>name</b> and/or <b>sudo</b> command line
	options for default user admin priviledge.
	<i>( ex: sudo -l, sudo -u, etc )</i>
	WRN
	)
	zenity --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --warning --no-wrap \
	--text="$w_text" --icon-name=important --ok-label="Go it!"
	if [ "$plug_version" == "unknown" ]; then
		w_text=$( cat <<-MSG
			Enter name and <b>sudo</b> type command line arguments.
		MSG
		)
		zen_entry='--add-entry=Distribution'
	else
		w_text=$( cat <<-MSG
			Enter <b>sudo</b> type command line and option
		MSG
		)
	fi
	set_args=$(zenity --height=100 --width=100 --title="Zenvidia" --window-icon=$img_zen_desktop --forms \
	--text="$w_text" --separator=';' $zen_entry --add-entry="sudo command")
	if [ $? = 0 ]; then
		[ "$set_args" != '' ] || exit 0
		if [[ "$set_args" =~ ';' ]]; then
			plug_version=$(echo "$set_args"|cut -d';' -f1)
			plug_conf=$plug_version.conf
			su_cmd=$(echo "$set_args"|cut -d';' -f2)
		else
			su_cmd="$set_args"
		fi
		if [ $(grep -c "su_cmd=" $script_conf ) -eq 0 ]; then echo -e 'su_cmd="'$su_cmd'"' >> $script_conf; fi
	else
		exit 0
	fi
}
distro(){ # OK
	plug_version=$(distro_version)
	plug_conf=$plug_version.conf
	if [ "$plug_version" != "unknown" ]; then
		case $plug_version in
	# 		arch|sles|mageia|mandriva) su_cmd='su -l';;
			rhel|fedora|ubuntu|mint|debian) su_cmd='sudo -u';;
			*) su_cmd='su';;
		esac
	fi

	if [ "$(def_user)" != "root" ]; then
		if [[ ! -e $conf_dir/distro/$plug_conf ]]; then
			if [[ $(ls -1 $conf_dir/distro | grep -ic "$plug_conf" ) -gt 0 ]]; then
			## conf file exist but in a different upper/lower case.
				dest_conf=$(user_CF_DIR)/$(ls -1 $conf_dir/distro | grep -i "$plug_conf")
			else
			## conf doesn't exist and need to be created
				## check first if name is unknown and ask default su commabnd for user admin priv.
				set_su
				cat <<-CONF > $(user_CF_DIR)/$plug_conf
					## examples between [...] have to be remove by real texts, vars, commands.
					## You can reset detected or set name to friendly one to display in Zenvidia.
					DISTRO="$plug_version"
					kernel=\$( uname -r | cut -d '-' -f 1 )
					## optional kernel devel package extension sometime needed (see ex. below in p_kernel)
					d_version=[ex: \$( uname -r | cut -d '-' -f 1,2 )]
					## define X server executable.
					X="[X]"
					## define package installer and options.
					PKG_INSTALLER="[ex: dnf]"
					pkg_cmd='[ex: install]'
					## auto "yes" option, final space is here needed.
					pkg_opts='[ex: -y ]'
					## default distro 32/64 libs directories.
					if [[ \$ELF_TYPE == 64 ]]; then
						ELF_32="[ex: /i386-linux-gnu or nothing]"
						ELF_64="[ex: /x86_64-linux-gnu or 64]"
						master=lib
					else
						## usualy 32 bit distro doesn't need any special libs definitions.
						ELF_32=""
						ELF_64=""
						master=lib
					fi
					## grub/grub2 directory if different than usual.
					grub_dir=[def: /boot/grub2]
					## define specific dir extension for kernel header and drivers source directory if any.
					alt=[ex: /kernels for /usr/src/kernels/ instead of /usr/src/]
					## default distro kernel sources.
					kernel_src=[ex: /usr/src\$alt/\$(uname -r)]
					## default initramfs updater commend (ex: dracut -f, update-initramfs, etc)
					INITRAM='[ex: dracut -f]'
					if [ \$resolve_dep = 0 ]; then
					## distro specific depencies
					## You can had there any packages matching specific distro needs.
					## ex: deplist+=("package1"), deplist+=("package2"), etc
						deplist+=("[ex: kernel-devel, kernel-headers-\$(uname -r), gksu]")
						deplist+=("")
					fi
				CONF
				## warn about no config file
				w_text=$(cat <<-WRN
				<b>Main $plug_version distro variables are now setted</b>

				You need to create a <u>new configuration</u> based on your distro environment variables.

				<i>Note : Even in case you are not sure of what you are doing, new configuratin file will be saved anyway.
				You will just have to go back to it in <u>$(user_CF_DIR)/$plug_conf</u> afterward.</i>
				WRN
				)
				$d_zen --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --warning --no-wrap \
				--text="$w_text" --icon-name=xkill --ok-label="Let's go!"

				## edit new config file.
				edit_plug_conf=$( $d_zen --width=640 --height=400 --title="Zenvidia $plug_version edition" \
				--window-icon=$img_zen_desktop --text-info --editable \
				--filename="$(user_CF_DIR)/$plug_conf" --checkbox="Confirm to write" --cancel-label="Abort (panic button)" \
				--ok-label="Create config file")
				if [ $? = 0 ]; then
					echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf
				else
					## display error message and close all processes.
					w_text=$(cat <<-WRN
					<b>Zenvida can't work without Distro config file for $plug_version</b>

					<u>Don't ask the dev, if didn't create one, it's probably he doesn't know how to.</u>

					You can try having a look at your distro's community forum and ask for help
					or see Zenvidia's git discussion feed.
					Then going back to the saved config file in $(user_CF_DIR)
					WRN
					)
					$d_zen --width=450 --title="Zenvidia" --error --no-wrap \
					--text="$w_text" --icon-name=xkill --ok-label="Snif!"
						exit 0
					fi
			fi
		else
			dest_conf=$(user_CF_DIR)/$plug_conf
		fi
		test -f $(user_CF_DIR)/$plug_conf || cp -f $conf_dir/distro/$plug_conf $dest_conf
		. $(user_CF_DIR)/$plug_conf
	else
		## this is here add to get compatibility in terminal only mode and isn't used in graphic mode.
		plug_conf=$(ls -1 $conf_dir/distro |grep -i "$plug_version")
		if test -f $conf_dir/distro/$plug_conf; then
		    . $conf_dir/distro/$plug_conf
		else
		    echo -e "${red} # No distribution conf file found. Abort.${nc}"
		    exit 0
		fi
	fi
	# CHECK that /usr/local/ for lib is in LD path
	for LD in "$ELF_32" "$ELF_64"; do
		if [ $(ldconfig -p |grep -c "$install_dir/$master$LD") -eq 0 ]; then
			printf "$install_dir/$master$LD" > /etc/ld.so.conf.d/local-lib$LD.conf
		fi
	done
}
module_dest_location(){ # OK
	case "$(distro_version)" in
		fedora* | rhel* | ovm*) echo "extra" && return ;;
		sles* | suse* | opensuse*) echo "updates" && return ;;
		debian* | ubuntu*) echo "updates/dkms" && return ;;
		arch*) echo "updates/dkms" && return ;;
		*) echo "extra" && return ;;
	esac
}
dm_serv(){
	for dm in {gdm,kdm,xdm,lightdm,lxdm,slim,sddm}; do
		if test -f /usr/lib/systemd/system/$dm.service; then echo "$dm" ; break; else dm=0; fi
	done
	if [ $dm = 0 ]; then
		## if DM is not found, try to dig in display manager service status.
		## wont work if DM service already disable, but will in case of x server crash.
		echo "$($d_sys show display-manager.service | sed -En "s/^Docu.*=[\"]?.*:(.*)\(.*\)[\"]?/\1/p")"
	fi
}
zen_colors(){ # OK
	# pango colors
	end='</span>'
	v='<span color="'$main'" weight="normal" font="'$size0'" font_family="'$font0'">'	#green
	j='<span color="'$sub'">'			#orange/yellow
	y='<span color="'$log_msg'">'		#cyan/blue
	r='<span color="'$title'">'
	# big red orange title
	rBB='<span color="'$title'" weight="bold" font="20" font_family="'$font1'">'	#red
	# Big
	bf='<span font="'$size1'">'
	nf='<span font="'$size0'">'
	# Bold
	vB='<span color="'$main'" weight="bold" font="'$size0'" font_family="'$font0'">'
	yB='<span color="'$log_msg'" weight="bold" font_family="'$font0'">'
	jB='<span color="'$log_warn'" weight="bold" font_family="'$font0'">'
	gB='<span color="'$log_grn'" weight="bold" font_family="'$font0'">'
	rB='<span color="'$log_err'" weight="bold" font_family="'$font0'">'
	## xterm colors
	xt_colors='-fg '$fg_xterm' -bg '$bg_xterm
	xN='\e[0m'
	xB='\e[1m'
}
### SYSTEM FUNCTIONS
PCI_ID(){ # OK
## graphic cards id
	i=0
	unset pci_n
	vnd_dev_list=( "GeForce" "Titan" "Quadro" "NVS" "Tesla" "GRID" )
	for vnd_list in {10de,8086,1022}; do
		if [[ $($d_lspci -nn|grep VGA|grep -o "$vnd_list:") != '' ]]; then
			if [ $($d_lspci -nn|grep VGA|grep -c "$vnd_list:") = 1 ]; then
				vga_list=$vnd_list
			else
				vga_list=$($d_lspci -nn|grep VGA|grep "$vnd_list"|awk '{print $1}')
			fi
			for pci_list in $vga_list; do
				pci_bus=$($d_lspci -nn|grep VGA|grep "$pci_list"|awk '{print $1}')
				pci_id=$($d_lspci -n|grep "$pci_bus"|sed -n 's/^.*:.*://;s/ .*$//p')
				vnd_nm=$(cat /usr/share/hwdata/pci.ids | sed -n 's/\t/*/g;s/  /#/p'| \
				grep "$vnd_list"|grep -v '*'| sed -n 's/^.*#//p')
				vnd_id=$vnd_list
				detect=$($d_lspci|grep "$pci_bus")
				if [[ $(printf "$detect"| grep -o "GeForce\|TITAN\|Quadro\|NVS\|Tesla\|GRID") != '' ]]; then
					for pci_card in $vnd_dev_list; do
						detected=$($d_lspci|grep "$pci_bus"|egrep -i "$pci_card")
						if [[ "$detected" != '' ]]; then
							dev_nm=$(printf "$detect"|sed -n "s/^.*$pci_card/$pci_card/;s/\( (\|] (\).*$//p")
						fi
					done
				else
					dev_nm=$(printf "Default Graphic")
				fi
				if [[ $pci_bus != '' ]]; then
				# list order : 0>nb, 1>pci slot, 2>pci id, 3>vendor, 4>device_name
					pci_n+=("$i","$pci_bus","$pci_id","$vnd_id","$vnd_nm","$dev_nm")
					((i++))
				fi
			done
		fi
	done
	## pci list: variant.
	# vga_pci_list=( $($d_lspci -nnmm| egrep "\ ()VGA|3D)\ ") )
	IFS=$(echo -en "\n\b")
	pci_dev="${pci_n[*]}"
	pci_dev_nb=$(printf "$pci_dev"|cut -d, -f1)
	IFS=$ifs
	unset dev_n dev slot slot_id vnd vnd_id
	for c in $pci_dev_nb; do
		var="${pci_n[$c]}"
		dev_n+=("$(printf "$var"|cut -d, -f1)")
		dev+=("$(printf "$var"|cut -d, -f6)")
		slot+=("$(printf "$var"|cut -d, -f2)")
		slot_id+=("$(printf "$var"|cut -d, -f3)")
		vnd+=("$(printf "$var"|cut -d, -f5)")
		vnd_id+=("$(printf "$var"|cut -d, -f4)")
	done
	board=$(printf "${pci_n[0]}"| cut -d, -f6)
}
# elf types
libclass(){ # OK
	# define distro base ELF type
	if [[ $HOSTTYPE =~ "64" ]]; then
# 	if [ $(uname - |grep -c "64") -gt 0 ] ; then
		ELF_TYPE="64"
	else
		ELF_TYPE=""
	fi
}
## dependencies control
dep_control(){ # OK
	w_width='400'
	if [ $resolve_dep = 0 ]; then
		if [ $UID = 0 ]; then
			context='--question'
			label='Install'
			info='You need to install them now'
		else
			context='--warning'
			label='Got it'
			info="You need to restart with ${j}Zenvidia (admin)${end} to install them"
		fi
		if [ "${#deplist[*]}" -gt 0 ] ; then
			$d_zen $context --width=$w_width --text="${v}Required dependencies are not met.\n$info.${end}" \
			--window-icon=$img_zen_desktop --ok-label="$label"
			if [ $? = 0 ]&&[ $UID = 0 ]; then
				(
				xterm $xt_options -e "$PKG_INSTALLER $pkg_opts$pkg_cmd ${deplist[*]}; printf \"$esc_message\"; sleep $xt_delay"
				) | $d_zen --progress --pulsate --auto-close --width=$w_width --text="Installing missing dependencies..."
				sed -i "s/resolve_dep=.*/resolve_dep=1/" $script_conf
			else
				exit 0
			fi
		fi
	fi
}
connection_control(){ # OK
	cnx=$(ping -c2 www.nvidia.com)
	cnx=$?
	( if [ $cnx -eq 1 ]; then
		w_text=$( cat <<-MSG
			No internet connection detected.
			A valid network connection is required for any download.
		MSG
		)
		$d_zen --width=300 --window-icon=$img_zen_desktop --error --text="${v}$w_text${end}"
	fi ) | $d_zen --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --progress --pulsate --auto-close \
	--text="${v}Connection control...${end}"
	if [ $cnx = 0 ]; then cnx_msg="OK"; else cnx_msg="NONE"; fi
}
## gcc and other compatibility control
compil_vars(){ # OK
#	if [ -s $install_dir/bin/'nvidia-installer' ]; then
	if [[ -s $d_nv_installer ]]; then
		NV_bin_ver=$($d_nv_installer -v | grep "nvidia-installer"|awk '{print $3}')
	else
		NV_bin_ver='none'
	fi
	if [[ $(gcc --version | grep "gcc") ]]; then
		GCC=$(gcc --version | grep "gcc" | sed -n "s/^.*) //p"| awk '{print $1}')
	else
		GCC='none'
	fi
	KERNEL=$(uname -r)
	OLD_KERNEL=$(ls -1 /lib/modules | sed -n '/'$KERNEL'/{g;1!p};h')
	# xterm default vars and messages.
	primary_dsp=$(xrandr --current| grep -w "connected"| grep primary)
	term_x_dsp=$(printf "$primary_dsp"| grep -o "[0-9]\{3,4\}[x]"|sed -n "s/x//p")
	[ $xt_hold = 0 ]|| x_hold=' -hold'
	if [ $xt_hold = 1 ]; then
		esc_message="$xB\n# Close xterm window to escape.\n$xN"
		x_hold=' -hold'
		x_sleep=''
	else
		esc_message="$xB\n# Terminal will auto-close in $xt_delay seconds.\n$xN"
		x_hold=''
		x_sleep="sleep $xt_delay"
	fi
	xt_options=$xt_colors''$x_hold' -fn 8x13 -geometry 80x24+'$[ ( ($term_x_dsp-660)/2) ]'+0'
#	xt_options=$xt_colors""$x_hold" -fn 8x13 -geometry 80x24+"$( ( ($term_x_dsp-660)/2)$dock )"+0"
}
## define installed driver version, if any
version_id(){ # OK
	if [[ ! $(version) ]]; then
		echo "undefined yet"
	else
		echo $(version)
	fi
}
## If version 'undifined', control if driver is initialy installed.
check_version(){ # OK
	if ! [[ $(version) =~ [0-9]* || $(new_version) =~ [0-9]* ]]; then
		w_text=$( cat <<-ERR
			${j}${bf}Version text file not found.${end}${end}

			Look like driver isn't installed initialy.
			Go to ${y}<b>» Main menu » Install drivers</b>${end} first.
		ERR
		)
		$d_zen --width=300 --window-icon=$img_zen_desktop --error --text="${v}$w_text${end}"
		base_menu
	fi
}
## ### CONFIGURATION ###
xorg_conf(){ # OK
# 	chk_version=$(echo "$(new_version)"| cut -d'.' -f1)
# 	new_version=$(new_version)
	sec_files(){
		if [ $ELF_TYPE -eq 64 ]; then
			ELF=$ELF_64
		else
			ELF=''
		fi
		conf_date=$(date +%D-%T)
		cat <<-XF > $x_conf_dir/xorg.conf.nvidia
			## xorg conf originaly created by $(new_version) nvidia installer.
			## Edited automaticaly by Zenvidia > $conf_date

		XF
		if [ $chk_version -lt 430 ]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "Files"
			   ModulePath "$nv_root/nvidia/xorg/modules"
			   ModulePath "/usr/$master$ELF/xorg/modules"
			EndSection
			XF
		fi
	}
	sec_device(){
		for e in $pci_dev_nb; do
			pci_slot=$(printf "${slot[$e]}"| sed -n "s/^0//;s/:0/:/;s/\./:/p")
			if [[ $(printf "${dev[$e]}"|grep "GeForce\|Quadro\|NVS\|Tesla\|GRID") != '' ]]; then
			cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
				Section "Device"
				   Identifier	"Device${dev_n[$e]}"
				   Driver	"nvidia"
				   VendorName	"${vnd[$e]}"
				   BusID	"PCI:$pci_slot"
				EndSection

			XF
			fi
		done
	}
	sec_option_df(){
	## compute X screen DPI ex : (1080x25.4)/286. From Nvidia Doc formula.
		if [ /usr/bin/xdpyinfo ]; then
			pixel=$(xdpyinfo | grep -B1 "dot"| sed -En "s/^.*([0-9]{4,5})x([0-9]{4,5}).*$/\1;\2/1p")
			milli=$(xdpyinfo | grep -B1 "dot"| sed -En "s/^.*([0-9]{3,4})x([0-9]{3,4}).*$/\1;\2/1p")
			w_pix=$(printf "$pixel"| cut -d';' -f1)
			h_pix=$(printf "$pixel"| cut -d';' -f2)
			w_mil=$(printf "$milli"| cut -d';' -f1)
			h_mil=$(printf "$milli"| cut -d';' -f2)
			## formule
			dpi_w=$(echo "($w_pix*25.4+$w_mil-1)/$w_mil"| bc -l| sed -n "s/\..*$//p")
			dpi_h=$(echo "($h_pix*25.4+$h_mil-1)/$h_mil"| bc -l| sed -n "s/\..*$//p")
			## inclusion
			x_dpi=$dpi_w" x "$dpi_h
		else
			## falback value.
			x_dpi="96 x 96"
		fi
		## get display current def and freq
		x_plore=$(xrandr --current | grep -m1 "*")
		def=$(printf "$x_plore"| awk '{print $1}')
		freq=$(printf "$x_plore"| sed -En "s/.* ([0-9]{2}\.[0-9]{2})\*.*$/\1/g;p")
		freq_prim=$(printf "$freq"| cut -d. -f1)
		freq_scnd=$(printf "$freq"| cut -c 4)
		if [ $freq_scnd -gt 5 ]; then freq=$(($freq_prim+1)); else freq=$freq_prim; fi
		cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			   Option	"NoLogo" "true"
			#   Option	"DPMS"
			   Option	"UseEDID" "true"
			   Option	"ProbeAllGpus" "false"
			#   Option	"UseDisplayDevice" "none"
			#   Option	"ConnectedMonitor" "DFP"
			#   Option	"DynamicTwinView" "false"
			#   Option	"AddARGBGLXVisuals"
			   Option	"SLI" "Off"
			#   Option	"MultiGPU" "Off"
			   Option	"BaseMosaic" "off"
			#   Option	"UseEdidDpi" "false"
			   Option	"Coolbits" "8"
			#   Option	"AllowGLXWithComposite" "true"
			#   Option	"TripleBuffer" "true"
			   Option	"Stereo" "0"
			   Option	"RenderAccel" "true"
			   Option	"DPI" "$x_dpi"
			   Option	"nvidiaXineramaInfoOrder" "DFP-0"
			   Option	"metamodes" "${def}_${freq} +0+0"
			EndSection

		XF
	}
	sec_layout(){
		cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
			Section "ServerLayout"
			   Identifier	"Layout0"
			   Screen 0	"Screen0" 0 0
			#   Option	"AutoAddDevices" "false"
			#   Option	"AutoAddGPU" "false"
			   Option	"Xinerama" "0"
			EndSection

			Section "ServerFlags"
			# allows the server to start up even if the mouse does not work
			   AllowMouseOpenFail
			EndSection

		XF
	}
	sec_screen(){
	cat <<-XF >> $x_conf_dir/xorg.conf.nvidia
		Section "Screen"
		   Identifier	"Screen${dev_n[0]}"
		   Device	"Device${dev_n[0]}"
		   Monitor	"Monitor${dev_n[0]}"
		   DefaultDepth	24

	XF
	}
	x_conf_dir=/etc/X11
	mv -f $x_conf_dir/xorg.conf.nvidia $x_conf_dir/xorg.conf.nvidia.bak
	sec_files
	sec_layout
	sec_device
	sec_screen
	sec_option_df
	ln -sfr $x_conf_dir/xorg.conf.nvidia $x_conf_dir/xorg.conf
}
# ### INSTALL & COMPIL SECTION ###
## TOOLS ###
clean_previous(){ # OK
	echo "# Backing up old kernel driver..."
	if [ -s /lib/modules/$OLD_KERNEL/$(module_dest_location)/nvidia.*[ko\|ko.xz] ]; then
		old_driver=$($d_modinfo -F version /lib/modules/$OLD_KERNEL/$(module_dest_location)/nvidia.*[ko\|ko.xz])
		if [ -s /lib/modules/$OLD_KERNEL/$(module_dest_location)/nvidia.*[ko\|ko.xz] ]; then
			[ -s $nv_root/nvidia.$old_driver/$OLD_KERNEL/nvidia.*[ko\|ko.xz] ]|| \
			cp -f /lib/modules/$OLD_KERNEL/$(module_dest_location)/*.*[ko\|ko.xz] \
			$nv_root/$nvname.$old_driver/$OLD_KERNEL/
		fi
	fi
}
nv_open_modules_set(){ # OK
	# nvidia_installer give the possibility to use open driver version, but not the possibility to choose
	# between open or proprietary version by installing both, or just test open only.
	# let's do it.
	if [ $open_wrn = 1 ]; then
		if [ $extract_open = 1 ]; then
			if [ $use_open -ne 1 ]; then
				_title="Open Modules build selection"
				_text=$(cat <<-MSG
					${jB}Nvidia Open Source Modules${end}
					${vB}Since 515 driver series, it is possible to use nvidia open source drivers
					By default, Zenvidia will build them alongside the main ones.

					AT THIS POINT, OPEN SOURCE DRIVERS WILL BE ONLY BUILD.
					You will be able to switch between version at any time with the ${j}Switch Tool${end}
					in ${j}Configuration and Tools${end} menu (restart Zenvidia is mandatory).

					${j}WARNING ${end}:${v}<i> Open drivers are in still in early state, many features are not
					accessible at this point.
					Check progress in Nvidia Changelog update regulary</i>.${end}

					Do you want to build open source drivers ?${end}
				MSG
				)
				$d_zen --question --window-icon=$img_zen_desktop --title="$_title" --icon-name=dialog-warning --text="$_text" \
				--no-wrap --cancel-label="No" --ok-label="Yes"
				if [ $? = 0 ]; then
					open_drv=1; use_open=0
				else
					open_drv=0; use_open=0
				fi
				sed -Ei "s/^(use_open)=[0-9]$/\1=$use_open/" $basic_conf
				sed -Ei "s/^(open_drv)=[0-9]$/\1=$open_drv/" $basic_conf
				if [ $first_open = 1 ]; then
					_text=$(cat <<-MSG
						${jB}Nvidia Open Source Modules${end}

						${j}WARNING ${end}:${vB}By default, Zenvidia send alert about open driver building,
						If you select ${j}<i>NO</i>${end} here, the previous window won't be displayed again.

						${v}<i>(Choice will be saved in configuration file and could be change)</i>${end}

						Do you want to be warn at each drivers upgrade ?${end}
					MSG
					)
					$d_zen --question --window-icon=$img_zen_desktop --title="$_title" --icon-name=dialog-warning --text="$_text" \
					--no-wrap --cancel-label="No" --ok-label="Yes"
					if [ $? = 0 ]; then
						first_open=0; open_wrn=1
					else
						first_open=0; open_wrn=0
					fi
					sed -Ei "s/^(open_wrn)=[0-9]$/\1=$open_wrn/" $basic_conf
					sed -Ei "s/^(first_open)=[0-9]$/\1=$first_open/" $basic_conf
				fi
			fi
		fi
	fi
	## check for open drivers source dir in tree
	if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
		cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open /usr/src/open-nvidia-$(new_version)
	fi
}
nv_modules_set(){ # OK
	## We don't use Nvidia installer for modules install for a good reason.
	## Nvidia-installer crash or don't give a shit of --no-drm, --no-uvm or --no-xorg-check options.
	## So even this will maybe fix in an update, we don't use it. Too much problems.
	_insert_type=1
	_help_tip=$(cat <<-HLP
		${v}- Unified Memory Module (${j} nvidia-uvm ${end})
		  is required for CUDA driver and application.
		- Prime Sync DRM Module (${j} nvidia-drm ${end})
		  is required for Optimus PRIME modesetting environment.${end}
		If you do not have or intend to use CUDA service and/or Optimus PRIME,
		it is safe to not use them."
	HLP
	)
	## get values from config file.
	if [ $hlp_txt = 1 ]; then _tip=$_help_tip; else _tip=''; fi
	if [ $use_uvm -gt 0 ]; then UVM='TRUE'; else UVM='FALSE'; fi
	if [ $use_drm -gt 0 ]; then DRM='TRUE'; else DRM='FALSE'; fi

	modules_msg=$(cat <<-TXT
		${vB}This is the first time you launch this options sets.

		With the next window you can select the nvidia's drivers type you want/need
		to use and will set the basic configuration file for future builds.
		$_help_tip${end}
	TXT
	)
	# warn about first use.
	if [ $no_warn = 0 ]; then
		$d_zen --question --window-icon=$img_zen_desktop --title="Zenvidia modules set" --icon-name=dialog-warning \
		--text="$modules_msg" --no-wrap --cancel-label="I got it, don't show me this message again" --ok-label="I got it"
		no_warn=$?
		sed -Ei "s/^(no_warn)=[0-9]$/\1=$no_warn/g" $basic_conf
	fi
	_title="Modules build selection"
	_text=$(cat <<-TXT
		${yB}${bf}Nvidia Optional Modules${end}${end}
		${vB}By default Zenvidia will only use the main Nvidia driver.
		You can select here the optional driver as you need.
		$_tip
		Check the appropriate boxes in list below to use optional drivers.${end}
		${v}Note :<i> nvidia-drm is use by default since 515 serie and will be set to 1</i>.

		<i>(Choice will be saved in configuration file and could be change)</i>${end}
	TXT
	)
	## set modprobe.d files
	black_file=/etc/modprobe.d/blacklist.conf
	unset driver_var black_conf modprobe_conf
	driver_var=$($d_zen --width=500 --window-icon=$img_zen_desktop --list --title="$_title" --text="$_text" \
	--column="check" --column="hide" --column="driver" --checklist --multiple --print-column=2 --hide-column=2 \
	--separator=' ' --hide-header \
	$UVM "use_uvm" "Unified Memory Module (nvidia-uvm)" $DRM "use_drm" "Optimus Prime Sync DRM Module (nvidia-drm)")
	## sortie : use_uvm use_drm
	## ATTENTION la valeur TRUE implique l'usage et n'est pas blacklistée.
	## La valeur FALSE implique le non usage et est blacklistée.
	for mod in {use_uvm,use_drm}; do
		if [[ "$driver_var" =~ "$mod" ]]; then
		# don't blacklist or remove from blacklist.
			class=$(printf "$mod"|cut -c4-)
			black_conf+=("$mod;1;nvidia$class")
		else
		# blacklist or add to blacklist.
			VAL=0
			if [ $chk_version -ge 515 ]; then
			## SINCE 515.48 DRM ARE USE BY DEFAULT set is 1.
				if [[ "$mod" == "use_drm" ]]; then
					[ $(grep -c "nvidia$class" $black_file) -gt 0 ]&& VAL=1
				fi
			fi
			class=$(printf "$mod"|cut -c4-)
			black_conf+=("$mod;$VAL;blacklist nvidia$class")
		fi
	done
}
gcc_options(){ # OK
	# test driver code compilator version __GNUC__, __GNUC_MINOR__
	test $(egrep -c "gcc_mismatch" $basic_conf) -gt 0 && (
		if [ $gcc_mismatch = 1 ]; then ignore_mismatch="IGNORE_CC_MISMATCH=1"; else ignore_mismatch=''; fi
		export IGNORE_CC_MISMATCH=$gcc_mismatch
	)
	proc=$(egrep -c "processor.*[0-9]{,2}" /proc/cpuinfo)
}
## PAY ATTENTION : With RT kernel, drivers could install properly but they could also not init at Xorg start.
## Do not ever overwrite current used kernel by RT one.
rt_options(){ # OK
# test if kernel is realtime.
	is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
	if [ $is_RT = 1 ]; then
		## user warning
		_title="Modules build environment"
		_text=$( cat <<-TXT
			${rBB}REALTIME Kernel Detected${end}
			${vB}ATTENTION :${v} You are about to install driver on a realtime kernel.

			Don't forget Nvidia kernel is not normaly made for realtime.
			Troubles init at boot time could happen.
			Think about making a root partition backup if you have no fallback.

			${j}"<b> dd if=/dev/sdxx of=root.img bs=1024k status=progress </b>"${end}
			(from a live usb)

			Do you really want to use compilation over realtime kernel ?${end}${end}
			TXT
		)
		$d_zen --question --window-icon=$img_zen_desktop --icon-name=dialog-warning --no-wrap \
		--cancel-label="Abort" --ok-label="Proceed" --title="$_title" --text="$_text"
		# yes 0, no 1
		if [ $? = 0 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		else
			base_menu
		fi
	fi
}
nv_drv_list(){
	unset _drv_list
	for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
		if [ $(grep -owc "$drv" /etc/modprobe.d/blacklist.conf) -eq 0 ]; then _drv_list+=("$drv"); fi
	done
	echo "${_drv_list[*]}"
}
## vars in functions
## old and new set have to be place as function to be re-used at multi levels.
version(){
	test -f $nvdir/version.txt && cat $nvdir/version.txt || echo "0"
}
new_version(){
	if [ $from_install = 1 ]; then
			if [ "$LAST_PACK" ]; then
				echo "$LAST_PACK"
			else
				echo "$run_pkg" | sed -n 's/^.*-//p'
			fi
	else
		echo "$(version)"
	fi
}
old_version(){
	if [ $from_install = 1 ]; then
		if test -f $tmp_old; then
			cat $tmp_old
		else
			$d_modinfo -F version nvidia -k $KERNEL
		fi
	else
		echo "0"
	fi
}
nv_old(){ echo "$(old_version)"| sed -n "s/\.//g;p"; }
nv_new(){
	if [ "$(new_version)" ]&&[ "$(new_version)" != "0" ]; then
		echo "$(new_version)"| sed -n "s/\.//g;p"
	else
		echo "$(version)"| sed -n "s/\.//g;p"
	fi
}
## initramfs tools detect and config.
initramfs_tools(){
	## try to find 'dracut' first, then fallbback to 'update-initramfs' if not found.
	## look the possibility to add /usr/bin/mkinitcpio -p linux. how-to ?
	## if none are found, disable ramfs rebuild and warn.
	if test $i_sys; then
		echo "$i_sys -f --kver"
	elif test $i_init; then
		echo "update-initramfs -u -k"
	elif test $i_cpio; then
		echo "mkinitcpio -p linux --kernel"
	else
		echo 0
	fi
}
test_ramfs_tool(){
## detect if ramfs tool exist then send to initramfs_warn if none.
	test "$(initramfs_tools)" = 0 && echo 0 || echo 1
}
initramfs_warn(){
	if [ $(test_ramfs_tool) = 0 ]; then
		## send alert
		## and ask to proceed with modprobe reload if initramfs tool is no detected.
		_text=$( cat <<-WRN
			<b>No tool were found to rebuild initramfs</b>
			Modprobe reload could work for the used kernel,
			but probably not for an extra kernel.
			Updated Modules wont probably load at reboot.

			You have been warn !
		WRN
		)
		zenity --question --icon-name=dialog-warning --no-wrap \
		--cancel-label="Abort" --ok-label="Proceed" --title="$_title" --text="${v}$_text${end}"
		if [ $? = 1 ]; then
			exec_mod_tool=0
			base_menu
			#exit 0
		else
			exec_mod_tool=1
		fi
	fi
}
## commands ###
exec_depmod(){
	 if [[ -f /boot/System.map-$1 ]]; then
        /usr/sbin/depmod -a "$1" -F "/boot/System.map-$1"
    else
        /usr/sbin/depmod -a "$1"
    fi
}
exec_mod_load(){
	## from DKMS script (partly)
	# ATTENTION modprobe on device only ?
	nv_pci=$(grep "10de" <<< ${pci_n[*]}|cut -d, -f2 )
	find /sys/devices -regextype sed -regex ".*$nv_pci.*modalias" -print0 | xargs -0 cat | xargs modprobe -b
	# or modprobe on all mandatory ?
	#find /sys/devices -name modalias -print0 | xargs -0 cat | xargs modprobe -a -b -q
	if [ -f /lib/systemd/system/systemd-modules-load.service ]; then
		$d_sys restart systemd-modules-load.service
	fi
}
exec_initramfs(){
## rebuild initramfs if modules reload service found is uselees in the case.
	## progress message is place before fuction exec and formated like this :
	## progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; } for zenity.
	## progress_msg(){ echo -en "\r# ($m%) - Rebuilding INITRAMFS"; } for terminal.
	## last 'echo' is for zenity progress bar only. ex:
	# 	echo "# Updating $KERNEL initramfs."; sleep 2
	# 	progress_msg(){ echo "# ($m%) - Rebuilding INITRAMFS"; echo "$m"; }
	# 	m=1 ;
# 	progress "$INITRAM --kver $KERNEL"; . $tmp_c ; rm -f $tmp_c
# 	progress "dracut --add-drivers $(nv_drv_list) --kver $KERNEL"; . $tmp_c ; rm -f $tmp_c
	progress "$(initramfs_tools) $KERNEL"; . $tmp_c ; rm -f $tmp_c
}
nv_open_switch(){ # OK # TODO remove blank lines ?
	probe_open=/etc/modprobe.d/open-NVIDIA.conf
	kernel_path=/lib/modules/$KERNEL/$(module_dest_location)
	reverse_conf(){
		[ $open_drv -ne $old_open_drv ]&& sed -Ei "s/^(open_drv)=.*$/\1=$old_open_drv/" $basic_conf
		[ $use_open -ne $old_use_open ]&& sed -Ei "s/^(use_open)=.*$/\1=$old_use_open/" $basic_conf
		menu_modif
	}
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -ne $old_use_open ]; then
			if [ $use_open -eq 1 ]; then
				drv_on='open-nvidia'
				drv_off='nvidia'
			else
				drv_on='nvidia'
				drv_off='open-nvidia'
			fi
				confirm_msg=$( cat <<-MSG
					${j}${bf}$drv_on switch${end}${end}
					${v}You are going to switch from ${j}$drv_off${end} to ${j}$drv_on${end}
					Are you sure ?${end}
				MSG
				)
				val_title="Driver Switch" #TEXT
				val_confirm="Yes, switch to $drv_on" #TEXT
				val_back="No, reverse to $drv_off" #TEXT
				val_cancel="reverse_conf" #TEXT
				val_exit="reverse_conf" #EXIT CMD
				win_confirm
				switch_txt="DRIVER SWITCH from DKMS $drv_on build"
			## Switch exec start here
			{	echo "# Switching from $drv_off to $drv_on."
				if [ -d /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module ]; then
					cp -f /var/lib/dkms/$drv_on/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
					echo -e "# Depmod $KERNEL modules ..."
					sleep 2
					progress_msg(){ echo -e "# Depmod $KERNEL modules ($m sec.)"; }
					m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
				else
					## in case of a fresh kernel update, only the predifined type is compile and install by dkms
					## and thus, var/lib/dkms module dir doesn't exist.
					## It is there need to recompile the all stuff
					tmp_b=$(mktemp --tmpdir zn_vars.XXX)
					nv_build_dkms
				fi
				if [[ $drv_on == "nvidia" ]]; then
					license="NVIDIA"
				else
					license="Dual MIT/GPL"
				fi
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "$license" ]]; then
					echo "# License is $license"
				else
					echo "# ERROR!: License is steal $license, reversing all."
					reverse_conf
				fi
				sleep 2
				## add or remove open-driver kernel options.
				if [ $use_open -eq 1 ]; then
					echo "# Set $drv_on kernel options."
					cat <<-CONF > $probe_open
						options nvidia NVreg_OpenRmEnableUnsupportedGpus=1
					CONF
				else
					echo "# Unset $drv_off kernel options."
					[ -f $probe_open ]&& rm -f $probe_open
				fi
				## systemctl restart systemd-modules-load.service
				progress_msg(){ echo "#  - Exec $KERNEL modules reload ($m sec.)"; echo "$m"; } ; m=1; do_slp=1
				exec_mod_load
				sleep 2
				## add no-autoinstall blank file
				touch /etc/dkms/no-autoinstall
				## set DKMS AUTOINSTALL values for each driver type.
				echo "# Set $drv_on DKMS AUTOINSTALL option to \"yes\"."
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/$drv_on-$(version)/dkms.conf
				sed -Ei "s/AUTOINSTALL=\".*\"//" /usr/src/$drv_off-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
				sed -n "s/AUTOINSTALL.*$/*/i;{/^.*\*$/d;s/^\ //i;p}" /usr/src/$drv_off-$(version)/dkms.conf
				## set diplayed license by driver type.
				sleep 2
				echo "# Reboot for $drv_on to take effect."
				sed -Ei "s/^(use_open)=.*$/\1=$use_open/" $basic_conf
			} | $d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia" --progress --pulsate \
			--text="${v}$switch_txt${end}"
		fi
	else
		if [ $open_drv -ne $old_open_drv ]; then
			confirm_msg=$( cat <<-MSG
			${j}${bf}Open Driver removal${end}${end}
			${v}You are going to remove open source driver from driver tree.
			Are you sure ?${end}
			MSG
			)
			val_title="Driver Removal" #TEXT
			val_confirm="Yes, remove" #TEXT
			val_back="No, preserve" #TEXT
			val_cancel="reverse_conf" #TEXT
			val_exit="reverse_conf" #EXIT CMD
			win_confirm
			## remove dkms driver tree.
			{	sleep 2
				echo "# Remove open source drivers from DKMS tree"
				/usr/sbin/dkms remove -m "open-nvidia"/$(version) -all
				sleep 2
				echo "# Restoring default Nvidia drivers."
				cp -f /var/lib/dkms/nvidia/$(version)/$KERNEL/$ARCH/module/* $kernel_path/
				sleep 2
				echo "# Executing depmod"
# 				depmod -a -kver $KERNEL
				progress_msg(){ echo -e "# Depmod $KERNEL modules ($m sec.)"; }
				m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
				sleep 2
				if [[ "$($d_modinfo -F license $kernel_path/nvidia.*[ko\|ko.xz])" == "NVIDIA" ]]; then
					echo "# License is back to NVIDIA"
				else
					echo "# ERROR!: License is still Dual MIT/GPL, abort."
					reverse_conf
					exit 1
				fi
				## remove no-autoinstall blank file
				test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
				echo "# Set Nvidia DKMS AUTOINSTALL option to \"yes\"."
				echo -e "AUTOINSTALL=\"yes\"" >> /usr/src/nvidia-$(version)/dkms.conf
				sed -Ei "s/AUTOINSTALL=\".*\"//" /usr/src/open-nvidia-$(version)/dkms.conf
				## remove blank lines ?
				#sed -n "/^[[:space:]]*$/d;s/^\ //i;p" /usr/src/nvidia-$(version)/dkms.conf
				sed -n "s/AUTOINSTALL.*$/*/i;{/^.*\*$/d;s/^\ //i;p}" /usr/src/nvidia-$(version)/dkms.conf
				sleep 2
				echo "# Unset $drv_off kernel options (if any)."
				[ -f $probe_open ]&& rm -f $probe_open
				sleep 2
				echo "# Set back Configuration file to NVIDIA only."
				sed -Ei "s/^(open_drv)=.*$/\1=0/" $basic_conf
				sed -Ei "s/^(use_open)=.*$/\1=0/" $basic_conf
				sleep 2
				echo "# Reboot for change to take effect."
			} | $d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia driver Switch" --progress --pulsate \
			--text="${v}Open Source Drivers deletion${end}"
		fi
	fi
}
blacklist_nouveau(){ # OK
	grub_cfg=$(find /boot -wholename "*/grub.cfg")
	grub_def=/etc/default/grub
	blacklist='nouveau.modeset=0 rd.driver.blacklist=nouveau'
	drmset='nvidia-drm.modeset'
	## modset var is used by nvidia-drm and nvidia-prime config sets.
	## It's also used by plymouth splash screen to render animation.
	if [ $use_drm = 1 ]; then
		test $drm_modset = 1 && modset=$drmset'=1' || modset=$drmset'=0'
	else
		modset=$drmset'=0'
	fi
	test -f $(user_CF_DIR)/grub-orig && . $(user_CF_DIR)/grub-orig || grub_orig='.* '
	if [ $(grep -c "GRUB_CMD.*nouveau" $grub_def) -gt 0 ]; then
		if [ $(cat $grub_def| egrep -c "^GRUB_CMD.*$blacklist $modset.*$") -eq 0 ]; then
			echo "# - GRUB conf updated (nouveau driver blacklisting and options)."; sleep 2
			## then, replace default env grub with new vars and update grub.cfg.
			sed -Ei "s/^(GRUB_CMD.*)=\"(.*) ($grub_orig.*)$/\1=\"$blacklist $modset \3/" $grub_def
			$d_grub-mkconfig -o $grub_cfg
		fi
	else
		echo "# Create GRUB conf for nouveau driver blacklisting."; sleep 2
		sed -En "s/^GRUB_CMD.*=\"(.*)\"$/grub_orig='\1'/p" $grub_def > $(user_CF_DIR)/grub-orig
		sed -Ei "s/^(GRUB_CMD.*)=\"(.*)$/\1=\"$blacklist $modset\2" $grub_def
		$d_grub-mkconfig -o $grub_cfg
	fi
	## add nouveau blacklist to modeprobe.d configs list.
# 	if ! [[ -s /etc/modprobe.d/blacklist-nouveau.conf ]]; then
	if [ ! -f /etc/modprobe.d/blacklist-nouveau.conf ]; then
		echo "# Update modprobe blacklist for nouveau driver..."; sleep 2
		echo "blacklist nouveau" > /etc/modprobe.d/blacklist-nouveau.conf
	fi
}
nv_blacklist_modules_conf(){
		## set modprobe.d files
		black_file=/etc/modprobe.d/blacklist.conf
		## move to post_install
		if [ ${#black_conf[*]} -gt 0 ]; then
			IFS=$(echo -en "\n\b")
			for mod_sets in ${black_conf[@]}; do
				mod=$(echo "$mod_sets"| cut -d';' -f1)
				used_val=$(echo "$mod_sets"| cut -d';' -f2)
				black_text=$(echo "$mod_sets"| cut -d';' -f3)
				# update basic conf.
				if [ $(grep -c "$mod" $basic_conf) -gt 0 ]; then
					sed -Ei "s/^($class)=[0-9]$/\1=$used_val/g" $basic_conf
				fi
				# update or modifiy blacklist.conf
				if [ $(grep -c "$black_text" $black_file) -gt 0 ]; then
					if [ $used_val -eq 0 ]; then replace="$black_text"; else replace=''; fi
					sed -Ei "s/^$black_text$/$replace/g" $black_file
				else
					if [ $used_val -eq 0 ]; then
						cat <<-CONF >> $black_file
							$black_text
						CONF
					fi
				fi
			done
			IFS=$ifs
			## removed blanck lines from file if any.
			sed -in "/^[[:space:]]*$/d;s/^\ //g" $black_file
		fi
}
## ### AFTER INSTALL ###
clean_old_version(){ # post install part.
	( unset drv_src
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
		fi
		for rep_clean in ${drv_src[*]}; do
			if [ -d /var/lib/dkms/$rep_clean/$(old_version) ]; then
				progress_msg(){ echo "# ($m sec.) - Cleaning $rep_clean $(old_version) DKMS tree"; echo "$m"; }; m=1
				do_slp=1; progress "$p_dkms remove -m nvidia/$(old_version) --all"
			fi
			if [ -d /usr/src/$rep_clean-$(old_version) ]; then
				echo "# - Cleaning $rep_clean $(old_version) SRC tree"; sleep 2
				rm -rf /usr/src/open-nvidia-$(old_version)
			fi
		done
	) | $d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia" --progress  \
		--text="# - Cleaning old $(old_version) source and DKMS tree" --auto-close
}
post_install(){ # OK
	echo "# ($n%) - Post install routines"; sleep 2
	echo "# ($n%) Create XORG config file for Nvidia device"; sleep 2
	xorg_conf # 8
	n=$[ $n+2 ]; echo "$n" # 8
	echo "# ($n%) - Linking $nv_root libs to system"; sleep 2
	n=$[ $n+2 ]; echo "$n" # 9
	if [ ! -s /etc/ld.so.conf.d/nvidia-$master$ELF_TYPE ]; then
		unset elf_lib_list
		elf_lib_list=("$ELF_64" "$ELF_32")
		for nv_lib in "${elf_lib_list[@]}"; do
			ld_conf=$nv_root/nvidia/$master$nv_lib
			[[ $nv_lib == 64 ]]|| nv_lib=32
			nv_lib_file='/etc/ld.so.conf.d/nvidia-'$master$nv_lib'.conf'
			printf "$ld_conf" > $nv_lib_file
		done
		report_log+=("${vB}Post install:\t\t${end}${gB} ldconfig\t\t${end}> ${y}Nvidia librairies linked to system${end}.\n")
	fi
	# libnvidia-wfb.so is broken with old version, need to be replace with xorg server libwfb.so. If exist in nvidia's dirs.
	if [ $chk_version -le 418 ]; then
		## 418 and above don't need nvidia libwfb.so to be replace anymore
		if [ -e $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so ]; then
			mv -f $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so.orig
			ln -sf /usr/$master$ELF_64/xorg/modules/libwfb.so $nv_root/nvidia.$(new_version)/xorg/modules/libwfb.so
			report_log+=("\t\t\t${gB} libwfb\t\t${end}> ${y}link to system${end}.\n")
		fi
	fi
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/install-$new_version.log; fi
	echo "# ($n%) - Fixing broken libs and links if needed"; sleep 2
	elf_lib=( "$master$ELF_64" "$master$ELF_32" )
	## Remove previous version libs if needed.
	unset lib_x
	unset fixed_lib_log
	for lib_X in "${elf_lib[@]}"; do
		for old_lib in {allocator,fbc,cfg,gtk2,gtk3,vulkan-producer,wayland-client}; do
			if [ -s $install_dir/$lib_X/libnvidia-$old_lib.so.$(old_version) ]; then
				rm_lib=libnvidia-$old_lib.so.$(old_version)
				rm -f $install_dir/$lib_X/$rm_lib
				if [ -h $install_dir/$lib_X/libnvidia-$old_lib.so ]||[ -h $install_dir/$lib_X/libnvidia-$old_lib.so.1 ]; then
					rm -f $install_dir/$lib_X/libnvidia-$old_lib.so*
				fi
				fixed_lib+=("$old_lib")
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ "$lib_X" =~ "64" ]]; then lib_x="x86_64"; else lib_x="i386"; fi
			fixed_lib_log+=(" cleaned ($lib_x)\n")
		fi
	done
		## send report from previous list before.
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			for line in ${fixed_lib_log[*]}; do
				report_log+=("\t\t\t${gB} lib fix\t\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
			done
		fi
	## fix gui libraries install if broken
	if [ -d $nvtmp/$extracted_release ]; then
		## fix lib32 prefix libs ?
		if [ $chk_version -lt 520 ]; then
			if [ -d $nvtmp/$extracted_release/32 ]; then
				if [ ! -s $install_dir/$master$ELF_32/libnvidia-fbc.so.$(new_version) ]; then
					r_dir=$install_dir/$master$ELF_32
					cp -f $nvtmp/$extracted_release/libnvidia-fbc.so.$(new_version) $r_dir/
					ln -sfr $r_dir/libnvidia-fbc.so.1 $r_dir/libnvidia-fbc.so
					ln -sfr $r_dir/libnvidia-fbc.so.$(new_version) $r_dir/libnvidia-fbc.so.1
					report_log+=("\t\t\t${gB} libfbc\t\t\t${end}> ${y}link fixed ($nv_lib)${end}.\n")
				fi
			fi
		fi

		## fix lib64 prefix libs links if needed
		unset fixed_lib_log
		r_dir=$install_dir/$master$ELF_64
		## wayland on vulkan libs do not install by default, this not critical.
		## then we inquire for any broken link in install dir.
		## and add any missing libs if needed.
		## wayland libs can broke some software display, thus this is optional.
		[ $wayland_link = 1 ] && wayland=',wayland-client'
		for links in {fbc,cfg,gtk2,gtk3,vulkan-producer$wayland}; do
			if [ ! -e $r_dir/libnvidia-$links.so.$(new_version) ]; then
				cp -f $nvtmp/$extracted_release/libnvidia-$links.so.$(new_version) $r_dir/
			fi
			if [ ! -h $r_dir/libnvidia-$links.so.1 ]; then
				ln -sfr $r_dir/libnvidia-$links.so.1 $r_dir/libnvidia-$links.so
				ln -sfr $r_dir/libnvidia-$links.so.$(new_version) $r_dir/libnvidia-$links.so.1
				fixed_lib_log+=("$links,")
			fi
		done
		if [ ${#fixed_lib_log[*]} -gt 0 ]; then
			if [[ $ELF_64 =~ "64" ]]; then elf_x='(x86_64)'; else elf_x='(i386)'; fi
			fixed_lib_log+=(" links updated $elf_x")
			report_log+=("\t\t\t${gB} link fix\t\t${end}> ${y}old ${fixed_lib_log[@]}${end}.\n")
		fi
	fi
	## FIXME is updating vdpau links to sys is needed even for old version ?
	## symlink libvdpau_nvidia to system
	if [ $chk_version -lt 430 ]; then
		for lib_V in "${elf_lib[@]}"; do
			link_v=$(file -p /usr/$lib_V/vdpau/libvdpau_nvidia.so.1| grep -c "nvidia.$(new_version)")
			if [ $link_v -eq 0 ]; then
				[ -d /usr/$lib_V/vdpau ]|| mkdir -p /usr/$lib_V/vdpau
				ln -sfr /usr/$lib_V/vdpau/libvdpau_nvidia.so /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
				ln -sf $nv_root/nvidia.$(new_version)/$lib_V/vdpau/libvdpau_nvidia.so.$(new_version) /usr/$lib_V/vdpau/libvdpau_nvidia.so.1
			fi
		done
	fi
	n=$[ $n+2 ]; echo "$n" # 10
	## link now all new libraries
	echo "# ($n%) - Validating new librairies (ldconfig)"; sleep 2
	if [ ! -h /usr/share/nvidia ]; then
		rm -f /usr/share/nvidia
		ln -sf -T $install_dir/share/nvidia /usr/share/nvidia
	fi
	ldconfig
	## if driver version greater than 430.xx, backup xorg modules content to default libs dirs. Just in case.
	if [ $chk_version -ge 430 ]; then
		if [ -s $xorg_def/modules/extensions/libglxserver_nvidia.so ]; then
			mkdir -p $nv_root/nvidia.$(new_version)/xorg/modules/{extensions,drivers}
			cp -rf $xorg_def/modules/extensions/libglxserver_* $nv_root/nvidia.$(new_version)/xorg/modules/extensions/
			cp -f $xorg_def/modules/drivers/nvidia_drv.so $nv_root/nvidia.$(new_version)/xorg/modules/drivers/
		fi
	fi
	n=$[ $n+2 ]; echo "$n" # 11
	echo "# ($n%) - Blacklisting and other routines"; sleep 2
	echo "# ($n%) - GRUB conf update if needed"; sleep 2
	blacklist_nouveau
	n=$[ $n+2 ]; echo "$n" # 12
	echo "# ($n%) - Blacklist conf update if needed"; sleep 2
	nv_blacklist_modules_conf
	n=$[ $n+2 ]; echo "$n" # 13
	## clean old install dir
	if [ -d $nv_root/nvidia.$(new_version) ]; then
		if [ -d $nv_root/nvidia.$(old_version) ]; then
			echo "# ($n%) - Cleaning old $(old_version) source and DKMS tree if needed."; sleep 2
			rm -rf $nv_root/nvidia.$(old_version)
			report_log+=("\t\t\t${gB} old version\t\t${end}> ${y}$(old_version) directory cleaned${end}.\n")
# 			[ -d /var/lib/dkms/nvidia/$(old_version) ] && $p_dkms remove -m nvidia/$(old_version) --all
# 			[ -d /var/lib/dkms/open-nvidia/$(old_version) ] && $p_dkms remove -m open-nvidia/$(old_version) --all
# 			[ -d /usr/src/nvidia-$(old_version) ] && rm -rf /usr/src/nvidia-$(old_version)
# 			[ -d /usr/src/open-nvidia-$(old_version) ] && rm -rf /usr/src/open-nvidia-$(old_version)
			clean_old_version
			report_log+=("\t\t\t${gB} old source\t\t${end}> ${y}All $(old_version) version cleaned${end}.\n")
			n=$[ $n+2 ]; echo "$n" # 14
		fi
	fi
}
## COMPIL & COMPIL CONF TOOLS ###
## check for patch in new version.
nv_build_options(){ # OK
	## nvidia build evolve in time, there need to set different options
	## along side versions.
	# define driver file locations
	nv_xorg_dir=$nv_root/nvidia.$(new_version)/xorg
	xorg_def=/usr/$master$ELF_64/xorg
	kernel_path=/lib/modules/$KERNEL/$(module_dest_location)
	no_check='--no-check-for-alternate-installs'
	no_net='-N'
	chk_version=$(echo "$(new_version)"| cut -d'.' -f1)
	[ $use_indirect = 0 ]|| force_glvnd='--force-libglx-indirect'
	[ $use_glvnd = 0 ]|| add_glvnd='--install-libglvnd'
	## since 515 series, open drivers are available. Default is none.
	extract_open=0
	ask_open_build=0
	if [ $chk_version -ge 390 ]; then
		compat32='--compat32-libdir='$master$ELF_32
		compat64='--opengl-libdir='$master$ELF_64
		gl_headers='--opengl-headers'
		no_net=''
	fi
	if [ $chk_version -ge 410 ]; then
		gl_headers=''
	fi
	if [ $chk_version -ge 430 ]; then
		nv_xorg_dir=$xorg_def
	fi
	if [ $chk_version -ge 515 ]; then
		extract_open=1; ask_open_build=1
	fi
}
nv_cmd_dkms_conf(){ # OK
	## check if source dir exit
	chk_dirs(){ [ -d /usr/src/$_src-$(new_version) ]||mkdir -p /usr/src/$_src-$(new_version); }
	## special IGNORE_PREEMPT_RT_PRESENCE script install.
	## add a pre install script for further kernel update through dkms.
	chk_RT(){
		if [ $is_RT -eq 1 ]; then
			if [ ! -e /usr/src/$_src-$(new_version)/nvidia.sh ]; then
				cat <<-SCP > /usr/src/$_src-$(new_version)/nvidia.sh
				#! /bin/bash

				if [ \$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$(uname -r)) -gt 0 ]; then
					export IGNORE_PREEMPT_RT_PRESENCE=1
				fi
				SCP
				chown root:root /usr/src/$_src-$(new_version)/nvidia.sh
				chmod 744 /usr/src/$_src-$(new_version)/nvidia.sh
			fi
		fi
	}
	# Create DKMS conf
	echo "# Create DKMS conf file..."; sleep 1
	## loop between open and private.
	if [ $chk_version -le 355 ]; then
		_src='nvidia'
		chk_dirs
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' KERNEL_UNAME=\${kernelver} modules"
		CLEAN="'make' clean"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"
		EOT
		if [ $use_uvm = 1 ]; then
			cat <<-EOT >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[1]="\${PACKAGE_NAME}-uvm"
			BUILT_MODULE_LOCATION[1]="uvm/"
			DEST_MODULE_LOCATION[1]="/$(module_dest_location)"
			EOT
		fi
	fi
	if [ $chk_version -lt 515 ]; then
		_src='nvidia'
		chk_dirs
		## dkms config part.
		cat <<-EOT > /usr/src/nvidia-$(new_version)/dkms.conf
		PACKAGE_NAME="nvidia"
		PACKAGE_VERSION="$(new_version)"
		AUTOINSTALL="yes"

		MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' IGNORE_CC_MISMATCH='$gcc_mismatch' KERNEL_UNAME=\${kernelver} modules"

		BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
		DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

		EOT
		o=1
		mods_list+=( "uvm" )\r
		mods_list+=( "modeset" )
		mods_list+=( "drm" )
		for mods in ${mods_list[@]}; do
			cat <<-EOT >> /usr/src/nvidia-$(new_version)/dkms.conf
			BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
			DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"
			EOT
			((o++))
		done
	fi
	## test if version support open driver version.
	if [ $chk_version -ge 515 ]; then
		unset drv_src
		if [ $open_drv = 1 ]; then
			drv_src=( open-nvidia nvidia )
		else
			drv_src=( nvidia )
			AUTOINSTALL='AUTOINSTALL="yes"'
		fi
		for _src in ${drv_src[@]}; do
			chk_dirs
			chk_RT
			if [ $open_drv = 1 ]; then
				if [ $use_open = 1 ]; then
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL=''; else AUTOINSTALL='AUTOINSTALL="yes"'; fi
				else
					if [[ $_src == "nvidia" ]]; then AUTOINSTALL='AUTOINSTALL="yes"'; else AUTOINSTALL=''; fi
				fi
			fi
			unset mods_list
			if [ $is_RT -eq 1 ]; then
				PRE_BUILD='PRE_BUILD="nvidia.sh"'
			fi
			cat <<-EOT > /usr/src/$_src-$(new_version)/dkms.conf
			PACKAGE_NAME="nvidia"
			PACKAGE_VERSION="$(new_version)"
			$PRE_BUILD
			$AUTOINSTALL
			MAKE[0]="'make' -j\`nproc\` NV_EXCLUDE_BUILD_MODULES='' \\
			IGNORE_CC_MISMATCH='$gcc_mismatch' \\
			KERNEL_UNAME=\${kernelver} modules $POST_BUILD"

			BUILT_MODULE_NAME[0]="\${PACKAGE_NAME}"
			DEST_MODULE_LOCATION[0]="/$(module_dest_location)"

			EOT
			o=1
			mods_list+=( "uvm" )
			mods_list+=( "modeset" )
			mods_list+=( "drm" )
			for mods in ${mods_list[@]}; do
				cat <<-EOT >> /usr/src/$_src-$(new_version)/dkms.conf
				BUILT_MODULE_NAME[$o]="\${PACKAGE_NAME}-$mods"
				DEST_MODULE_LOCATION[$o]="/$(module_dest_location)"

				EOT
				((o++))
			done
		done
	fi
}
nv_build_dkms(){ # OK
	unset drv_src
	## all script here is inserted in xterm for better display of process.
	## known bug : it appears on unknown reason that DKMS script do not install modules.
	## exploring some solutions, but not sure of them.
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	show_dkms=' (dkms)'
	[ -f $tmp_b ] && echo -e "show_dkms=' (dkms)'" >> $tmp_b
		echo "# Build & install DKMS modules..."; sleep 1
		mod_check(){
		## for an unkonw reason, in some rare case, dkms even if build and install retrun succes doesn't install the drivers.
		## thus, we install those driver manually with cp.
				mod_move=$(
				cat <<-CHECK
					if [ -f nvidia.*[ko\\|ko.xz] ]; then
						printf "${blu}#${red} Error${blu} : No \$_dkms $(new_version) modules found in kernel path $kernel_path.\n${nc}"
						sleep 2
						printf "${blu}# Copying \$_dkms modules in $kernel_path from DKMS repository.\n${nc}"
						#echo -e "moving"
						cp -vf nvidia.ko $kernel_path/nvidia.ko
						if [[ -s nvidia-uvm.ko ]]; then cp -vf nvidia-uvm.ko $kernel_path/nvidia-uvm.ko; fi
						if [[ -s uvm/nvidia-uvm.ko ]]; then cp -vf uvm/nvidia-uvm.ko $kernel_path/nvidia-uvm.ko; fi
						if [[ -s nvidia-modeset.ko ]]; then cp -vf nvidia-modeset.ko $kernel_path/nvidia-modeset.ko; fi
						if [[ -s nvidia-drm.ko ]]; then cp -vf nvidia-drm.ko $kernel_path/nvidia-drm.ko; fi
						echo -e "${pur}- Compressing \$_dkms modules if needed."
						test $is_RT -eq 0 || xz -T12 $kernel_path/*.ko
						if [[ -s $kernel_path/$_dkms.*[ko\\|ko.xz] ]]; then
							echo -e "${pur}- Exec $KERNEL modules depmod"
							sleep 2
							progress_msg(){ echo -en "\\r- Exec $KERNEL modules depmod (\$m sec.)"; }
							m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
						fi
						$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
						pass=\$?
						if [ \$pass = 0 ]; then
							vermagic=\$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\\|ko.xz]| awk '{print \$1}')
							printf "${blu}# All Clear ($(new_version) modules moved from dkms repo)${nc}.\n\n"
							echo -e "pass=\$pass" >> $tmp_b
						else
							printf "${red} ------------- ERROR -------------- ${nc}\n"
							printf "${red} -------- Version mismatch -------- ${nc}\n"
							echo -e "pass=1" >> $tmp_b
						fi
					else
						printf "${red} ------------- ERROR -------------- ${nc}\n"
						printf "${red} ---- Driver not found in path ---- ${nc}\n"
						echo -e "pass=1" >> $tmp_b
					fi

				CHECK
				)
				cat <<-FILTER
					if [ -d /var/lib/dkms/\$_dkms/$(new_version)/$KERNEL/$ARCH/module ]; then
						cd /var/lib/dkms/\$_dkms/$(new_version)/$KERNEL/$ARCH/module
						printf "${pur}# Checking presence in DKMS /$(new_version)/$KERNEL/$ARCH/module${nc}\n"
						$mod_move
					elif [ -d /var/lib/dkms/\$_dkms/$(new_version)/build ]; then
						cd /var/lib/dkms/\$_dkms/$(new_version)/build
						printf "${pur}# Checking presence in DKMS /$(new_version)/build${nc}\n"
						$mod_move
					else
						printf "${pur}# Nothing to do${nc}\n"
					fi
				FILTER
		}
		remove_add(){
			# ATTENTION Remove driver tree only ? or remove all ?
			remove_seq=$(
			cat <<-RM
				#$headings
				printf "${xB}# Removing previous ${red}$(old_version) \$_dkms${nc}${xB} DKMS modules from DKMS tree.\n${nc}"
				sleep 2
				printf "${pur}"
				#echo -e "remove \$_dkms"
				if [ $(nv_old) -gt $(nv_new) ]; then
					$p_dkms remove -m \$_dkms/$(old_version) --all
				else
					$p_dkms remove -m \$_dkms/$(old_version) -k $KERNEL
				fi
				printf "${nc}"
				sleep 2
# 				clear
				RM
			)
			add_seq=$(
			cat <<-ADD
				#$headings
				printf "${xB}# Add ${red}$(new_version) \$_dkms${nc}${xB} modules to DKMS tree.\n${nc}"
				sleep 2
				printf "${pur}"
				#echo -e "add \$_dkms"
				$p_dkms add -m \$_dkms/$(new_version) -k $KERNEL
				printf "${nc}"
				sleep 2
# 				clear
				ADD
			)
			## remove previous known and unknown version if any before installing new one.
			cat <<-SEQ
			#mod_installed=\$(find $kernel_path -name "nvidia.*[ko\\|ko.xz]" -print0 | xargs -0 modinfo -F version)
			mod_installed(){ # used by nv_build_dkms only
				test -d $kernel_path && find $kernel_path -name "nvidia.*[ko\\|ko.xz]" -print0 | xargs -0 modinfo -F version
			}
			old_inst=\$(sed -n "s/\\.//g;p" <<< \$(mod_installed))
			if [ $(nv_old) -gt 0 ]; then
				if [ $(nv_old) = \$old_inst ]; then
					if [ $(nv_old) -ne $(nv_new) ]; then
						$remove_seq
					fi
				fi
			else
				## is the modules version present in dkms tree ?
				if [ "\$old_inst" ]; then
					if [ \$($p_dkms status -m \$_dkms/\$(mod_installed) -k $KERNEL| egrep -c "built|installed") -gt 0 ]; then
						if [[ \$old_inst != $(nv_new) ]]; then
							$remove_seq
						fi
					else
					## if not, just remove them, and make a depmod to clear things.
						if [ \$old_inst -ne $(nv_new) ]; then
							printf "${pur}- Removing out of DKMS tree \$(mod_installed) \$_dkms from kernel modules path.\n${nc}"
							sleep 2
							#echo -e "rm mods"
							rm -f $kernel_path/*
							printf "${pur}- Executing clean depmod before next step.${nc}\n"
							sleep 2
							/usr/sbin/depmod -a $KERNEL
							printf "${pur}- Done.${nc}\n"
							sleep 2
						fi
					fi
				else
					printf "${pur}- No previous driver found. Installing $(new_version) \$_dkms.\n${nc}"
					sleep 2
				fi
			fi
			if [ \$($p_dkms status -m \$_dkms/$(new_version) -k $KERNEL| egrep -c "added|built|installed") -eq 0 ]; then
				$add_seq
			fi
			SEQ
		}
		build_seq(){
			build_seq_1=$(
			cat <<-BLD
			#$headings
			printf "${xB}# Building ${red}$(new_version) \$_dkms${nc}${xB} DKMS modules for $KERNEL:\n${nc}"
			sleep 2
			printf "${pur}"
			#echo -e "build \$_dkms"
			$p_dkms build -m \$_dkms/$(new_version) -k $KERNEL --force
			printf "${nc}"
			printf "${blu}# All Clear for $(new_version) \$_dkms build.${nc}\n"
			printf "${red} --------- \$_dkms script ended ---------- \n\n${nc}"
			sleep 2
# 			clear
			BLD
			)
			build_seq_2=$(
			cat <<-BLD
			#$headings
			printf "${xB}# Build & Install ${red}$(new_version) \$_dkms${nc}${xB} DKMS modules for $KERNEL:\n${nc}"
			sleep 2
			printf "${pur}"
			#echo -e "install classic \$_dkms"
			$p_dkms install -m \$_dkms/$(new_version) -k $KERNEL --force
			printf "${nc}"
			sleep 2
			$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
			pass=\$?
			echo -e "pass=\$pass" >> $tmp_b
			printf "${xB}# Checking ${red}$(new_version) \$_dkms${nc}${xB} modules in $kernel_path:\n${nc}"
			if [ \$pass = 0 ]; then
				echo -e "Check validated (pass=\$pass)\n"
			else
				echo -e "Check unvalidated (pass=\$pass)\n"
			fi
			sleep 2
			if [ \$pass = 1 ]; then
				$(mod_check)
			else
				vermagic=\$($d_modinfo -F vermagic $kernel_path/nvidia.*[ko\\|ko.xz]| awk '{print $1}')
				printf "${blu}# All Clear for $(new_version) \$_dkms in $KERNEL kernel.${nc}\n\n"
				printf "${red} --------- \$_dkms script ended ---------- \n\n${nc}"
				sleep 2
			fi
# 			clear
			BLD
			)
			cat <<-SEQ
			if [[ \$_dkms =~ ^open ]]; then
				if [ $use_open = 0 ]; then
					$build_seq_1
				else
					$build_seq_2
				fi
			elif [[ \$_dkms =~ ^nvidia ]]; then
				if [ $open_drv = 1 ]; then
					if [ $use_open = 0 ]; then
						$build_seq_2
					else
						$build_seq_1
					fi
				else
					$build_seq_2
				fi
			fi
			SEQ
		}
		post_treatment(){
			cat <<-MSG
			printf "${xB}# Checking ${red}$(new_version) \$_dkms${nc}${xB} build log presence.\n${nc}"
			if [ -s /var/lib/dkms/\$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log ]; then
				test -d $nvlog/dkms/\$_dkms/ || mkdir -p $nvlog/dkms/\$_dkms/
				cp -f /var/lib/dkms/\$_dkms/$(new_version)/$KERNEL/$ARCH/log/make.log $nvlog/dkms/\$_dkms/
				dkms_log_file=$nvlog/dkms/\$_dkms/make.log
				echo -e "dkms_log_file=\$dkms_log_file" >> $tmp_b
				printf "${pur}* \$_dkms $(new_version) log found.\n${nc}"
				printf "${pur}* \$_dkms make log copied to \$dkms_log_file.\n${nc}"
			else
				printf "${pur}# No $(new_version) \$_dkms build log found.\n${nc}"
			fi
			if [[ \$_dkms =~ ^open ]]; then sleep 4; else sleep 2; fi
			MSG
		}
		headings="printf \"${xB}# Installing $(new_version) \$_dkms DKMS modules:\n\n${nc}\""
		xt_content=$( cat <<-XT
		#set -x
		for _dkms in ${drv_src[@]} ; do
			#printf "${xB}# Installing ${red}\$_dkms${xB} DKMS modules for $KERNEL :\n\n${nc}"
			$headings
			printf "${red} --------- \$_dkms script start ---------- \n\n${nc}"
			sleep 2
			$(remove_add)
			$(build_seq)
			#$headings
			$(post_treatment)
			[[ \$_dkms =~ ^open ]]&& clear
		done
		printf "$esc_message"
		$x_sleep
		XT
		)
		xterm $xt_options -title Zenvidia_dkms_build -e "$xt_content"
}
nv_cmd_make_src(){ # OK
# 	if [[ $new_version != '' ]]; then version=$new_version; fi
	unset drv_src
	if [ $open_drv = 1 ]; then
		drv_src=( open-nvidia nvidia )
	else
		drv_src=( nvidia )
	fi
	[ -f $tmp_b ]&& echo -e "show_dkms=' (from source)'" > $tmp_b
	mod_check(){
		copy_mods=$(
			cat <<-CHECK
				printf "${xB}# Installing ${red}$(new_version) \$module${nc}${xB} in $kernel_path:\n${nc}"
				sleep 2
				printf "${pur}# Copying \$module modules in $kernel_path.\n${nc}"
				echo -e "* Making $(new_version) \$module module copy."
				cp -f nvidia.ko $kernel_path/nvidia.ko
				if [[ -s nvidia-uvm.ko ]]; then cp -f nvidia-uvm.ko $kernel_path/nvidia-uvm.ko; fi
				if [[ -s uvm/nvidia-uvm.ko ]]; then cp -f uvm/nvidia-uvm.ko $kernel_path/nvidia-uvm.ko; fi
				if [[ -s nvidia-modeset.ko ]]; then cp -f nvidia-modeset.ko $kernel_path/nvidia-modeset.ko; fi
				if [[ -s nvidia-drm.ko ]]; then cp -f nvidia-drm.ko $kernel_path/nvidia-drm.ko; fi
				## compress modules.
				#test $is_RT -eq 0 || xz -T12 $kernel_path/*.ko
				if [ $is_RT -eq 0 ];then
					echo -e "* Compressing $(new_version) \$module for $KERNEL compatibility."
					xz -T12 $kernel_path/*.ko
				fi
				printf "${pur}* Executing depmod.${nc}\n"
				#/usr/sbin/depmod -a -kver $KERNEL
				sleep 2
				#progress_msg(){ echo -en "\\r* Exec $KERNEL modules reload (\$m sec.)"; }
				#m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
				$( exec_depmod "$KERNEL" )
				$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
				pass=\$?
				[ -f $tmp_b ]&& echo -e "pass=\$pass" >> $tmp_b
				printf "${nc}"
			CHECK
		)
		## rebuild initramfs in case of trouble booting.
		cat <<-SEQ
			#if [ -e /usr/src/\$module-$(new_version)/nvidia.ko ]; then
			if [ ! -e /usr/src/\$module-$(new_version)/nvidia.ko ]; then
				printf "${red} ------- $module Compilation done -------- \n${nc}"
				sleep 2
				clear
				$headings
				sleep 2
				if [ $use_open -eq 1 ]; then
					if [[ \$module =~ ^open ]]; then
						$copy_mods
					else
						printf "${xB}# Reserving: Not installing, ${red}$(new_version) \$module${nc}${xB} is not used.\n${nc}"
					fi
				else
					if [[ \$module =~ ^nvidia ]]; then
						$copy_mods
					else
						printf "${xB}# Reserving: Not installing, ${red}$(new_version) \$module${nc}${xB} is not used.\n${nc}"
					fi
				fi
			else
				printf "\n${red} --------------  ERROR  ---------------- \n${nc}"
				printf "${red} --- No modules found in source path --- \n\n${nc}"
			fi
		SEQ
	}
# 	initram(){
# 		cat <<-INI
# 			progress_msg(){ echo "# (\$m%) - Rebuilding INITRAMFS (required)"; echo "\$m"; }; m=1
# 			printf "\n${xB}# Rebuilding INITRAMFS image.${nc}\n"
# 			printf "${pur}"
# 			echo -e "* Making $KERNEL initramfs image."
# 			#$INITRAM --kver $KERNEL
# 			exec_mod_load
# 			printf "${nc}"
# 		INI
# 	}
	post_treatment(){
		cat <<-MSG
		printf "\n${xB}# Checking ${red}$(new_version) \$_dkms${nc}${xB} build log presence.\n${nc}"
		if [ -s /usr/src/\$module-$(new_version)/make.log ]; then
			[ -d $nvlog/source/\$module ]|| mkdir -p $nvlog/source/\$module
			cp -f /usr/src/\$module-$(new_version)/make.log $nvlog/source/\$module
			src_log_file=$nvlog/source/\$module/make.log
			[ -f $tmp_b ]&& echo -e "src_log_file=\$src_log_file" >> $tmp_b
			printf "${pur}* \$module $(new_version) log found.\n${nc}"
			printf "${pur}* \$module make log copied to \$src_log_file.\n${nc}"
		else
			printf "${pur}* No $(new_version) \$module build log found.\n${nc}"
		fi
		if [[ \$module =~ ^open ]]; then sleep 4; else sleep 2; fi
		MSG
	}
	## Compilation start here.
	if [ $upgrade_other = 1 ]; then
		make_env='env KERNEL_UNAME='$KERNEL' KERNEL_SOURCES='$kernel_src
	fi
	if [ $chk_version -lt 355 ]; then
		opts_355="cd uvm/; make clean; make -j$proc; cd ../"
	fi
	headings="printf \"${xB}# Installing from $(new_version) \$module sources:\n\n${nc}\""
	xt_content=$( cat <<-XT
		for module in ${drv_src[@]} ; do
			$headings
			if [ -d /usr/src/\$module-$(new_version) ]; then
				cd /usr/src/\$module-$(new_version)
				printf "${xB}# Build ${red}$(new_version) \$module${nc}${xB} DKMS modules for $KERNEL:\n${nc}"
				printf "${red} ------- \$module compilation start ------- \n${nc}"
				sleep 2
				make clean
				printf "${pur}"
				echo -e "* Making compilation."
				$make_env make -j$proc
				$opts_355
				printf "${nc}"
				sleep 2
				$(mod_check)
				sleep 2
				$(post_treatment)
			else
				echo "\n${xB}# Source ${red}$(new_version) \$module${nc}${xB} unaviable.\n# Check your kernel source three.${nc}"
				[ -f $tmp_b ]&& echo -e "pass=1" >> $tmp_b
			fi
			[[ \$module =~ ^open ]]&& clear
		done
		printf "$esc_message"
		$x_sleep
	XT
	)
	xterm $xt_options -title Zenvidia_source_compilation -e "$xt_content"
}
nv_cmd_install_driver(){ # OK
		## prevent installer to doing think for 'upgrade an other kernel'.
		upgrade_other=0
		if [[ $($d_modinfo -F version nvidia) != $(new_version) ]]; then
			[ -d /usr/src/nvidia-$(new_version) ] ||mkdir -p /usr/src/nvidia-$(new_version)
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel/* /usr/src/nvidia-$(new_version)
			if [ $extract_open = 1 ]; then
				test $ask_open_build -eq 1 && nv_open_modules_set
			fi
			if [ $use_dkms = 1 ]; then
				if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel ]; then
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo "# DKMS compilation ERROR !!"; sleep 2
					fi
				fi
			fi
			if [ $use_dkms = 0 ]; then
				echo "# Nvidia MODULES compilation from source..."; sleep 1
				nv_cmd_make_src
			fi
		else
			[ -f $tmp_b ] && echo -e "pass=1" >> $tmp_b
		fi
}
nv_cmd_update(){ # OK
	driver_logfile=$nvlog/$(new_version)-$KERNEL.log
	tmp_b=$(mktemp --tmpdir zn_vars.XXX)
	## check for for patch in new version.
	rt_options
	nv_build_options
	if [ $extract_open = 1 ]; then
		if [ ! -d /usr/src/open-nvidia-$(new_version) ]; then
			cp -Rf $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)/kernel-open/* /usr/src/open-nvidia-$(new_version)
		fi
	fi
	## check for open modules presence.
	test $ask_open_build -eq 1 && nv_open_modules_set
	if [ $use_dkms = 1 ]; then
		[ $from_install = 1 ] && nv_cmd_dkms_conf
		nv_build_dkms
		. $tmp_b
		make_log=$dkms_log_file
		if [ $pass -eq 1 ]; then
			echo "# DKMS compilation ERROR !!"; sleep 2
		fi
	else
		if [ $use_dkms = 0 ]; then
			echo "# Nvidia MODULES compilation from source..."; sleep 1
			nv_cmd_make_src
			. $tmp_b
			make_log=$src_log_file
		fi
	fi
	if [ $pass -eq 0 ]; then
		## rebuild initramfs in case of trouble booting.
		echo "# Updating $KERNEL modules."; sleep 1
		$d_modinfo -F version nvidia -k $KERNEL | grep "$(new_version)" &>/dev/null
		if [ $? = 0 ] ; then
			if [ $exec_mod_tool = 1 ]; then
				echo "# - Exec $KERNEL modules reload "; sleep 2
				exec_mod_load
			else
				if [ $upgrade_other = 1 ]; then
					progress_msg(){ echo "# - Rebuilding $KERNEL INITRAMFS ($m sec.)"; echo "$m"; }; m=1; do_slp=1
					exec_initramfs
				else
					echo "# - Exec $KERNEL modules reload "; sleep 2
					exec_mod_load
				fi
			fi
		else
			echo "# ERROR ! $KERNEL modules do not match $(new_version). Abort."; sleep 3; exit 0
		fi
 	fi
 	blacklist_nouveau
	install_error_log
}
nv_cmd_install_libs(){ # OK # TODO CHECK REGULARY AT DRIVER UPGRADE
## INFOS ABOUT NVIDIA-INSTALLER OPTIONS :
#  --opengl-prefix=OPENGL-PREFIX
#      The prefix under which the OpenGL components of the NVIDIA driver will be installed; the default is:
#      '/usr'.  Only under rare circumstances should this option be used.  The Linux OpenGL ABI
#      (http://oss.sgi.com/projects/ogl-sample/ABI/) mandates this default value.
# --opengl-libdir=OPENGL-LIBDIR
#      The path relative to the OpenGL library installation prefix under which the NVIDIA OpenGL components will
#      be installed.  The default is 'lib' on 32bit systems, and 'lib64' or 'lib' on 64bit systems, depending on
#      the installed Linux distribution.  Only under very rare circumstances should this option be used.
#  --wine-prefix=WINE-PREFIX
#      The prefix under which Wine components of the NVIDIA driver will be installed.  The default is '/usr'.
#  --wine-libdir=WINE-LIBDIR
#      The path relative to the Wine installation prefix under which Wine components of the NVIDIA driver will be
#      installed.  The default is '<opengl-libdir>/nvidia/wine', where <opengl-libdir> is the path determined for
#      --opengl-libdir above.
#	-b --no-sigwinch-workaround --no-distro-scripts $no_check \	
#	--x-prefix=$xorg_dir --x-module-path=$xorg_dir/modules --opengl-prefix=$croot_all \
#	sh $run_pkg -a $quiet -z -Z --no-x-check --ui=none $unified \
#	--kernel-source-path=$kernel_src --kernel-install-path=$kernel_path  --no-abi-note \
#	sh $run_pkg -s -z -N --no-x-check \
## EXTRA INFOS
#	$nocheck --no-kernel-module --no-opengl-files --skip-module-unload \
#	--no-recursion --opengl-headers --install-libglvnd --glvnd-glx-client --force-libglx-indirect  --opengl-libdir=$master$ELF_64 \
#	--utility-prefix=$install_dir --utility-libdir=$install_dir/$master$ELF_64 \
# 	temp="--tmpdir=$buildtmp"

	cd $nvtmp/NVIDIA-Linux-$ARCH-$(new_version)

	xterm $xt_options -title Zenvidia_install_libs -e "
	$install_bin -s -z $no_net --no-x-check --no-distro-scripts \
	$nocheck --no-kernel-module --skip-module-unload --no-recursion $gl_headers \
	$add_glvnd $force_glvnd --install-compat32-libs \
	--compat32-prefix=$nv_root/nvidia.$(new_version) $compat32 $compat64 \
	--x-prefix=/usr --x-library-path=$nv_root/nvidia.$(new_version) --x-module-path=$nv_xorg_dir/modules \
	--opengl-prefix=$nv_root/nvidia.$(new_version) --wine-prefix=$nv_root/nvidia.$(new_version) --utility-prefix=$install_dir \
	$docs $profile --tmpdir=$buildtmp --log-file-name=$lib_logfile
	printf \"$esc_message\" ; sleep $xt_delay"
	## link to sys.
	cd $nv_root
	ln -sfr -T $nv_root/nvidia.$(new_version) $nv_root/nvidia
}
## ### INSTALL MODULE AND LIBRARIES PROCESS ###
## ### MAIN SECTION ###
install_log_messages(){ # OK
	## install log messages
	if [ $pass -eq 0 ]; then
		echo "# Modules build done."; sleep 1
		report_log+=("${vB}Driver build$show_dkms:\t${end}${gB} success\t\t${end}> ${y}Installation complete with no error${end}\n")
	else
		echo "# Modules build ERROR."; sleep 1
		report_log+=("${vB}Driver build:\t\t${end}${rB} failure\t\t${end}> ${y}ERROR, 'make' exit with 'failed' state${end}\n")
	fi
	## realtime report messages.
	if [ $is_RT -eq 1 ]; then
		report_log+=("\t\t\t${gB} kernel option\t${end}>${y} Kernel $KERNEL is REALTIME${end}.\n")
	fi
	## open driver install report messages.
	if [ $open_drv -eq 1 ]; then
		if [ $use_open -eq 1 ]; then append="open driver loaded"; else append="close source loaded"; fi
		report_log+=("${vB}Open Driver:\t\t${end}$gB compiled\t\t${end}>${y} $append${end}\n")
	fi
}
install_error_log(){ # OK
	if [ $(grep -c "ERROR" $dkms_log_file) -gt 0 ]; then
		# on driver complation break, abort and go back to main menu.
		w_text=$( cat <<-ERR
			${vB}DRIVER INSTALL SEND FATAL ERROR !${end}

			${v}Modules failed to compil.
			Read make log file to know more abor errors.${end}
		ERR
		)
		$d_zen --width=450 --title="Zenvidia" --warning --no-wrap \
		--text="$w_text" --icon-name=xkill --cancel-label="Display Log file" --ok-label="$MM"
		if [ $? = 1 ]; then
			## display log file
			$d_zen --width=700 --height=400 --title="Zenvidia $make_log" --text-info --filename="$make_log"
		fi
		base_menu
	else
		inst_mod_version=$($d_modinfo -F version nvidia -k $KERNEL)
	fi
}
install_report_log(){ # OK
	## display final message depends of exit status.
	$d_zen --title="Zenvidia" --question --no-wrap --window-icon=$img_zen_desktop --width=500 \
	--text="${j}${bf}$(new_version) Install Report${end}${end}${v}:\n $(cat <<< ${report_log[*]})${end}\n$rep_msg" \
	--ok-label="edit now" --cancel-label="edit later"
	if [ $? = 0 ]; then edit_xorg_conf; fi
}
## ### INITIAL OR UPGRADE INSTALL PROCESS ###
install_drv(){ # OK
	## tell script that all post_install process came from global install.
	from_install=1
	## vars for auto confirmation window sets below 'win_confirm'
	confirm_msg="$menu_msg\n${v}Installing driver${end} ${j}$(new_version)${end} ${v}for hardware :${end} ${j}$board${end}."
	val_confirm="Install"
	val_back="$MM"
	val_exit="menu_install"
	val_cancel="base_menu" #TEXT
	val_title="Zenvidia"
	## check for for patch in new version.
	nv_build_options
	rt_options
	## define modules to build at compil/dkms time.
	nv_modules_set
	win_confirm
	# child process doesn't send back install check result, it need to be
		# set in a temp file.
		tmp_b=$(mktemp --tmpdir zn_vars.XXXX)
		# set a second temp file for old-version backup when new modules installed
		tmp_old=$(mktemp --tmpdir zn_vars.XXXX)
		# then push version var in second temp to be used as old-version var during installation.
		echo "$($d_modinfo -F version nvidia -k $KERNEL)" > $tmp_old
	if [[ -s $run_pkg ]] ; then
	{	## set start count
		n=1
		## extract .run package for install processes (22)
		extract_build
		test $tmp_c && . $tmp_c
		echo "$n"
		## check compatiblity files before executng anything. (4)
		hardware_compat
		n=$[ $n+6 ] ; echo "$n" # 1
		## at install only, nvidia-installer is located in temp rep.
		install_bin="./nvidia-installer"
		echo "# ($n%) - Backing up old driver version, if any"; sleep 2
		# backup driver repository (shits happens!)
		unset report_log
		if [ -d $nv_root/nvidia.$(old_version) ]; then
			bak_version=$(old_version)
			if [[ -s $nvbackup/nvidia.$bak_version.tar.gz ]]; then
				report_log+=("${vB}Previous version:\t${end}${gB} passed\t\t${end}> ${y}previously backed up${end}\n")
			else
				backup_old_version
				report_log+=("${vB}backed up:\t${end}${gB} success\t\t${end}> ${y}$bak_version normal backup process${end}\n")
			fi
		else
			report_log+=("${vB}Previous version:\t${end}${jB} warning\t\t${end}> ${y}no directory to archive.${end}\n")
		fi

		n=$[ $n+6 ] ; echo "$n" # 2 ### ?
		## temp value to n
		p=$n
		echo "# ($n%) - Starting install"; sleep 1
		## create base libs install directories
		for d in "$nv_root/$predifined_dir $nv_root/nvidia.$(new_version)/$master$ELF_32 $nv_root/nvidia.$(new_version)/$master$ELF_64 $nv_xorg_dir"; do
			test -d $d || mkdir -p $d
		done
		cd $nv_root
		# nv_cmd processes (install without X crash )
		echo "# ($n%) - Package compil and install"; sleep 1
		# install driver first, then control if everything ok (14 Initramfs)
		( nv_cmd_install_driver ) | $d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia" \
		--progress --pulsate --auto-close --text="${v}DRIVER${end} : Install driver and/or dkms modules."
		. $tmp_b
# 		n=$[ $p+$n ]; echo "$n" # 3 # n=$[ $n+6 ]
		n=$[ $n+6 ]; echo "$n" # 3 # n=$[ $n+6 ]
# 		p=$[ $p+$n ]; n=$p; echo "$n"

		if [ $pass -eq 0 ]; then
		## rebuild initramfs or modprobe reload.
			if [ $exec_mod_tool = 1 ]; then
				echo "# - Exec $KERNEL modules reload "; sleep 2
				exec_mod_load
			else
				progress_msg(){ echo "# ($m%) - Exec $KERNEL modules init/reload"; echo "$m"; }; m=$n; do_slp=1
				exec_initramfs
				. $tmp_c
			fi
# 			if [ $(nv_new) -gt $(nv_old) ]; then
# 				exec_initramfs
# 				. $tmp_c
# 			else
# 				exec_mod_load ; n=$[ $n+20 ]
# 			fi
		fi
		echo "$n"
		install_log_messages
		install_error_log
		# nvidia-installer librairies log file
		lib_logfile=$nvlog/libinstall-$(new_version).log
		## install default libs with nvidia-installer
		echo "# ($n%) - Install Nvidia default librairies"; sleep 1
		( nv_cmd_install_libs ) | $d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia" --progress \
		--pulsate --auto-close --text="${v}LIBRARIES${end} : Extract and install default nvidia libs..."
		## report nvidia installer log message
		if [ $(cat $lib_logfile| grep -c "WARNING") -gt 0 ]; then
			if [ $(cat $lib_logfile| grep "WARNING"| grep -c "libGL.so") -gt 0 ]; then
				report_log+=("${vB}Nvidia-installer:\t${end}${jB} no effect\t\t${end}> ${y}WARNING on missing /usr/lib(32/64)/LibGL.so link,\n\t\t\t\t\t\t    LibGL.so is already link in default nvidia's libraies directory${end}.\n")
			elif [ $(cat $lib_logfile| grep "WARNING"| grep -c "libglvnd") -gt 0 ]; then
				report_log+=("\t\t\t${jB} no effect\t\t${end}> ${y}WARNING missing libglvnd developpement files.${end}\n")
			fi
		fi
		## control if libraries are properly installed
		if [[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| grep -c ".*") -lt 40 ]]|| \
		[[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| grep -c ".*") -lt 40 ]]; then
			$d_zen --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --error --no-wrap \
			--text="${vB}LIBS INSTALL CONTROL RETURN ERRORS.${end}$v.\nCheck $lib_logfile for more details.${end}"
			if [ $? = 0 ]; then base_menu; fi
		else
			report_log+=("${vB}Libraries install:\t${end}${gB} success\t\t${end}> ${y}normal install process${end}.\n")
		fi
		n=$[ $n+6 ]; echo "$n" # 4
		cd $nvtmp
		if [[ -s $nvtmp/$extracted_release/nvidia-installer ]]; then
			echo "# ($n%) - Backup new Nvidia-Installer to $nvdir"; sleep 1
			cp -f NVIDIA-Linux-$ARCH-$(new_version)/nvidia-installer $nvdir
			n=$[ $n+1 ]; echo "$n" # 5
		fi
		echo "# ($n%) - Update new driver version"; sleep 1
		printf "$(new_version)" > $nvdir/version.txt
		n=$[ $n+1 ]; echo "$n" # 6
		# Backup installed binary from release to release dir archive
		if [ ! -f $nvdl/nv-update-$(new_version) ] ; then
			cp -f $run_pkg $nvdl/nv-update-$(new_version)
			if [[ -f $nvdl/nv-update-$(new_version) ]] ; then
				echo "# ($n%) - Driver $(new_version) release package backup success"; sleep 1
			else
				$d_zen --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --error --no-wrap \
				--ok-label="Go it, let's go on."--text="\n${v}Driver ${j}$(new_version)${end} release repos backup mistake.${end}"
			fi
		else
			echo "# ($n%) - nv-update-$(new_version) already present in path, skip"; sleep 1
		fi
		n=$[ $n+2 ]; echo "$n" # 7
		post_install
		echo "99"; sleep 2
		echo "100"
		## Install report display.
		if [[ $inst_mod_version == $(new_version) ]]; then
			if [ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_64| grep -c ".*") -gt 40 ]|| \
			[ $(ls -1 $nv_root/nvidia.$(new_version)/$master$ELF_32| grep -c ".*") -gt 40 ]; then
			rep_msg=$( cat <<-RPT
			${vB}${bf}<i>Congratulations !</i>${end}${end}
			${jB}$(new_version)${end} ${vB}driver is now succefully installed${end}.

			${v}You may now configure your ${j}xorg.conf${end} file to fit with your current default display before restarting
			your computer with the new installed drivers.
			You may also do it later if you like, but it's not really recommanded.

			What do you want to do ?${end}
			RPT
			)
			install_report_log
			fi
		else
			error_log=$(
			cat <<-RPT
				${rB}${bf}Unexpected ERROR.${end}${end}
				${jB}$inst_mod_version isn't $(new_version)${end}.
				Really weird. ${jB}O_o${end} !
				Some unknown bug pops up during driver installation.
				Or developper fucked out something ?
				Can't tell.
			RPT
			)
			$d_zen --window-icon=$img_zen_desktop --width=450 --title="Zenvidia" --error \
 			--text="${v}$error_log${end}"
		fi
		} | $d_zen --window-icon=$img_zen_desktop --width=450 --title="Zenvidia" --progress --percentage=1 --auto-close
		rm -f $tmp_b

	else
		error_log=$(
		cat <<-RPT
			${rB}${bf}Ouch!${end}${end}
			${jB}No proper Nvidia package found in repository${end}.
			Go to the NVIDIA download site :
			${y}http://www.nvidia.fr/Download/Find.aspx?lang=en${end}
			or to NVIDIA ftp repo, here :
			${y}https://download.nvidia.com/XFree86/${end}
		RPT
		)
		$d_zen --window-icon=$img_zen_desktop --width=450 --title="Zenvidia" --error \
		--text="${v}$error_log${end}"
		if [ $? = 0 ]; then base_menu; fi
	fi
}
extract_build(){ # OK
	[ -d $nvtmp ]|| mkdir -p $nvtmp
	[ -d $buildtmp ]|| mkdir -p $buildtmp
	cd $nvtmp
	if [ -d $nvtmp/NVIDIA-Linux-$ARCH-$(new_version) ]; then
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo "# ($n%) - $(new_version) package already extracted"; sleep 2
		n=[ $n+30 ]
	else
		[ ! -d NVIDIA-Linux-$ARCH-* ]|| rm -Rf NVIDIA-Linux-$ARCH-*
		## save dir name for install and post install process.
		extracted_release=NVIDIA-Linux-$ARCH-$(new_version)
		echo "# ($n%) - Primary package extraction"; sleep 2
		progress_msg(){ echo "# ($m%) - Extracting $extracted_release"; echo "$m"; }; m=$n; do_slp=1
		progress "$run_pkg -x" #; . $tmp_c; rm -f $tmp_c
		sleep 1
		if [ "$(new_version)" ]&&[ "$(new_version)" != "$(old_version)" ]; then
			cp -f $nvtmp/$extracted_release/nvidia-installer .
			echo -e "$(new_version)" > $nvdir/new_version.txt
		else
			$d_zen --width=450 --title="Zenvidia" --error \
			--text="${j}${bf}Nvidia repository not found${end}${end}.${v} Extraction failure.${end}"
			base_menu
		fi
	fi
	cd $nvdir
}
hardware_compat(){ # OK
	echo "# ($n%) - Checking compatibility data files"; sleep 2
	## extract supported hardware per version.
	unset COMPAT
	[ -d $nvcompat ]|| mkdir -p $nvcompat
	rdme_file=$nvtmp/$extracted_release/README.txt
	if [ -f $rdme_file ]; then
		IFS=$(echo -en "\n\b")
		COMPAT+=("A1. CURRENT NVIDIA GPUS")
		COMPAT+=("$(egrep "The /*[0-9]{2,4}((.xx)|(..*[0-9]{2,3}.xx))" $rdme_file)")
		for line in ${COMPAT[@]}; do
			if [[ $line =~ ".xx" ]]; then
				drv_class=$(echo -e "$line"| sed -En "s/The (.*).xx .*$/\1/p")
			else
				drv_class="$(new_version)"
			fi
			unset sed_output
			sed_output=( $( sed -En "/$line/,/The *[0-9]{2,4}/p" $rdme_file |\
			sed -n "/------/,/^\ $/p" |\
			sed -n "s/^ /#/g;{s/^#\|^#---.*$//p}") )
			if [[ $drv_class =~ "71.86" ]]; then
				sed -n "/^RIVA/,/Quadro.*$/p" <<< ${sed_output[@]} > $nvcompat/$drv_class
			else
				cat <<< ${sed_output[*]} > $nvcompat/$drv_class
			fi
			class_list+=("$drv_class")
		done
		IFS=$ifs
		## control if device is compatible with new driver
		# vendor is here clearly identified (10de).
		device=$(cat <<< ${pci_n[@]}| grep -i "10de"|cut -d, -f3|sed -n "s/.*/\U&/g;p")
		for comp_file in ${class_list[@]}; do
			if [ $(grep -ic "$device" $nvcompat/$comp_file) -gt 0 ]; then
				if [[ $comp_file =~ "$(new_version)" ]]; then
					if [ $(printf "$comp_file"| sed -n "s/\..*$//p") -gt 304 ]; then
						compat_sup=$(grep -im1 "$device" $nvcompat/$comp_file |\
						sed -En "s/^(.*([a-zA-Z]|[0-9])) .* ($device) .*([A-Z])$/\1;\3;\4/p")
					else
						compat_sup=$(grep -im1 "$device" $nvcompat/$comp_file |\
						sed -En "s/^(.*([a-zA-Z]|[0-9])) .* ($device)$/\1;\3/g;p")
					fi
					echo "# ($n%) - Compatiblity found in $comp_file, proceed to install"; sleep 2
				else
					compat_sup=$(grep -i "$device" $nvcompat/$comp_file |\
					sed -En "s/^(.*([a-zA-Z]|[0-9])) .* ($device).*$/\1 (\3)/p")
					error_log=$(cat <<-ERR
						${rB}${bf}<i>COMPATIBILITY ISSUE</i>${end}${end}
						${v}The ${j}$compat_sup${end} is not compatible with ${j}$(version)${end} driver.
						Look for ${j}$comp_file${end} serie instead.${end}
					ERR
					)
					$d_zen --width=450 --title="Zenvidia" --error --no-wrap \
					--text="$error_log" \
					--icon-name=xkill --ok-label="Got it"
					base_menu
				fi
			fi
		done
	fi
}
## BACKUP & PROGRESS COUNT ###
tar_count(){ # OK
	( eval "$1" &>/dev/null ) & \
	( count_msg )
	m=$(($m+1))
}
progress(){ # OK
	test $tmp_c || tmp_c=$(mktemp --tmpdir zn_count.XXX)
	local exitval=0
	local pid progresspid
	if [[ $1 ]]; then
		eval_pid(){
			on_exit(){
				kill $(jobs -p) 2>/dev/null
				wait $(jobs -p) 2>/dev/null
			}
			trap on_exit EXIT
			while [ -d /proc/$pid ]; do
				( progress_msg )
				sleep $do_slp &
				#test $do_slp = 1 && sleep 1 &
				wait $!
				((m++))
			done
			echo -e "n=$m" > $tmp_c
		}
		( eval "$1" &>/dev/null ) & \
		pid=$! eval_pid & \
		progresspid=$!
		wait $pid 2>/dev/null
		exitval=$?
		kill $progresspid 2>/dev/null
		wait $progresspid 2>/dev/null
   fi
   ## line to paste in global progress count
	#	. $tmp_c ; rm -f $tmp_c
	return $exitval
}
backup_old_version(){ # OK # TO CLEAN ?
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	if [ -d $nv_root/nvidia.$bak_version ]; then
		cd $nvbackup
		## make the archive.
		m=1
		count_msg(){ echo "# ($m%) - Backup : $bak_version tar ball creation"; sleep 1; echo "$m"; }
		do_slp=1; progress_msg(){ echo "# ($m%) - Backup : $bak_version GZIP archive creation"; echo "$m"; }
		tar_count "tar cf nvidia.$bak_version.tar /etc/OpenCL"
		test -e $(grep -C1 /etc/ld.so.conf.d/nvidia-*) && tar_count "tar uf nvidia.$bak_version.tar /etc/ld.so.conf.d/nvidia-*"
		test -f /etc/modprobe.d/open-NVIDIA.conf && tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/open-NVIDIA.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/blacklist-nouveau.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/modprobe.d/blacklist.conf"
		## if backup is create with a use_open var to 1 and the present driver config is different,
		## open-NVIDIA.conf file is not enought to tell the right way of use. User's use_open var must be saved too.
		tar_count "tar uf nvidia.$bak_version.tar /home/$(def_user)/.zenvidia/basic.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf"
		tar_count "tar uf nvidia.$bak_version.tar /etc/X11/xorg.conf.nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-hibernate.service.wants"
		tar_count "tar uf nvidia.$bak_version.tar /etc/systemd/system/systemd-suspend.service.wants"
		tar_count "tar uf nvidia.$bak_version.tar /lib/modules/$KERNEL/$(module_dest_location)/nvidia*"
		tar_count "tar uf nvidia.$bak_version.tar /lib/firmware/nvidia/$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar $nv_root/nvidia.$bak_version"
		tar_count "tar uf nvidia.$bak_version.tar /usr/lib/systemd/system/nvidia-*"
#  		test -d /usr/$master$ELF_32/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
#  		test -d /usr/$master$ELF_64/nvidia && tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
 		[ -d /usr/$master$ELF_32/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_32/nvidia"
 		[ -d /usr/$master$ELF_64/nvidia ]&& tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/nvidia"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/drivers/nvidia_drv.so"
		tar_count "tar uf nvidia.$bak_version.tar /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia*"
		make -C /usr/src/nvidia-$bak_version clean
		tar_count "tar uf nvidia.$bak_version.tar /usr/src/nvidia-$bak_version"
		if [ -d /usr/src/open-nvidia-$bak_version ]; then
			make -C /usr/src/open-nvidia-$bak_version clean
			tar_count "tar uf nvidia.$bak_version.tar /usr/src/open-nvidia-$bak_version"
		fi
		tar_count "tar uf nvidia.$bak_version.tar $install_dir/bin/nvidia-*"
		if [[ $(ls -1 /usr/local/$master$ELF_32/libnvidia-*| grep -c $bak_version) -le 3 ]]; then
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_32/libnvidia-{fbc{.so,.so.1},*.$bak_version}"
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_64/libnvidia-*{.{so,so.1},.$bak_version}"
		else
			tar_count "tar uf nvidia.$bak_version.tar $install_dir/$master$ELF_32/libnvidia-*{.{so,so.1},.$bak_version}"
 		fi
# 		tar_count "tar uf nvidia.$bak_version.tar $install_dir/share/nvidia/nvidia-application-profiles-$bak_version*"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/dkms/nvidia/$bak_version/{source,$KERNEL}"
		tar_count "tar uf nvidia.$bak_version.tar /var/lib/nvidia/{dirs,log}"
		tar_count "tar uf nvidia.$bak_version.tar $nvdir/version.txt"
## compress in gz.
		progress "gzip -c nvidia.$bak_version.tar > nvidia.$bak_version.tar.gz"
		echo "" > $tmp_c
		echo "# Backup: $bak_version GZIP archive created"; sleep 1
		rm -f nvidia.$bak_version.tar
	fi
}
## UPDATE DRIVER SECTION ###
upgrade_new_kernel(){ # OK
	unset kern_list
	up_version=$(version)
	ls_kern=$(ls -1 /boot| grep -v "rescue"| grep "vmlinuz"| sed -n 's/^[[:alpha:]]*-//p')
	for linuz in ${ls_kern}; do
		kern_list+=("false")
		kern_list+=("$linuz")
	done
	w_text=$( cat <<-MSG
		$menu_msg
		${v}Driver install ${j}$up_version${end} for hardware ${j}$board${end}.
		Pick the up to date kernel${end}
	MSG
	)
	NEW_KERNEL=$($d_zen --height=300 --window-icon=$img_zen_desktop --title="Zenvidia" --list --radiolist --hide-header \
	--text "$w_text" --column "1" --column "2" --separator=";" "${kern_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	if [ $(echo -e "$NEW_KERNEL"| egrep -c "[0-9]+") -gt 0 ]; then
		upgrade_kernel
	fi
}
upgrade_kernel(){ # OK
	if [[ $NEW_KERNEL ]];then
		KERNEL=$NEW_KERNEL
	fi
	if [ $upgrade_other = 1 ]; then
		kernel_path="/lib/modules/$KERNEL/$(module_dest_location)/"
		kernel_src="/usr/src$alt/$KERNEL"
	fi
	drv_release=$(ls $nvdl/ | grep "$(new_version)")
	confirm_msg="${v}Kernel update ${j}$KERNEL${end} :$d${end}"
	val_title="Zenvidia"
	val_confirm="$CC"
	val_back="$MM"
	val_cancel="base_menu" #TEXT
	val_exit="base_menu"
	win_confirm
	( echo "# Kernel update $KERNEL ..."
	cd $nvdl/
	nv_cmd_update
	if [ $pass -gt 0 ]||[ ! -e $kernel_path/nvidia.*[ko\|ko.xz] ]; then
		$d_zen --window-icon=$img_zen_desktop --width=450 --title="Zenvidia" --error \
		--text="${j}INSTALL ABORT ABNORMALY, check $(echo "$logfile" | sed -n 's/^.*=//p')${end}."
		exit 0
	fi
	new_version=$(version)
	) | $d_zen --window-icon=$img_zen_desktop --width=450 --title="Zenvidia" --progress --pulsate --auto-close
	if [ -e $nvlog/install.log ]; then cp -f $nvlog/install.log $nvlog/update-$KERNEL.log; fi
	base_menu
}
## FROM A REMOTE/USER DIRECTORY ###
from_directory(){ # OK
	nv_dir(){
		table_opts='--column \"1\" --column \"2\" --separator=\";\"'
		cd $nvdl; n=1
		for local_drv in $(ls -1 $nvdl); do
			list_drv+=("false")
			list_drv+=(" $local_drv")
		done
		drv_pick=$($d_zen --width=450 --height=400 --window-icon=$img_zen_desktop --title="Zenvidia" $zen_opts \
		--text="${j}${bf}Install from stock${end}${end}\n${vB}Driver list in $nvdl :${end}\n$loaded"\
		$table_opts ${list_drv[@]})
		if [ $? = 1 ]; then menu_install; fi
		if [ $? = 0 ]; then
			if [ "$drv_pick" != '' ]; then
				run_pkg=$nvdl/$drv_pick
			else
				from_directory
			fi
		else
			menu_install
		fi
	}
	home_dir(){
		drv_pick=$($d_zen --width=450 --height=400 --window-icon=$img_zen_desktop --title="Zenvidia" --file-selection \
		--filename="$(user_DL_DIR)" --file-filter=".run" \
		--text="${j}${bf}Install from user directory${end}${end}\n${vB}Select a driver from ${j}$(def_user)${end} download directory${end}\n$loaded")
		if [ $? = 1 ]; then menu_install; fi
		if [ $? = 0 ]; then
			if [ "$drv_pick" != '' ]; then
				chmod a+x $drv_pick
				run_pkg=$drv_pick
			else
				from_directory
			fi
		else
			menu_install
		fi
	}
	test $(version) && loaded="${v}<i>($(version) actually installed and loaded)</i>${end}"
	A="Listed versions"
	B="Use a local directory"
	zen_opts='--list --radiolist --hide-header'
	table_opts='--column "1" --column "2" --column "3" --separator=";" --hide-column=2'
	from_cmd=$($d_zen --width=450 --height=400 --window-icon=$img_zen_desktop --title="Zenvidia" $zen_opts \
	--text="${vB}Local NVIDIA drivers list :${end}\n$j$(printf "$(ls $nvdl|sed -n 's/^/\t - /p')")${end}\n${vB}Use one of the listed above or one from the user's directory.${end}" \
 	$table_opts false 1 "$A" false 2 "$B" )
	if [ $? = 1 ]; then base_menu; fi
	case $from_cmd in
		"1") nv_dir ;;
		"2") home_dir ;;
		*) menu_install ;;
	esac
	new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
	install_drv
}
from_net(){ # OK
# download functions
		cd $buildtmp
		download_menu
		run_pkg=$nvdl/nv-update-$LAST_PACK
		if [ -f $buildtmp/$run_pack ]; then
			$d_zen --info --window-icon=$img_zen_desktop --title="Zenvidia" --no-wrap --icon-name=swiss_knife \
			--text="${v}Driver download ${j}$LAST_PACK${end} ended.${end}"
			mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
			chmod 755 $nvdl/nv-update-$LAST_PACK
		fi
		new_version=$(printf "$run_pkg"| sed -n "s/^.*-//g;p")
		install_drv
}
## UPDATED RELEASE CHECK ###
check_update(){ # OK
	( 	wget -q -O $nvtmp/drvlist_0 https://$nvidia_ftp-$ARCH/
		cat $nvtmp/drvlist_0 | sed -En "s/^.*href.*'(.*)\/'>.*$/\1/p" > $nvtmp/drvlist
		rm $nvtmp/drvlist_0
		wget -q -O $nvtmp/last_update https://$nvidia_ftp-$ARCH/latest.txt
		sleep 2
	) | $d_zen --width=400 --window-icon=$img_zen_desktop --title="Zenvidia" --progress --pulsate --auto-close \
	--text="${v}NVIDIA Download center data check${end}"
	LAST_IN=$(version)
	LAST_DRV=$(cat $nvtmp/last_update | awk '{ print $1 }')
	LAST_BETA=$(tac $nvtmp/drvlist | sed -n 1p)
	# compatibilty control
	if [[ $LAST_DRV == $LAST_BETA ]] ; then
			DIFF_list=$LAST_DRV
	else
			DIFF_list="$LAST_DRV $LAST_BETA"
	fi
	w_height=355
	unset dl_allow COMP_L COMP_I
	for DRV in $DIFF_list; do
		## prevent and remove compatibility list first
		if [[ -e $nvtmp/compat.$DRV ]]; then rm -f $nvtmp/compat.$DRV; fi
		(wget -q -O $nvtmp/upt_compat.$DRV https://$nvidia_ftp-$ARCH/$DRV/README/supportedchips.html
		sleep 1
		)| $d_zen --width=400 --window-icon=$img_zen_desktop --title="Zenvidia" --progress --pulsate \
		--auto-close --text="${v}NVIDIA Download center compatibility check (${j}$DRV${end})...${end}"
		## build a list of driver version compatibility for the installed devices.
		for dev_class in ${vnd_dev_list[@]}; do
			if [ $(echo -e "${pci_dev[*]}" |grep -ic "$dev_class") -gt 0 ]; then
				cat $nvtmp/upt_compat.$DRV | grep "<tr\|<td\|</tr>"| \
				perl -n -pe "s|(<(/\|)t[r,d](>\| id=\"))||,s|(\">\|</td>)\n|,|p" | \
				grep -i "$dev_class" >> $nvtmp/compat.$DRV
			fi
		done
		## test existence of the new driver version in remote tree.
		## and prepare optional messages to display.
		if [ $(cat $nvtmp/drvlist| grep -c $DRV) -gt 0 ]; then
			downloadable=1
			dl_allow+=( "1,$DRV" )
			dl_warn=''
		else
			downloadable=0
			dl_allow+=( "0,$DRV" )
			dl_warn='is not downloadable yet and wont be list'
		fi
		for e in $pci_dev_nb; do
			## find and identify isntalled devices in driver version compatibility lists.
			DEV_slot=$(printf "${slot_id[$e]}"| sed -n "s/[a-z]./\U&/g;p")
			DEV_filter=$(cat $nvtmp/compat.$DRV| egrep -i "${dev[$e]}.*$DEV_slot")
			DEV_nm=$(printf "$DEV_filter"|cut -d"," -f2)
			VDPAU=$(printf "$DEV_filter"|cut -d"," -f4)
			## create a list of nvidida devices for lib install fatal log messages.
			if_prev=$(echo "${COMP_I[*]}"| grep -c "$DEV_nm")
			## eval text to display in window message.
			if [[ -n $DEV_filter ]]; then
				if [ $VDPAU != '' ]; then
					comp_v="(VDPAU class $VDPAU)"
				else
					comp_v=""	
				fi
				comp_b="compatible. $comp_v"
				comp_c="${v}fit your hadrware${end}"
				comp_check=0
			else
				comp_b="${vB}is compatible${end}"
				comp_c="${rB}doesn't fit your hadrware anymore${end}"
				comp_check=1
				comp_v=""
			fi
			if [ $if_prev -eq 0 ]; then
				COMP_I+=( "$DEV_nm\n" )
			fi
			if [[ $DEV_filter ]]; then
				COMP_L+=("${j}${dev[$e]}${end} ${v}($DRV), $comp_b${end}")
				COMP_L+=("${j}$DRV${end} $comp_c\n")
				w_height=$(($w_height+30))
			fi
		done
		if [ $downloadable = 0 ];then
			COMP_L+=("${rB}Driver $DRV, $dl_warn${end}")
		fi
		if [ $if_update = 0 ]; then
			dl_warn_msg="${vB}Remote packages list available in next window.${end}"
		fi
	done
	## write it in default script directory for further use.
	echo -e "${COMP_I[@]}" > $nvtmp/compat.update
	sed -in "/^[[:space:]]*$/d;s/^\ //g" $nvtmp/compat.update
	IFS=$(echo -en "\n\b")
	compat_msg=$(cat <<< ${COMP_L[*]})
	IFS=$ifs
	win_update
}
win_update(){ # OK
	## define window messages and display compatibilities.
	in_local=$(ls -1 $nvdl/ | grep -c "$LAST_DRV\|$LAST_BETA")
	if [ $in_local -gt 0 ]; then
		in_offi=$(ls -1 $nvdl/ | grep -c "$LAST_DRV")
		in_beta=$(ls -1 $nvdl/ | grep -c "$LAST_BETA")
	fi
	unset more_msg
	case $in_local in 
		## ↓ if not dowloaded packages are detected, set ui mode to full and process to next 
# 		0) ui_mod=1; extra_msg="\n${v}What do you want to do ?${end}";;
		0) ui_mod=1; end_msg="What do you want to do ?"; w_add='-30';;
		## ↓ if one or more packages are detected, set ui mode to full.
		## Then check if ui mode has to be set differently.
		1)	ui_mod=1
			## ↓ check if last driver is installed and mack it 'installed'. 
			if [[ $LAST_IN == $LAST_DRV ]]; then set_in=" (installed)"; fi
			## ↓ control present packages and choose waht to display.
			for more_drv in {"$in_offi,$LAST_DRV","$in_beta,$LAST_BETA"}; do
				_exist=$(echo "$more_drv"|cut -d',' -f1)
				_drive=$(echo "$more_drv"|cut -d',' -f2)
				case $_exist in
					0) more_msg+=( "\n${j}$_drive${end}${vB} is not in your repository.${end}" ) ;;
					1) more_msg+=( "\n${j}$_drive${end}${vB} is in your repository.${end}${v}$set_in${end}" ) ;;
				esac
			done
			start_msg=$(cat <<< ${more_msg[@]})
			end_msg="What do you want to do ?"
			w_add='+65'
		;;
		## set ui_mod to 0 if offi and beta exist or are the same.
		2) if [[ $in_offi = 1 && $in_beta = 1 ]]; then
				ui_mod=0
				if [[ $LAST_DRV == $LAST_BETA ]]; then
					start_msg="${j}$LAST_DRV${end}${rB}, Official and BETA are in your repository.${end}"
				else
					if [[ $LAST_IN == $LAST_DRV||$LAST_BETA ]]; then
						set_in=" ($LAST_IN installed)"
					fi
					start_msg="${rB}Official and BETA are in your repository $set_in.${end}\n"
					end_msg="Go back to Install menu if needed\n"
				fi
			fi
		;;
	esac
# 	if [ $ui_mod = 1 ]; then w_height=$(($w_height+65)); fi
	extra_msg="\n$start_msg\n${v}$end_msg${end}"
	case $ui_mod in
		0)	w_height=300
			zen_opts='--info --icon-name=swiss_knife '
			table_opts=''
			list_opts='';;
		1)	w_height=$(($w_height$w_add))
			zen_opts='--list --radiolist --hide-header'
			table_opts='--column "1" --column "2" --column "3" --separator=";" --hide-column=2'
			list_opts="false 1 Install false 2 Download ";;
		2)	w_height=300
			zen_opts="--question --ok-label=Install --cancel-label=$R"
			table_opts=''
			list_opts=''
			extra_msg="${v}What do you want to do ?${end}";;
	esac
	w_text=$(cat <<-MSG
		${yB}${bf}Available drivers${end}${end}
		${v}Driver version installed :${end}\t\t${j}$LAST_IN${end}
		${v}The official version is : ${end}\t\t\t${j}$LAST_DRV${end}
		${v}The last bêta is :${end}\t\t\t${j}$LAST_BETA${end}
		$compat_msg
		$dl_warn_msg
		$extra_msg
	MSG
	)
	sel_cmd=$($d_zen --width=450 --height=$w_height --window-icon=$img_zen_desktop --title="Zenvidia" $zen_opts \
	--text="$w_text" $table_opts $list_opts )
	if [ $? = 0 ]; then
		case $ui_mod in
			0) base_menu ;;
			1) case $sel_cmd in
					"1") from_net ;;
					"2") download_only ;;
				esac ;;
			2) from_net ;;
			*) menu_install ;;
		esac
	else
		base_menu
	fi	
}
download_menu(){ ### CHECK ME TODO : Better code ?
	unset DM_list
	dn=1
	if [ $if_update = 1 ]; then
		D1="$LAST_DRV (official)"
		D2="$LAST_BETA (beta)"
	else
		D1="$LAST_DRV (official)"
		D2="$LAST_BETA (beta)"
		D3="Other (old version 3xx.)"
		dl_allow+=( "1,old version" )
	fi
	IFS=$(echo -en "\n\b")
	for drv_ld in {"$D1","$D2","$D3"}; do
		## if ldriver has clearence to download, add it to list.
		## else, don't.
		for allowed in ${dl_allow[@]}; do
			dl_clear=$(echo -e "$allowed"| cut -d',' -f1)
			drv_clear=$(echo -e "$allowed"| cut -d',' -f2)
			if [ $(echo -e "$drv_ld"| grep -c "$drv_clear") -gt 0 ]; then
				if [ $dl_clear = 1 ]; then
					if [ ${#DM_list[@]} -gt 0 ]; then
						list_check=$(echo "${DM_list[*]}"| grep -c "$drv_ld")
					else
						list_check=0
					fi
					if [ $list_check -eq 0 ]; then
						DM_list+=("false")
						DM_list+=("$dn")
						DM_list+=("$drv_ld")
						((dn++))
					fi
				fi
			fi
		done
	done
	IFS=$ifs
	w_height='200'
	dl_cmd=$($d_zen --width=450 --height=$w_height --title="Zenvidia" --window-icon=$img_zen_desktop --list --radiolist \
	--text="${yB}${bf}Downloads${end}${end}\n${v}Select the version to install${end}" --hide-header \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	"${DM_list[@]}" false $dn "$MM" )
	if [ $? = 1 ]; then menu_update; fi
	if [ $if_update = 1 ]; then
		case $dl_cmd in
			"1") LAST_PACK=$LAST_DRV; last_pack ;;
			"2") LAST_PACK=$LAST_BETA; last_pack ;;
			*) menu_update ;;
		esac
	else
		case $dl_cmd in
			"1") LAST_PACK=$LAST_DRV; last_pack ;;
			"2") LAST_PACK=$LAST_BETA; last_pack ;;
			"3") package_list; LAST_PACK=$PICK_DRV; last_pack ;;
			*) menu_update ;;
		esac
	fi
	
}
download_only(){ # OK
	cd $buildtmp
	download_menu
	if [ -f $buildtmp/$run_pack ]; then
		$d_zen --info --window-icon=$img_zen_desktop --title="Zenvidia" --no-wrap --icon-name=swiss_knife \
		--text="${v}Driver download ${j}$LAST_PACK${end} ended.\n$MM${end}"
		mv -f $buildtmp/$run_pack $nvdl/nv-update-$LAST_PACK
		chmod 755 $nvdl/nv-update-$LAST_PACK
		base_menu
	else
		$d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia" --error \
		--text="${v}Driver download ${j}$LAST_PACK${end} failure.\n The package ${j}$run_pack${end} doesn't exist.\n$MM.${end}"
		base_menu
	fi
}
## ### UPDATE FUNCTION, FROM INTERNET. ###
package_list(){ # OK
	unset drv_list
	pck_drv=$(tac $nvtmp/drvlist | egrep -v "^((1.)|(71.)|(96.)|(2.))")
	for line in $pck_drv; do
		drv_list+=("$line")
	done
	PICK_DRV=$($d_zen --width=450 --height=300 --window-icon=$img_zen_desktop --title="Zenvidia" --list --radiolist \
	--text "${yB}${bf}Driver list${end}" --hide-header --column "1" --column "2" --separator=";" \
	"${drv_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
}
last_pack(){ # OK
	track(){
    # picked up & inspired by winetricks download progress commande:
    # Parse a percentage, a size, and a time into $1, $2 and $3
    # then use them to create the output line.
   	perl -p -e "$| = 1; s|^.* +([0-9]+%) +([0-9,.]+[GMKB]) +([0-9hms,.]+).*$|\1\n# $run_pack\t(\1): time left \3\t\2\/s|"
	}
	download_cmd(){
		wget -c https://$nvidia_ftp-$ARCH/$LAST_PACK/$run_pack $buildtmp/ 2>&1
	}
	wget -q -O $nvtmp/bug_list https://$nvidia_ftp-$ARCH/$LAST_PACK/
	if [ -s $nvtmp/bug_list ]; then
		(	cat $nvtmp/bug_list | egrep -o "href='NVIDIA.*[0-9]+.*'"| perl -pe "s/^.*\'(.*)\'/\1/p" \
			> $nvtmp/selector
			sleep 2
		) | $d_zen --width=500 --window-icon=$img_zen_desktop --progress --pulsate --auto-close --text="${v}Remote content control...${end}"
		if [ $(cat $nvtmp/selector | grep -c "$LAST_PACK") -gt 0 ] ; then
			RUN_PACK=$(cat $nvtmp/selector)
		fi
		unset drv_list
		for line in $RUN_PACK; do
			drv_list+=("false")
			drv_list+=("$line")
		done
		run_pack=$($d_zen --width=450 --height=300 --window-icon=$img_zen_desktop --title="Zenvidia" --list \
		--text="${v}Choose the version to install${end}" --radiolist --hide-header \
		--column "1" --column "2" "${drv_list[@]}" --separator=";")
		if [ $? = 1 ]; then exit 0; fi
		( download_cmd | track
		) | $d_zen --width=500 --window-icon=$img_zen_desktop --progress --auto-close --title="driver download $LAST_PACK"
		err=$?
		if test $err -gt 128; then
			if pid=`ps -A | grep ."wget" | awk '{print $1}'`; then
					echo User aborted download, killing wget
					kill $pid
			fi
		fi
		return $err
		_local=$(stat -c "%s" $buildtmp/$run_pack)
		_remote=$(cat $nvtmp/selector | grep -w "$run_pack"|sed -n "/.run$/p"|awk '{print $5}')
		[ $_remote = $_local ]|| {
		$d_zen --height=100 --error --window-icon=$img_zen_desktop --icon-name=xkill --no-wrap \
		--text="${v}Download unexpected end.\nPlease restart driver download from ${vB}Update${end} menu${end}" --ok-label="Heeeh !"
		if [ $? = 0 ]; then base_menu; fi
		}
   else
		$d_zen --width=300 --window-icon=$img_zen_desktop --title="Zenvidia" --warning \
		--text="${rB}$fatal_dev\Remote directory is empty.\n${end}${v}Nvidia devs have probably forgoten to upload data.\nFeel free to try at a later time.${end}"
		base_menu
	fi
}
## TOOLS ###
win_confirm(){ # OK
	## Popup confirmation window to be clomplete with the following vars:
	#	confirm_msg="" #TEXT
	#	val_title="" #TEXT
	#	val_confirm="" #TEXT
	#	val_back="" #TEXT
	#	val_cancel="" #CMD
	#	val_exit="" #EXIT CMD
	confirm_w=$($d_zen --title="$val_title" --window-icon=$img_zen_desktop --list --radiolist \
	--hide-header --text "$confirm_msg\n\n${v}What do you want to do ?${end}" --hide-column "2" \
	--column "1" --column "2" --column "3" --separator=";" \
	false 1 "$val_confirm" false 2 "$val_back")
	if [ $? = 1 ]; then ${val_cancel} ; fi
	case $confirm_w in
		"1") shift ;;
		"2") ${val_exit};;
		*) ${val_cancel};;
	esac
}
win_open_switch(){ # OK
	if [ $open_drv -gt 0 ]; then
		if [ $use_open -gt 0 ]; then OPEN='TRUE'; PROP='FALSE'; else OPEN='FALSE'; PROP='TRUE'; fi
		old_open_drv=$open_drv
		old_use_open=$use_open
		_text=$( cat <<-MSG
			${j}${bf}Driver switch${end}${end}
			${v}Driver type selection (open source / proprietary).
			<i>(driver license $($d_modinfo -F license nvidia -k $KERNEL) loaded)</i>${end}
		MSG
		)
		_title="Zenvidia (tools)"
		driver_swt=$($d_zen --width=500 --list --window-icon=$img_zen_desktop --title="$_title" --text="$_text" \
		--column="check" --column="hide" --column="driver" --radiolist --print-column=2 --hide-column=2 \
		--separator='' --hide-header $PROP "0" "Load proprietary drivers" $OPEN "1" "Load Open Source Drivers")
		if [ $? = 1 ]; then menu_modif; fi
		if [ $? = 0 ]; then
			use_open=$driver_swt
			if [ $use_open -ne $old_use_open ]; then
				nv_open_switch
				menu_modif
			fi
		fi
	fi
}
## PACKAGE MANAGING ###
manage_pcks(){ # OK
	w_height='--height=300'
	hlp_tip=''
	w_text=$( cat <<-MSG

		${v}<b>Manage Drivers Packages</b>:

		<u>Note</u> : <i>In case of issue after restoration (ex: driver not loading),
		try command line tools in first place after reboot.
		Many distro auto reload desktop manger at boot. If you meet this issue,
		you have to disable the desktop manager with systemcl before operating
		with command line</i>.${end}
		MSG
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(cat <<-HLP

		${v}- <b>Remove downloaded packages</b>:
			Manage downloaded packages in Zenvidia directory.
		- <b>Backup tools</b>:
			Make a drivers and librairies backup of the current version.
		- <b>Restore tool</b>:
			Make a restoration of previously backed up drivers installation.${end}
		HLP
		)
		w_height='--height=400'
	fi
	menu_packs=$($d_zen --width=400 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia" \
	--text "${j}${bf}Manage drivers packages${end}${end}$w_text$hlp_tip" \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	false 1 "Remove downloaded package" false 2 "Backup tools" false 3 "Restore a backup")
	if [ $? = 1 ]; then menu_modif; fi
	case $menu_packs in
		"1") remove_pcks ;;
		"2") backup_tools ;;
		"3") restore_pcks ;;
		*) menu_modif ;;
	esac
}
remove_pcks(){ # OK
	# list package in release directory
	unset rm_packs packs_list
	for pack in $(ls -1 $nvdl); do
		packs_list+=("false")
		packs_list+=("$pack")
	done
	w_text=$( cat <<-MSG
		${j}${bf}Remove downloaded package${end}${end}
		Select on or more packages to be removed.
	MSG
	)
	rm_packs=$($d_zen --width=400 --height=300 --window-icon=$img_zen_desktop --list --multiple \
	--checklist --hide-header --title="Zenvidia (remove)" \
	--text "${v}$w_text${end}" \
	--column "1" --column "2" --separator=" " \
	"${packs_list[@]}" )
	if [ $? = 1 ]; then manage_pcks; fi
	w_text=$( cat <<-MSG
		Selected to be removed:
		${j}$rm_packs${end} driver(s).

		Please, confirm.
	MSG
	)
	# check that list not empty before proceed.
	if [[ $rm_packs ]]; then
		$d_zen --width=300 --window-icon=$img_zen_desktop --title="Zenvidia (Remove downloaded package)" --question \
		--text="${vB}$w_text${end}" \
		--ok-label="$CC" --cancel-label="$PM"
		if [ $? = 0 ]; then
			for vers in ${rm_packs[@]}; do
				pack_vers=$(printf "$vers"|sed -n "s/^.*-//g;p")
				vers_ref=$(printf "$pack_vers"|sed -n "s/\.//p")
				ls -d /var/lib/dkms/nvidia/$pack_vers &>/dev/null
				if [ $? = 0 ]; then
					w_text=$(cat <<-INFO
						<b>$pack_vers still exist in DKMS tree</b>.

						Remove all associated package and directory ?
						<i>(All reference in $nv_root will be also removed if found)</i>

						Please, confirm.
					INFO
					)
					$d_zen --width=300 --window-icon=$img_zen_desktop --title="Zenvidia (Remove downloaded package)" --question \
					--text="${v}$w_text${end}"
					if [ $? = 0 ]; then
						if [[ $ver_pack = $ver_txt ]]; then
							w_text=$( cat <<-WRN
							The associated directory you're about to remove is the same as the actually running.
							This action will fataly break ${j}$pack_vers${end} installation
							You don't want to do this.

							Action skipped."
							WRN
							)
							$d_zen --height=100 --window-icon=$img_zen_desktop --title="Zenvidia (Remove downloaded package)" \
							--icon-name=xkill --error --no-wrap --text="${v}$w_text${end}" \
							--ok-label="I understand my mistake"
						else
							test -d $nv_root/nvidia.$pack_vers && rm -Rf $nv_root/nvidia.$pack_vers
							rm -f $nvdl/nv-update-$pack_vers
							$p_dkms remove nvidia/$pack_vers --all
							test -d /var/lib/dkms/open-nvidia/$pack_vers && $p_dkms remove open-nvidia/$pack_vers --all
						fi
					fi
				else
					test -d $nv_root/nvidia.$pack_vers && rm -Rf $nv_root/nvidia.$pack_vers
					test -f $nvdl/nv-update-$pack_vers && rm -f $nvdl/nv-update-$pack_vers
				fi
			done
			$d_zen --height=100 --window-icon=$img_zen_desktop --title="Zenvidia (Remove downloaded package)" \
			--icon-name=swiss_knife --info --text="${vB}Driver(s):\n${j}$rm_packs${end}\npackage(s) removed.${end}" --no-wrap
			manage_pcks
		else
			manage_pcks
		fi
	else
		manage_pcks
	fi
}
remove_baks(){ # OK
	# list package in release directory
	unset rm_bak bak_list
	for back in $(ls -1 $nvbackup); do
		bak_list+=("false")
		bak_list+=("$back")
	done
	w_text=$( cat <<-MSG
		${j}${bf}Remove backed up package${end}${end}
		Select on or more archives to be removed.
	MSG
	)
	rm_bak=$($d_zen --width=400 --height=300 --window-icon=$img_zen_desktop --list --multiple \
	--checklist --hide-header --title="Zenvidia (remove) backups" \
	--text "${v}$w_text${end}" \
	--column "1" --column "2" --separator=" " \
	"${bak_list[@]}" )
	if [ $? = 1 ]; then manage_pcks; fi
	# check that list not empty before proceed.
	if [[ $rm_bak ]]; then
		w_text=$( cat <<-MSG
			Selected to be removed:
			${j}$rm_bak${end} driver(s).

			Please, confirm.
		MSG
		)
		$d_zen --width=300 --window-icon=$img_zen_desktop --title="Zenvidia (Remove backed up package)" --question \
		--text="${vB}$w_text${end}" \
		--ok-label="$CC" --cancel-label="$PM"
		if [ $? = 0 ]; then
			for vers in ${rm_bak[@]}; do
				test -f $nvbackup/$vers && rm -f $nvbackup/$vers
			done
			$d_zen --height=100 --window-icon=$img_zen_desktop --title="Zenvidia (Remove backed up package)" \
			--icon-name=swiss_knife --info --text="${vB}Driver(s) Archive(s) removed.${end}" --no-wrap
			manage_pcks
		else
			manage_pcks
		fi
	else
		manage_pcks
	fi
}
backup_tools(){ # OK
	w_height='--height=130'
	hlp_tip=''
	w_text=$( cat <<-MSG

		${v}Select the driver tool to use.${end}
	MSG
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$( cat <<-INFO

			${v}<b>Make a backup</b> :
			- Back up the current isntalled driver installation.
			<b>Remove a backup</b> :
			- Remove archived installation driver packages.
			${end}
		INFO
		)
	fi
	menu_backup=$($d_zen --width=400 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia" \
	--text "${j}${bf}Backup manager${end}${end}$hlp_tip$w_text" \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	false 1 "Make a backup" false 2 "Remove a backup")
	if [ $? = 1 ]; then menu_modif; fi
	case $menu_backup in
		"1") backup_pcks ;;
		"2") remove_baks ;;
		*) manage_pcks ;;
	esac
}
backup_pcks(){ # OK
	bak_version=$(version)
	if [ -f $nvbackup/nvidia.$bak_version.tar.gz ]; then
		$d_zen --width=250 --height=100 --window-icon=$img_zen_desktop --title="Zenvidia (Backup)" --info \
		--icon-name=swiss_knife --no-wrap \
		--text="${j}$bak_version${end}${v} is already backed up.\nNo reason to do it again.${end}"
		if [ $? = 0 ]; then menu_modif ; fi
	else
		w_text=$( cat <<-WRN
			You are going to backup ${j}$bak_version${end} driver installation
			Please, confirm.
		WRN
		)
		$d_zen --width=250 --height=100 --window-icon=$img_zen_desktop --title="Zenvidia (Backup)" --question \
		--text="${v}$w_text${end}" \
		--ok-label="$CC" --cancel-label="$R"
	fi
	if [ $? = 0 ]; then
		( backup_old_version ) | $d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia" --progress  \
		--text="Backup : $bak_version backup archive creation" --auto-close
		manage_pcks
	else
		manage_pcks
	fi
}
restore_pcks(){ # OK
	nv_build_options
	# list package in release directory
	unset drive_list
	[ -d $nvbackup ]|| mkdir -p $nvbackup
	nv_root_repo=$(ls -1 $nvbackup | grep "nvidia."| sed -n "s/.tar.gz//p")
	for drive in $nv_root_repo; do
		drive_list+=("false")
		drive_list+=("$drive")
	done
	w_text=$( cat <<-MSG
		${j}${bf}Restoration tool${end}${end}
		${v}Choose the driver you want to restore.${end}
	MSG
	)
	drive_packs=$($d_zen --width=400 --height=300 --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia (restore)" \
	--text "$w_text" --column "1" --column "2" --separator=";" \
	"${drive_list[@]}" )
	if [ $? = 1 ]; then manage_pcks; fi
	# check that list not empty before proceed.
	if [[ $drive_packs ]]; then
		res_version=$(printf "$drive_packs"|sed -n "s/nvidia.\([0-9]*\)/\1/p")
		ver_res=$(printf "$res_version"| sed -n "s/\.//g;p")
		ver_mod=$(printf "$(version)"| sed -n "s/\.//g;p")
		old_version=$(version)
		if [ ! -d $nv_root/$drive_packs ]; then
			confirm_msg="${v}Restoring ${j}$res_version${end} will replace actual${end} ${j}$(version)${end}."
			val_title="Zenvidia $b_mod"
			val_confirm="Yes, restore and replace."
			val_back="$PM"
			val_cancel="base_menu"
			val_exit="manage_pcks"
			win_confirm
			## $d_zen window open here.
			{ echo "# Restoring from nvidia.$res_version.tar.gz..."; sleep 2
			if [ "$res_version" != "$(version)" ]; then
				rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$(version)
				rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$(version)
				rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$(version)
			fi
			# p: preserve perm, h: preserve sym, f: file.
			progress_msg(){ echo "# ($m sec.) - Restoring from nvidia.$res_version.tar.gz"; echo "$m"; }
			m=1; do_slp=1;progress "tar -zxf $nvbackup/nvidia.$res_version.tar.gz -C /"; rm -f $tmp_c
			ldconfig
			progress_msg(){ echo "# ($m sec.) - Rebuild modules dependencies (depmod)"; echo "$m"; }
			m=1; do_slp=1 ; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
			## restore or rebuild drivers.
			$d_modinfo -F version nvidia -k $KERNEL | grep "$res_version" &>/dev/null
			if [ $? -eq 1 ]; then
				echo "# Rebuilding missing $res_version drivers for $KERNEL kernel.."
				sleep 2
				version(){ echo $res_version; restore_msg=" (restored)";}
				driver_logfile=$nvlog/$(version)-$KERNEL.log
				tmp_b=$(mktemp --tmpdir zn_vars.XXX)
				rt_options
				if [ -d /usr/src/nvidia-$res_version ]||[ -d /usr/src/open-nvidia-$res_version ]; then
					nv_cmd_dkms_conf
					# Compil and install DKMS modules
					nv_build_dkms
					. $tmp_b
					if [ $pass -eq 1 ]; then
						echo "# FAILURE : DKMS compilation ERROR !!"; sleep 2
						echo "# FAILURE : See 'update modules menu' to force build."; sleep 2
						manage_pcks
					fi
				else
					echo "# FAILURE : No source directory found for $res_version"; sleep 2
					manage_pcks
				fi
			else
				echo "# Clear : $res_version modules checked in $KERNEL kernel."
				sleep 2
			fi
			## rebuild initramfs "in case of"
			progress_msg="Rebuilding INITRAMFS (required)\t\t\t"
			msg_suffix=" sec."
			progress_msg(){ echo "# ($m sec.) - Rebuilding INITRAMFS (required)"; echo "$m"; }; m=1; do_slp=1
			exec_mod_load
			## remove /opt/nvidia.prev_version for compatibility future restore purpose
			rm -Rf $nv_root/nvidia.$(version)
			}| $d_zen --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --progress --pulsate --auto-close \
			--text="${v}Restore driver $res_version and missing modules.${end}"
		else
			# current version overwrite ALERT message
				warning_msg=$( cat <<-WRN
					${jB}Driver install overwrite${end}

					${v}The backup you are going to restore is the same as the one used by the system.

					To prevent data loss when restoring and others ugly deasagrements (like X server crash),
					Zenvidia wont replace the actual install by overwriting ${j}$res_version${end} over itself.

					If you really wish to overwrite, use the command line tool with desktop manager
					service disabled and closed the actual desktop session
					(<i>ex: systemctl disable lightdm.service</i>)${end}
				WRN
				)
				$d_zen --error --title="Zenvidia $b_mod" --icon-name=xkill \
				--text="$warning_msg" --no-wrap --ok-label="Thanks for the advice!"
				base_menu
		fi
	else
		manage_pcks
	fi
	manage_pcks
}
## EDITION TOOLS ###
edit_script_conf(){ # OK
	## build list
	unset conf_list orig_conf cnf_list conf_base conf_chg
	IFS=$(echo -en "\n\b")
	conf_list=( $(cat $basic_conf | sed -En "s/^# (.*):.*/\1/p") )
	for conf_set in "${conf_list[@]}"; do
		cnf_text="$conf_set"
		setted=$(grep -A1 "$cnf_text" $basic_conf | sed -n "2p")
		set_id=$(echo "$setted"|sed -En "s/(.*)=(.*)/\1/p")
		set_val=$(echo "$setted"|sed -En "s/(.*)=(.*)/\2/p")
		if [ $set_val -gt 0 ]; then setted='TRUE'; else setted='FALSE'; fi
		if [ $set_val -gt 1 ]; then extra_val=$set_val; else extra_val=''; fi
		cnf_list+=("$setted")
		cnf_list+=("$cnf_text")
		cnf_list+=("($set_id)")
		cnf_list+=("$set_val")
		cnf_list+=("$extra_val")
		cnf_list+=("#")
		orig_conf+=("($set_id);$set_val;$extra_val")
	done
	help_tip="${v}\nDefine options and functions you would like to use\n${end}"
	w_height='--height='500
	conf_base=$($d_zen --width=550 $w_height --window-icon=$img_zen_desktop --list \
	--multiple --editable --checklist --title="Zenvidia" \
	--text "${j}${bf}Zenvidia Configuration${end}$help_tip${end}" \
	--column "Set" --column "Definition" --column "Conf Set" --column "4" --column "Extra" \
	--column "6" --hide-column=4,6 --print-column=3,4,5,6 \
	--separator=";" \
	"${cnf_list[@]}" )
	## output : use help tip;hlp_txt;0;cairo;1;28 etc
	if [ $? = 1 ]; then base_menu; fi
	IFS=$ifs
	## split ouput in readable list
	## and remove blank lines.
	conf_orig=( $orig_conf )
	conf_chg=( $(echo -e "${conf_base[*]}"|sed -n "s/#/\n/g;p"|sed -n "s/^;\|;$//g;p"|\
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p") )
	## check open_drv setiing before changinf anything
	if [ $open_drv ]; then
		old_open_drv=$open_drv
		if [ $use_open ]; then old_use_open=$use_open; fi
	fi
	## modify new set value.
	for output in ${conf_chg[@]}; do
			set=$(echo "$output"| cut -d';' -f1| sed -n "s/(\|)//g;p")
			value=1
			bis_value=$(echo "$output"| cut -d';' -f3)
			if [[ "$bis_value" ]]&&[[ "$bis_value" != '' ]]; then value=$bis_value; fi
			if [ $(egrep -c "$set=$value" $basic_conf) -eq 0 ];then
				sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
				if [[ $set == "use_open" ]]; then export use_open=$value; fi
			fi
	done
	## modifiy unset value.
	for input in ${orig_conf[@]}; do
		if [ $(grep -c "$input" <<< ${conf_chg[@]}) -eq 0 ]; then
			set=$(echo "$input"| cut -d';' -f1| sed -n "s/(\|)//g;p")
			value=0
			bis_value=$(echo "$input"| cut -d';' -f3)
			if [[ "$bis_value" ]]&&[[ "$bis_value" != '' ]]; then value=$bis_value; fi
			if [[ $set != 'xt_delay' ]]; then
				if [ $(egrep -c "$set=$value" $basic_conf) -eq 0 ];then
					sed -Ei "s/^($set)=.*$/\1=$value/" $basic_conf
					if [[ $set == "use_open" ]]; then export use_open=$value; fi
				fi
			fi
		fi
	done
	## if open_drv is change, DKMS autoinstall boot time command has to be change by adding the blank file
	## 'no-autoinstall' in /etc/dkms directory. Method seems to work without issue except for package manager
	## udpate program that apprently need 'autoinstall all' to be set (fedora here).
	if [ $open_drv -ne $old_open_drv ]; then
		if [ $open_drv = 1 ]; then
			touch /etc/dkms/no-autoinstall
		else
			test -f /etc/dkms/no-autoinstall && rm -f /etc/dkms/no-autoinstall
		fi
	fi
	## if use_open is change, then apply open/close source switch.
	if [ $use_open -ne $old_use_open ]; then
		w_text=$( cat <<-WRN
			${jB}Driver Switch${end}
			${vB}Open driver settings have been change.

			Do you want to apply now ?${end}
		WRN
		)
		$d_zen --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --question --no-wrap \
		--text="$w_text" --icon-name=xkill --cancel-label="No, I'll apply later" --ok-label="Yes, apply"
		if [ $? = 0 ]; then
			nv_open_switch
		fi
	fi
	## then go back to Section Menu.
	menu_modif
}
edit_color_conf(){ # OK
	## color tmep file test preview
	color_TMP=$(mktemp --tmpdir nv_color.XXXX)
	cat $color_conf > $color_TMP
	edit_color_gui(){
		test_text=$(
		cat <<-SPL
			DISPLAY PREVIEW :
			${rBB}TITLE${end}
			${j}${bf}Sub TTILE${end}${end}
			TEXT, main and alternate text :
			${v}Once upon a time in south west ? I don't care !${end}.
			${y}But I can alternate between Est and West,
			but I still don't care ...${end}.
			LOGS :
			${vB}Command cleared${end}\t\t${gB}passed${end}\t> ${y}log message values.${end}
			${vB}Command issue warning${end}\t${jB}warning${end}\t> ${y}log message values.${end}
			${vB}Command non fatal error${end} ${rB}error${end}\t\t> ${y}log message values.${end}
		SPL
		)
		w_text=$(
		cat <<-TXT
			${j}${bf}Basic font colors and style${end}${end}
			${v}Change GUI font colors to fit your desktop theme.${end}
		TXT
		)
		sample=$(
		cat <<-SPL
			${rBB}TITLE${end}\t${j}${bf}Sub TTILE${end}${end}
			${v}main text${end} ${y}Log messages${end}
			${gB}Log cleared${end} ${jB}Log warnings${end} ${rB}Log Errors${end}
		SPL
		)
		w_tip=$(
		cat <<-TIP
			${j}NOTICE${end}${v}: Colors will appled immediatly after validation.
			Do not forget Xterm only support a limited type of colors.${end}
		TIP
		)
		style1=$(egrep -io "[a-z]*$" <<< $font1)
		style0=$(egrep -io "[a-z]*$" <<< $font0)
		font_color=$(
		$d_yad --width=300 --height=300 --title "Zenvidia" --center \
			--window-icon=$img_zen_desktop --text "$w_text" \
			--button='Abort:1' --button='Preview;;Reload with newly setted values:2' --button='Done:0' \
			--form --separator="|" --item-separator=";" --borders=15 --field="":LBL '' \
			--field="${v} Title and warning messages font color${end}":CLR "$title" \
			--field="${v} Sub window title font color${end}":CLR "$sub" \
			--field="${v} Main window font color\t\t${end}":CLR "$main" \
			--field="${v} Log message font color\t\t${end}":CLR "$log_msg" \
			--field="${v} Log clear font color\t\t${end}":CLR "$log_grn" \
			--field="${v} Log warning font color\t\t${end}":CLR "$log_warn" \
			--field="${v} Log error font color\t\t${end}":CLR "$log_err" \
			--field="${v} Sub Titles font type${end}":FN "$font1 $style1 $size1" \
			--field="${v} Normal font type${end}":FN "$font0 $style0 $size0" \
			--field="":LBL '' \
			--field="${v} Xterm forground color${end}":CLR "$fg_xterm" \
			--field="${v} Xterm background color${end}":CLR "$bg_xterm" \
			--field="":LBL '' \
			--field="$test_text":LBL '' \
			--field="":LBL '' \
			--field="$w_tip":LBL ''
		)
		out=$?
		if [ $out = 0 ]; then
			menu=menu_modif
		elif [ $out = 1 ]; then
			base_menu
		elif [ $out = 2 ]; then
			menu="$@ edit_color_gui"
		fi
		if [ $out -eq 2 ]; then
			color_base=$color_conf
			color_conf=$color_TMP
		else
			if [ $color_base ]; then
				color_conf=$color_base
			fi
		fi
		IFS=$(echo -en "\n\b")
		unset input_colors output_colors output_conf
		input_colors=$(cat $color_conf | cut -d'=' -f1)
		output_colors=( $(echo -e "$font_color"| sed -En "s/^\||[\|]{3}$//g;s/\|/\n/g;p") )
		C=0
		for type in ${input_colors[@]}; do
			if [[ $type =~ font* ]]; then
				font_n=$(echo "$type"| grep -o "[0-9]")
				eval style=\$'style'$font_n
				new_font=$(echo "${output_colors[$C]}"|egrep -io ".*[a-z]")
				new_style=$(echo "$new_font"|awk '{print $3}')
				if [[ $new_style == '' ]]; then stylish=' '$style; else stylish=''; fi
				output_conf+=("$type;$new_font$stylish")
				shift 0
			elif [[ $type =~ size* ]]; then
				output_conf+=("$type;$(echo "${output_colors[$C]}"|egrep -o "[0-9].*$")")
				((C++))
			else
				output_conf+=("$type;${output_colors[$C]}")
				((C++))
			fi
		done
		for sets in ${output_conf[@]}; do
			setting=$(printf "$sets"| cut -d';' -f1)
			value=$(printf "$sets"| cut -d';' -f2)
			if [ $(grep -c "$setting='$value'" $color_conf) -eq 0 ]; then
				sed -Ei "s/^($setting)=.*$/\1='$value'/g" $color_conf
			fi
		done
		IFS=$ifs
		if [ $out -eq 2 ]; then
			. $color_conf
			zen_colors
		fi
		${menu}
	}
	if [ $d_yad ]; then
		edit_color_gui
	fi
}
edit_xorg_conf(){ # OK
	xorg_cfg=/etc/X11/xorg.conf.nvidia
	hlp_tip=$(
	cat <<-HLP
	${v}Edit or manage Xorg options.${end}

	HLP
	)
	menu_xorg=$($d_zen --width=400 --height=100 --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia" \
	--text "${j}${bf}Edit Xorg Config File${end}${end}\n$hlp_tip" \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	TRUE 1 "Edit full Xorg config file" FALSE 2 "Manage Device Options only")
	if [ $? = 1 ]; then
		if [ $from_install = 0 ]; then menu_modif; fi
	fi
	case $menu_xorg in
		"1") edit_xorg_full_text ;;
		"2") edit_xorg_options ;;
	esac
}
edit_xorg_options(){ # OK
	unset options options_list options_orig options_new options_old
	IFS=$(echo -en "\n\b")
	options=$(sed -En '/Section "Screen"/,/EndSection/p' $xorg_cfg| grep "Option")
	for line in ${options[@]}; do
		if [[ $line =~ \#.*$ ]]; then setted='FALSE'; else setted='TRUE'; fi
		option=$(printf "$line"| sed -En "s/^.*Option\t(\".*\") (\".*\")$/\1/p"|sed -n "s/\"//g;p")
		if [ ! $option ]; then
			option=$(printf "$line"| sed -En "s/^.*Option\t(\".*\")$/\1/p"|sed -n "s/\"//g;p")
		fi
		value=$(printf "$line"| sed -En "s/^.*Option\t(\".*\") (\".*\")$/\2/p"|sed -n "s/\"//g;p")
		options_list+=("$setted")
		options_list+=("$option")
		options_list+=("$value")
		options_list+=("#")
		options_orig+=("$option;$value")
	done
	hlp_tip=$(
	cat <<-HLP
	${v}Select/unselect options you need.

	Options added manually will be displayed here also.${end}

	HLP
	)
	w_height='--height='500
	options_conf=$($d_zen --width=550 $w_height --window-icon=$img_zen_desktop --list \
	--multiple --editable --checklist --title="Zenvidia" \
	--text "${j}${bf}Zenvidia Configuration${end}${end}\n${v}$hlp_tip${end}" \
	--column "Set" --column "Option" --column "Set" \
	--column "4" --hide-column=4 \
	--print-column=2,3,4 \
	--separator=";" \
	"${options_list[@]}" )
	if [ $? = 1 ]; then edit_xorg_conf; fi
	options_old=( $(echo -e "${options_orig[*]}") )
	options_new=( $(echo -e "${options_conf[*]}"|sed -n "s/#/\n/g;p"|sed -n "s/^;\|;$//g;p"|\
	sed -n "/^[[:space:]]*$/d;s/^\ //i;p") )

	## modify new set value.
	for output in ${options_new[@]}; do
			output_set=$(echo "$output"| cut -d';' -f1)
			value=$(echo "$output"| cut -d';' -f2)
			if [[ "$value" ]]; then reg_val=' (\".*\")' ; opt_val=" \"$value\""; else reg_val=''; opt_val=''; fi
			if [ $(grep -c "^#.*$output_set" <<< $options ) -gt 0 ]|| \
			[ $(grep -c "$output_set.*$value" <<< $options) -eq 0 ]; then
				sed -Ei "s/^[#]?(.*Option\t\"$output_set\")$reg_val/\1$opt_val/" $xorg_cfg
			fi
	done
	## modifiy unset value.
	for input in ${options_orig[@]}; do
		input_set=$(echo "$input"| cut -d';' -f1)
		value=$(echo "$input"| cut -d';' -f2)
		if [ $(grep -c "$input_set" <<< $options_conf) -eq 0 ]; then
			if [ $(egrep -c "#.*Option.*\"$input_set\"" $xorg_cfg) -eq 0 ];then
				if [[ "$value" ]]; then reg_val=' (\".*\")' ; opt_val=" \"$value\""; else reg_val=''; opt_val=''; fi
				sed -Ei "s/^(.*Option\t\"$input_set\")$reg_val/#\1$opt_val/" $xorg_cfg
			fi
		fi
	done
	IFS=$ifs
	edit_xorg_conf
}
edit_xorg_full_text(){ # OK
	edit_xorg=$($d_zen --width=500 --height=400 --window-icon=$img_zen_desktop --title="Zenvidia" --text-info --editable \
	--text="${v}Edit xorg config file${end}" --filename="$xorg_cfg" \
	--checkbox="Confirm to overwrite" )
	if [[ $(printf "$edit_xorg"| sed -n '1p') != '' ]]; then
		printf "$edit_xorg\n" > $xorg_cfg
	fi
	if [ $? = 0 ]; then edit_xorg_conf; fi
}
edit_distro_conf(){ # OK
	## warn about no config file
	w_text=$(cat <<-WRN
	${j}<b>You are going to modify $plug_version configuration file</b>${end}

	Variables and datas from this file are very sensitives and could potentialy
	breaks Zenvidia.

	Are you sure about what you are doing ?
	WRN
	)
	$d_zen --width=450 --window-icon=$img_zen_desktop --title="Zenvidia" --question --no-wrap \
	--text="${vB}$w_text${end}" --ok-label="I live dangerously" --cancel-label="Well, I'm finally a coward"
	if [ $? = 1 ]; then menu_modif; fi
	## edit config file.
	edit_plug_conf=$( $d_zen --width=640 --height=400 --window-icon=$img_zen_desktop --title="Zenvidia $plug_version edition" \
	--text-info --editable --filename="$(user_CF_DIR)/$plug_conf" \
	--checkbox="Confirm to overwrite" --cancel-label="Abort (panic button)" --ok-label="Write")
	if [ $? = 0 ]; then
		echo -e "$edit_plug_conf" > $(user_CF_DIR)/$plug_conf
	else
		menu_modif
	fi
}
read_help(){ # OK
	$d_yad --width=680 --height=400 --title="Zenvidia" --window-icon=$img_zen_desktop --button="yad-close" \
	--center --text-info --formatted < $zen_docs/HELP.txt
	menu_manage
}
read_about(){ # OK
	$d_yad --width=680 --height=400 --title="Zenvidia" --window-icon=$img_zen_desktop --button="yad-close" \
	--center --text-info --formatted < $zen_docs/README.txt
	menu_manage
}
read_nv_help(){ # OK
	IFS=$(echo -en "\n\b")
	w_height='--height=500'
	if [[ ${#chapter_index[@]} -le 1 ]]; then
		unset chapter_index chapters_list
		chapters_list=$(sed -En "/TABLE OF.*$/,/1A. ABOUT.*$/p" $help_pages/README.txt | sed -n "/^___.*$/,/^___.*$/p"| egrep "^Chapter|^Appendix")
		for chapter in ${chapters_list[@]}; do
			chapter_index+=("FALSE")
			chapter_index+=("$chapter")
		done
	fi
	## display index first
	index=$( $d_zen --width=550 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --title="Zenvidia" \
	--text "${j}${bf}Nvidia Documentation ${end}$help_tip${end}" \
	--column=" " --column "Chapters" \
	"${chapter_index[@]}" )
	if [ $? -eq 1 ]; then base_menu; fi
	if [ "$index" != '' ]; then
		chap_start=$(printf "$index"| sed -n "s/(.*)//g;p")
		## then if chapter tag is not empty, dispaly chapter.
		chap_end=$(egrep -A1 "$chap_start" <<< $chapters_list | sed -n 2p | sed -n "s/(.*)//g;p")
		chap_brief="$chap_start : "$(sed -En "/^$chap_start/,/^$chap_end/p" $help_pages/README.txt | sed -En "/^____/,/^____/p")
		$d_zen --width=600 --height=400 --title="Zenvidia" --text-info \
		--ok-label="Back to index" --cancel-label="Exit to main" \
		cat <<< "$chap_brief"
		if [ $? -eq 1 ]; then menu_manage; else read_nv_help; fi
		IFS=$ifs
 	else
		IFS=$ifs
		menu_manage
 	fi
}
read_changelog(){ # OK
	unset entry_list entrylog_list
	IFS=$(echo -en "\n\b")
	w_height='--height=500'
	relist_title=''
	brief(){
		if [ $(echo -e "$log_brief"| grep -c .) -gt 0 ]; then
			log_brief=$( cat <<-BRIEF
			Nvidia changelog ( $entrylog ) :
			$(cat $help_pages/NVIDIA_Changelog | \
			sed -En "/$entrylog/,/$log_end/p"| \
			sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
			BRIEF
			)
		else
			log_brief=$(echo -e "Nvidia changelog ( $entrylog ) :\n\nNothing to display here.\n\nLog file empty.")
		fi
			$d_zen --width=600 --height=400 --title="Zenvidia" --window-icon=$img_zen_desktop --text-info \
			--ok-label="Back to list" --cancel-label="Exit to menu" \
			cat <<< "$log_brief"
			if [ $? -eq 1 ]; then
				menu_manage
			else
				if [[ $relist_title != '' ]]; then
					relist
				else
					relist_title=''
					read_changelog
				fi
			fi
	}
	relist(){
		if [[ $relist_title != '' ]]; then
			cancel_btn='--cancel-label=Back to list'
		else
			cancel_btn='--cancel-label=Back to menu'
		fi
		if [[ ${#entrylog_list[@]} -le 1 ]]; then
			for log_line in ${entry_list[@]}; do
				entrylog_list+=("FALSE")
				entrylog_list+=("$log_line")
			done
		fi
		entrylog=$( $d_zen --width=550 $w_height --window-icon=$img_zen_desktop --list \
		--radiolist --title="Zenvidia" \
		--text "${j}${bf}Nvidia Change Logs list $relist_title${end}${end}" $cancel_btn \
		--column=" " --column "Versions" \
		"${entrylog_list[@]}" )
		if [ $? -eq 1 ]; then
			if [[ $relist_title != '' ]]; then
				read_changelog
			else
				menu_manage
			fi
		else
			if [ "$entrylog" != '' ]; then
			log_end=$(egrep -A1 "$entrylog" <<< $entry_list| sed -n 2p)
			log_list=$(cat $help_pages/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
			sed -n "s/^===.*$//g;p")
				if [[ $relist_title != '' ]]; then
					log_brief=$(cat $help_pages/NVIDIA_Changelog | sed -En "/$entrylog/,/$log_end/p"| \
					sed -En "s/^[0-9]{,4}-.*$//p;s/====.*$//p;s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}")
					brief
				else
					log_brief=$(cat <<< $log_list | sed -En "s/^[ ]{3}//g;{/^\ *$/d;s/^\ //i;p}" )
				fi
			else
				menu_manage
			fi
		fi
	}
	entry_list=$(egrep -e "=====" $help_pages/NVIDIA_Changelog | sed -En "s/[ ]?={8}[ ]?//g;p")
	relist
	if [[ $log_list =~ .*[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
		unset entry_list entrylog_list
		entry_list=$(cat <<< $log_list | egrep ".*[0-9]{4}-[0-9]{2}-[0-9]{2}"|sed -En "s/ ([0-9]{4})/\n\1/g;p" )
		relist_title=": ${y}$entrylog${end}"
		relist
	else
		relist_title=''
		brief
	fi
	IFS=$ifs
}
nv_config(){ # OK
	[ -x $d_nv_settings ] && \
	gpu_set=$($d_nv_settings -q gpus | grep -i "nvidia" | sed -En "s/^.*\[gpu:([0-9])\].*(\(.*\)).*$/GPU \1 - \2/g;p")
	$su_cmd "$(def_user)" $d_nv_settings -p "$gpu_set"
	menu_modif
}
zen_notif_setup(){
	setup_validation(){
		notif=$($d_zen --height=100 --window-icon=$img_zen_desktop --title="Zenvidia notification" --question --no-wrap \
		--text="${vB}Autostart launcher set to ${j}$_notif${end}${end}" \
		--ok-label="Ok" --cancel-label="$PM")
		if [ $? = 1 ]; then menu_modif; fi
		sed -Ei "s/(Exec=zen_notify) -[a-z]/\1 $_set/" $desk_file
		menu_modif
	}
	desk_file=/home/$(def_user)/.config/autostart/zen_notify.desktop
	unset setup_list setup_option c_set_list
	setup_option=(
	"Check driver update only;driver check only;n"
	"Check zenvidia and driver update;driver and zenvidia check;z"
	)
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$( cat <<-HLP

		${v}<i>You can leave it as it is or choose between
		one of the sets below</i>.${end}
		HLP
		)
		w_height='--height=350'
	else
		hlp_tip=''
		w_height='--height=300'
	fi
	st=1
	c_set_opt=$(cat $desk_file |grep "Exec"| perl -p -e "s|^.*-+([a-z])|\1|")
	for n_set in "${setup_option[@]}"; do
		m_set=$(printf "$n_set"|cut -d';' -f1)
		c_set=$(printf "$n_set"|cut -d';' -f2)
		o_set=$(printf "$n_set"|cut -d';' -f3)
		setup_list+=("false")
		setup_list+=("$st")
		setup_list+=("$m_set")
		if [[ $o_set == $c_set_opt ]]; then c_set_cnf=$c_set; fi
	done
	w_text=$(cat <<-MSG
		${j}${bf}Notifications config${end}${end}
		${vB}Notification is currently set to:
		> ${j}$c_set_cnf${end}${end}
	MSG
	)
	menu_notif=$($d_zen --width=400 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia notification" --text "$w_text$hlp_tip" \
	--column "1" --column "2" --column "3" --hide-column=2 \
	"${setup_list[@]}")
	if [ $? = 1 ]; then menu_modif; fi
	case $menu_notif in
		"1") _set='-n'; _notif="driver check only" ;;
		"2") _set='-z'; _notif="driver and zenvidia check" ;;
		*) menu_modif ;;
	esac
	setup_validation
}
### SUB MENU ###
menu_install(){
	unset install_list ins_cmd ins_list
	if [ $hlp_txt = 1 ]; then
		hlp_tip="\n$hlp_01b"
		hlp_tip=$( cat <<-HLP

		${vB}Select the install type${end}
		   - ${vB}From a local package${end}:
		   Install a new driver from a user directory local package
		   or a listed already downloaded with zenvidia.
		   - ${vB}From Nvidia server${end}:
		   Will display the full drivers list from the Nvidia server.
		   Install and download will be executed in the next step.
		HLP
		)
		w_height='--height=300'
	else
		hlp_tip="\n${vB}Select here the install type${end}"
		w_height='--height=200'
	fi
	install_list=("From a local package" "From NVIDIA server")
	n=1
	for ins_cmd in "${install_list[@]}"; do
		ins_list+=("false")
		ins_list+=("$n")
		ins_list+=("$ins_cmd")
		n=$[ $n+1 ]
	done 
	menu_inst=$($d_zen --width=400 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia" \
	--text "${j}${bf}Install new drivers${end}${end}${v}$hlp_tip${end}" \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	"${ins_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	case $menu_inst in
		"1") menu_msg="${vB}NVIDIA package update from local dir. ${end}"; from_directory ;;
		"2") menu_msg="${vB}NVIDIA package from NVIDIA server.${end}"; ui_mod=2; check_update ;;
		*) base_menu ;;
	esac
}
menu_update(){
	check_version
	if [ $hlp_txt = 1 ]; then
		w_height='--height=450'
		hlp_tip=$(cat <<-HLP

		<b>Select here the element to update or install</b>
		- <b>Driver upgrade</b>
		   Check for new driver update.
		   You can select during the process to download only or install directly.
		   If <i>download only</i> is chosen, for installation afterward
		   go back to : » ${j}main${end} menu » ${j}Install Drivers${end}
		   <u>Note</u> : All download are stored.
		- <b>Update driver only (dkms)</b>
		   Install nvidia dkms modules for a new running kernel.
		- <b>Update driver only (force)</b>
		   Optional command to force install from driver sources in case of
		   DKMS failure.
		- <b>Update driver for an other kernel (dkms)</b>
		   Optional command to update nvidia modules for an other kernel.
		HLP
		)
	else
		hlp_tip=''
		w_height='--height=300'
	fi
	nu=1
	if [ $hlp_txt = 0 ]; then hlp_tip="\n${vB}\Select here the element to update or install${end}"; fi
		if [ $use_dkms = 1 ]; then
			up_cmd_list=("Driver upgrade" "Update driver only (dkms)" "Update driver only (force)" "Update driver for an other kernel (dkms)")
		else
			up_cmd_list=("Driver upgrade" "Update driver only" "Update driver for an other kernel")
		fi
	unset up_list
	for up_cmd in "${up_cmd_list[@]}"; do
		up_list+=("false")
		up_list+=("$nu")
		up_list+=("$up_cmd")
		nu=$[ $nu+1 ]
	done 
	menu_upd=$($d_zen --width=400 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia" \
	--text "${j}${bf}Update Drivers or kernel modules${end}${end}${v}$hlp_tip${end}" \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	"${up_list[@]}" )
	if [ $? = 1 ]; then base_menu; fi
	git_tmp=$(mktemp --tmpdir nv_git.XXXX)
	home=/home/$(def_user)
	if [ $use_dkms = 1 ]; then
		case $menu_upd in
			"1") menu_msg="${v}Check driver updates list${end}"; ui_mod=1; check_update ;;
			"2") menu_msg="${v}Build module for current kernel (dkms)${end}"
					upgrade_other=0; use_dkms=1; upgrade_kernel; base_menu ;;
			"3") menu_msg="${v}Build module for current kernel (force)${end}"
					upgrade_other=0; use_dkms=0; upgrade_kernel; base_menu ;;
			"4") menu_msg="${v}Build module for the selected kernel (dkms)${end}"
					upgrade_other=1; use_dkms=1; upgrade_new_kernel; base_menu ;;
			*) base_menu ;;
		esac
	fi
}
menu_modif(){
	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(cat <<-HLP

		<b>Select here the element to modify or edit</b>:
		- <b>Edit Xorg config file</b>:
			Edit the current xorg configuration file in /etc/X11.
		- <b>Edit script config</b>:
			Edit Zenvidia basic user conf script to set or unset mostly everything.
		- <b>Edit GUI $d_zen font colors</b>:
			Change default Zenity font colors.
			<u>Note</u> : graphic UI is available with Yad installed.
		- <b>Nvidia settings</b>:
			Start Nvidia-setting graphic UI tool.
		- <b>Edit distro config</b>:
			Modify the distribution configation file.
			<u>Warning</u> : This very sensitive, bad config file breaks Zenvidia.
		- <b>Manage drivers packages</b>:
			This tool is to backup, restore and remove old or current driver install.
			It also manage dowloaded nvidia's .run pack.
			<u>Note</u> : if old installation is found during driver update,
			it is automatically backup prior to new version installation.
		- <b>Notication settings</b>:
			Configuration tool for Zen_notify daily update checker.
		- <b>Open driver switch tool</b> (optional):
			When available, this tool allow to switch between
			open and proprietary source drivers.
		HLP
		)
		w_height='--height=660'
	else
		hlp_tip="\n${vB}Select here the element to modify or edit${end}"
		w_height='--height=330'
	fi
	nd=1
	mod_menu_list=("Edit xorg config file" "Edit Zenvidia config" "Edit GUI Colors" "Nvidia-settings" "Edit Distro config" "Manage drivers packages"  "Zenvidia notification config")
	unset mod_list
	if [ $open_drv -gt 0 ]; then
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("Open driver switch tool")
		nd=$[ $nd+1 ]
	fi
	for mod_cmd in "${mod_menu_list[@]}" ; do
		mod_list+=("false")
		mod_list+=("$nd")
		mod_list+=("$mod_cmd")
		nd=$[ $nd+1 ]
	done
	menu_mod=$($d_zen --width=400 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia" \
	--text "${j}${bf}Configuration and Tools${end}${end}${v}$hlp_tip${end}" \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	"${mod_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	if [ $open_drv -gt 0 ]; then
		case $menu_mod in
			"1") test $UID = 0 && win_open_switch || is_SU; menu_modif;;
			"2") from_install=0; test $UID = 0 && edit_xorg_conf || is_SU; menu_modif;;
			"3") edit_script_conf ;;
			"4") edit_color_conf ;;
			"5") nv_config ;;
			"6") test $UID = 0 && edit_distro_conf || is_SU; menu_modif;;
			"7") test $UID = 0 && manage_pcks || is_SU; menu_modif;;
			"8") zen_notif_setup ;;
			*) base_menu ;;
		esac
	else
		case $menu_mod in
			"1") from_install=0; test $UID = 0 && edit_xorg_conf || is_SU; menu_modif;;
			"2") edit_script_conf ;;
			"3") edit_color_conf ;;
			"4") nv_config ;;
			"5") test $UID = 0 && edit_distro_conf || is_SU; menu_modif;;
			"6") test $UID = 0 && manage_pcks || is_SU; menu_modif;;
			"7") zen_notif_setup ;;
			*) base_menu ;;
		esac
	fi
}
menu_manage(){
# 	check_version
	if [ $hlp_txt = 1 ]; then
		hlp_tip=$(
		cat <<-TIP

			${v}README and Help file from Nvidia $(version) and other.${end}

			- ${vB}Documanetation${end}:\tRead the current Nvidia help file.
			- ${vB}Change Logs${end}:\tRead the current Nvidia changelog file.
			- ${vB}Zenvidia Help${end}:\tRead Zenvidia doc file.
			- ${vB}About Zenvidia${end}:\tRead current Zenvidia README file.
		TIP
		)
		w_height='--height=300'
	else
		hlp_tip="\n${v}README and Help file from Nvidia $(version) and other.${end}"
		w_height='--height=300'
	fi
	nm=1
	unset mng_list
	for mng_cmd in "Documention manual ($(version))" "Change Logs ($(version))" "Zenvidia Help" "About Zenvidia (README)"; do
		mng_list+=("false")
		mng_list+=("$nm")
		mng_list+=("$mng_cmd")
		nm=$[ $nm+1 ]
	done
	menu_mng=$($d_zen --width=400 $w_height --window-icon=$img_zen_desktop --list \
	--radiolist --hide-header --title="Zenvidia" \
	--text "${j}${bf}Help and Documentation${end}${end}${v}$hlp_tip${end}" \
	--column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	"${mng_list[@]}")
	if [ $? = 1 ]; then base_menu; fi
	case $menu_mng in
		"1") unset chapter_index chapters_list; read_nv_help ;;
		"2") unset entry_list entrylog_list; read_changelog ;;
		"3") read_help ;;
		"4") read_about ;;
		*) base_menu ;;
	esac
}
### RESCUE COMMAND LINE ###
dm_serv_restore(){ # OK
	for drv in {nvidia_uvm,nvidia_drm,nvidia_modeset,nvidia}; do
		if [ $(grep -owc "$drv" /etc/modprobe.d/blacklist.conf) -eq 0 ]; then
		drv_list+=("$drv")
		fi
	done
	test $echec = 0 && ( echo -e "${nc}# ${yel}DM and $dkms_ins drivers re-init :${nc}" )
	echo -e "${nc}# ${yel}Unload $dkms_ins drivers if any${nc}."; sleep 2
	modprobe -r -a ${drv_list[*]}
	echo -e "${nc}# ${yel}Load $cmd_ver drivers${nc}."; sleep 2
	exec_mod_load
	echo -e "${nc}# ${yel}Exec $KERNEL modules init/reload."; sleep 2
	progress_msg(){ echo -en "\r${nc}#${blu} ($m sec.) Exec $KERNEL modules initramfs."; }; m=1; do_slp=1
	#exec_mod_load
	exec_initramfs
	echo -e "\n${nc}# ${yel}Done.${nc}"
	echo -e "# ${yel}License is $license ${nc}."
	## catch console pid here
	if [ "$(dm_serv)" != "" ]; then
		test $($d_sys status $(dm_serv) | grep -c "disabled") -gt 0 && (
		echo -e "${nc}# ${yel}Restore $(dm_serv) service to 'enable'${nc}."; sleep 2; )
		$d_sys enable $(dm_serv).service
		echo -e "${nc}# ${yel}Start $(dm_serv) service${nc}."; sleep 2
		echo -e "${blu}(Press ENTER to start, CTRL-C to cancel)${nc}"; read
		$d_sys start $(dm_serv).service
	else
		echo -e "${nc}# ${yel}You can 'enable' and 'start' your Display Manager now.${nc}."
	fi
	## trying to kill console root's tty.
	if [ $(w | grep -c "root.*tty") -gt 0 ]; then
		sleep 40
		pkill -9 -t $(w | grep "root.*tty" | awk '{print $2}')
	fi
}
restore_cmdline(){ # OK
	echec=0
	echo -e "# ${yel}Restoring $cmd_ver driver for $KERNEL${nc} :\n"
	sleep 2
	## clean old librairies
	if [ "$dkms_ins" != "" ]; then
		if [[ $cmd_ver != $dkms_ins ]]; then
			echo -e "# ${blu}Cleaning $dkms_ins old installation${nc} ..."
			sleep 2
			rm -f /usr/$master$ELF_64/xorg/modules/extensions/libglxserver_nvidia.so.$dkms_ins
			rm -f $install_dir/$master$ELF_32/libnvidia-*.so.$dkms_ins
			rm -f $install_dir/$master$ELF_64/libnvidia-*.so.$dkms_ins
			test -d /var/lib/dkms/nvidia/$dkms_ins && $p_dkms remove nvidia/$dkms_ins --all
			test -d /var/lib/dkms/open-nvidia/$dkms_ins && $p_dkms remove open-nvidia/$dkms_ins --all
			rm -Rf /usr/src/nvidia-$dkms_ins
			test -d /usr/src/open-nvidia-$dkms_ins && rm -Rf /usr/src/open-nvidia-$dkms_ins
			sleep 2
		fi
	fi
	echo -e "# ${yel}Uncompressing $cmd_ver archive for $KERNEL${nc} :\n"
	tar -zvxf $nvbackup/nvidia.$cmd_ver.tar.gz -C /
	echo -e "\n# ${blu}- Registering $cmd_ver librairies (ldconfig)${nc} ..."
	ldconfig
	echo -e "# ${blu}- Depmod $cmd_ver modules ..."
	progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
	m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
	## check modules
	echo -e "\n${nc}# ${blu}- Testing $cmd_ver modules availbility${nc} ..."
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	test $vermagic && echo -e "# ${yel}Initramfs update${nc}." || \
	( echo -e "# ${red}Test failed${nc}."; echec=1; rebuild_cmdline )
	sleep 2
	if [ $echec = 0 ]; then
		echo -e "\n${nc}# ${yel}Done.${nc}"
		echo -e "# ${yel}License is $license ${nc}.\n"
		dm_serv_restore
	fi
}
rebuild_cmdline(){
	if [ $echec = 1 ]; then
		echo -e "# ${red}WARNING ${yel}: No $cmd_ver modules set in the backup${nc}.\n"; sleep 2
	fi
	clear
	echo -e "# ${yel}Build & Install $cmd_ver DKMS $KERNEL modules ($license) :${blu}"; sleep 2
	if [ $($p_dkms status -m $module/$cmd_ver -k $KERNEL| grep -cv "added") -gt 0 ]; then
		$p_dkms remove -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms add -m "$module/$cmd_ver" -k $KERNEL
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL
	else
		$p_dkms install -m "$module/$cmd_ver" -k $KERNEL --force
	fi
	## recheck modules
	vermagic=$($d_modinfo -F vermagic nvidia -k $KERNEL| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [[ $vermagic ]]; then
		echo -e "\n${nc}# ${yel}Initramfs update.${blu}"; sleep 2
		dm_serv_restore
	else
		echo -e "\n# ${red}Failed${nc}."
	fi
}
rescue_cmdline(){
	## modinfo will display error if modules is not found, just add comments.
	clear
	echo -e "# ${yel}Compling $module $cmd_ver sources${nc} :\n" ; sleep 2
	kernel_module_src=/usr/src/$module-$cmd_ver
	cd $kernel_module_src; make -j12
	## check again
	vermagic=$($d_modinfo -F vermagic $kernel_module_src/nvidia.*[ko\|ko.xz]| awk '{print $1}')
	license=$($d_modinfo -F license nvidia -k $KERNEL)
	if [ $vermagic ]; then
		if [[ $vermagic == $KERNEL ]]; then
			cp -f *.ko $libmod/
			## compress modules.
			clear
			echo -e "# ${blu}- Compressing modules if needed${nc}."; sleep 2
			is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
			[ $is_RT = 0 ]|| xz -T12 $libmod/*.ko
			echo -e "# ${blu}- Depmod $cmd_ver modules ..."
			progress_msg(){ echo -en "\r${nc}#${blu} - Depmod $cmd_ver modules ($m sec.)"; }
			m=1; do_slp=1; progress "( exec_depmod "$KERNEL" )"; rm -f $tmp_c
			## rebuild initramfs in case of trouble booting.
			clear
			dm_serv_restore
		fi
	else
		echo -e "${nc}#${red} *** Something went wrong ! ***\n${nc}#${yel} Restoration script can't proceed, exit${nc}."
	fi
}
## root warning
is_SU(){
	w_text=$(cat <<-WRN
	${y}${bf}Your are not root${end}${end}
	This command can't be executed with ${j}<b>Zenvidia (user)</b>${end} unprivilegded desktop entry.
	See ${j}<b>Zenvidia</b>${end} <i>(admin)</i> desktop entry instead.
	WRN
	)
	$d_zen --width=450 --title="Zenvidia" --window-icon=$img_zen_desktop --warning --no-wrap \
	--text="${v}$w_text${end}" --icon-name=swiss_knife --ok-label="Got it"
}
### MAIN MENUS ###
base_menu(){
	devices(){
	for e in $pci_dev_nb; do
		printf "${vB}Card %s :\t\t\t${end} ${j}${dev[$e]}\t($(printf "${vnd[$e]}"|awk '{print $1}'))${end}\n" $((${dev_n[$e]}+1))
	done
	}
	open_check(){
	if [ $open_drv ]&&[ $open_drv = 1 ]; then
		if [ $use_open ]; then
			if [ $use_open = 1 ]; then open_used=" and in use\n"; else open_used=", but unused\n"; fi
		else
			open_used=", closed source used\n"priviledge_msg
		fi
		printf "${vB}Open Source modules :\t ${end}${j} installed$open_used${end}"
	fi
	}
	right_check(){
		if [ $UID = 0 ]; then
			echo "You have root priviledge"
		else
			echo "You are not root (download, install, restore unavailable)"
		fi
	}
	# remove deplist list in case of relaunching first because an update asking to
	unset deplist
	w_height=450
	hlp_tip_txt=$( cat <<-HLP
		Help tips text is currently set. You can unset it at any
		moment in: ${j}Configuration and Tools${end} menu » ${j}Edit script config${end}.\n\n"
	HLP
	)
	[ $hlp_txt = 0 ]|| { hlp_wrn="$hlp_tip_txt"; w_height=$(($w_height+50)); }	
	window_text=$( cat <<-MSG
		${rBB}\t\t   ZENVIDIA${end}
		${y}${nf}\t\t   Close and Open Source
		\t\t   Nvidia drivers manager${end}${end}
		${vB}\nSystem :\t\t${end} ${j}$DISTRO${end}
		${vB}Processor type :\t\t${end} ${j}$ARCH${end}
		$(devices)
		${vB}Driver version installed : ${end}  ${j}$(version_id)${end}$restore_msg
		${vB}Kernel version :\t\t${end} ${j}$KERNEL${end}
		${vB}GCC version :\t\t${end} ${j}$GCC${end}
		${vB}NVIDIA binary version :\t${end} ${j}$NV_bin_ver${end}$restore_msg
		$(open_check)
		${v}Network connection :${end}  ${j}$cnx_msg${end}
		${v}Rights :${end}  ${j}$(right_check)${end}

		${v}$hlp_wrn$ansWN${end}
	MSG
	)
	menu_cmd=$($d_zen --width=400 --height=$w_height --title="Zenvidia" --list --window-icon=$img_zen_desktop \
	--radiolist --hide-header --column "1" --column "2" --column "3" --separator=";" --hide-column=2 \
	--text="$window_text" \
	false 1 "Install drivers" false 2 "Update drivers or modules" false 3 "Configuration and Tools" false 4 "Help and Documentation" )
	if [ $? = 1 ]; then exit 0; fi
	case $menu_cmd in
		"1") if_update=0; test $UID = 0 && initramfs_warn; menu_install || is_SU; base_menu;;
		"2") if_update=1; test $UID = 0 && initramfs_warn; menu_update || is_SU; base_menu;;
		"3") if_update=1; menu_modif ;;
		"4") if_update=1; menu_manage ;;
		*) exit 0 ;;
	esac
}
install_controls(){
	# check nvidia dir presence
	if [ -d $install_dir/NVIDIA ] ; then
		dir_msg="${j} OK${end}"
	else		
		dir_msg="${j}OK\n${y}NVIDIA repository doesn't exist${end}"
		$d_zen --width=400 --window-icon=$img_zen_desktop --error --no-wrap --title="Zenvidia" \
		--text="$dir_msg"
	fi
	# check/change run packages permission
	nvdl_last=$(ls -1 $nvdl/|sed -n '$p')
	if [[ -s $nvdl/$nvdl_last ]] ; then
		for changes in $(ls -1 $nvdl ); do
			if [[ $(stat -c "%a" $nvdl/$changes) != 755 ]]; then
				chmod 755 $nvdl/$changes
			fi
		done
	fi
}
start_cmd(){
## this for function testing only in "$1"
# 	if [[ $cmd_opt != '' ]]; then
# 		$($cmd_opt)
# 	fi
	## check if X server is off before lauching cmd line tools.
# 	xprop -root &>/dev/null
# 	if [ $? -gt 0 ]; then
	if [ $x_alive -gt 0 ]; then
		help_text(){
			cat <<-HT
				Command line option : $(basename $0 ) [option] [driver version]
				Options :
				   restore	-> restore driver backup.
				   rebuild	-> rebuild driver.
				   rescue	-> force driver build from sources.
				   reinit	-> Rebuild initramfs and start DM.
			HT
			if [ $(ls -1 $nvbackup | grep -c .) -gt 0 ]; then
				echo -e "Driver version backups :"
				ls -1 $nvbackup | sed -En "s/^nvidia.([0-9]*.*).tar.gz/ - \1/p"
			fi
			file -E $libmod/nvidia.*[ko\|ko.xz] &>/dev/null
			if [ $? -eq 0 ]; then
				echo -e "Installed driver version : $dkms_ins"
			else
				echo -e "Found dkms driver version : $module » $dkms_ver"
			fi
			echo -e "Display Manager : $(dm_serv)"
		}
		libmod='/lib/modules/'$KERNEL'/'$(module_dest_location)
		echo -e "** ${red}X server not runing${nc} **"
		echo -e "${yel}"
		if [ -f /etc/modprobe.d/open-NVIDIA.conf ]; then
			module='open-nvidia'
			license='Dual MIT/GPL'
		else
			module='nvidia'
			license='NVIDIA'
		fi
		## check realtime kernel.
		is_RT=$(grep -ic "CONFIG_PREEMPT_RT=y" /boot/config-$KERNEL)
		if [ $is_RT = 1 ]; then
			ignore_RT='IGNORE_PREEMPT_RT_PRESENCE=1'
			export IGNORE_PREEMPT_RT_PRESENCE=$is_RT
		fi
		## check dkms mods list.
		dkms_mod=$($p_dkms status -m $module | grep -v "added"| cut -d, -f1)
		dkms_ver=$(echo -e "$dkms_mod"| cut -d"/" -f2)
		dkms_ins=$($d_modinfo -F version $libmod/nvidia.*[ko\|ko.xz])
		echec=0
		if [[ $cmd_ver != '' ]]; then
			case $cmd_opt in
				restore) restore_cmdline ;;
				rebuild) rebuild_cmdline ;;
				rescue) rescue_cmdline ;;
				reinit) dm_serv_restore;;
				*) help_text ;;
			esac
		else
			 help_text
		fi
		echo -e "${nc}"
		exit 0
	else
		dep_control
		install_controls
		connection_control
		# define gcc options if defined.
		gcc_options
		base_menu
	fi
}
## BASICS CHECK ###
## configuration file
if [ ! -s $script_conf ]; then $d_zen --window-icon=$img_zen_desktop --width=250 --error --icon-name=xkill --text="Script's config file missing."; exit 0; fi
## set default or null value before conf files reading.
use_dkms=1	# TODO FIXME make use_dkms default and remove var ?
use_uvm=0
use_drm=1
use_open=0
open_drv=0
no_warn=0
open_wrn=1
first_open=1
from_install=0
exec_mod_tool=0
ARCH=$HOSTTYPE

## ### SCRIPT INTRO ###
# check distro elf type
libclass
# check distro and load specific config.
distro
# cmdline tool doesn't need to read config, so skip the step if in console only.
if [[ $(def_user) != "root" ]]; then
# check if default user has conf file to load, or create it from shipped.
	for conf in {basic,color}; do
		if [ -f $(user_CF_DIR)/$conf.conf ]; then
			eval ${conf}_conf=$(user_CF_DIR)/$conf.conf
		else
			cp -f $nvdir/$conf.conf $(user_CF_DIR)/
			chown $(def_user):$(def_user) $(user_CF_DIR)/$conf.conf
			eval ${conf}_conf=$(user_CF_DIR)/$conf.conf
		fi
	done
## then read script conf.
. $basic_conf
. $color_conf
fi
## INITIALS checks
# load $d_zen span font colors.
zen_colors
# pick all necessary env Definition
compil_vars
PCI_ID
## pick cmd line options if any (X server off only).
cmd_opt=$1; cmd_ver=$2
## ### LET'S START ###
start_cmd
exit 0
